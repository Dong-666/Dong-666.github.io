<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络-运输层 | Dong</title><meta name="author" content="天际线上的猪"><meta name="copyright" content="天际线上的猪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面向通信部分的最高层，用户功能中的最低层，让我们来看看运输层吧">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-运输层">
<meta property="og:url" content="http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="Dong">
<meta property="og:description" content="面向通信部分的最高层，用户功能中的最低层，让我们来看看运输层吧">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://dong-666.github.io/img/code.jpg">
<meta property="article:published_time" content="2021-04-18T07:28:20.000Z">
<meta property="article:modified_time" content="2022-04-17T13:32:15.603Z">
<meta property="article:author" content="天际线上的猪">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://dong-666.github.io/img/code.jpg"><link rel="shortcut icon" href="/img/favicon3.png"><link rel="canonical" href="http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 天际线上的猪","link":"链接: ","source":"来源: Dong","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络-运输层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-17 21:32:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Dong" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/te/"><i class="fa-fw fas fa-map"></i><span> 疫情地图</span></a></div><div class="menus_item"><a class="site-page" href="/todolist/"><i class="fa-fw fas fa-check-circle"></i><span> ToDoList</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> Gallery</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/code.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Dong"><span class="site-name">Dong</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/te/"><i class="fa-fw fas fa-map"></i><span> 疫情地图</span></a></div><div class="menus_item"><a class="site-page" href="/todolist/"><i class="fa-fw fas fa-check-circle"></i><span> ToDoList</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> Gallery</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络-运输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-18T07:28:20.000Z" title="发表于 2021-04-18 15:28:20">2021-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-17T13:32:15.603Z" title="更新于 2022-04-17 21:32:15">2022-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络-运输层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>注：内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层主要是面向通信部分的最高层，同时也是用户功能中的最低层。主要有以下两点</p>
<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有</strong>位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406162023935.png" alt="image-20210406162023935"></p>
<h2 id="逻辑通信"><a href="#逻辑通信" class="headerlink" title="逻辑通信"></a>逻辑通信</h2><p>运输层为相互通信的应用进程提供<strong>逻辑通信</strong></p>
<ul>
<li>逻辑通信：好像是这样通信，但事实上并非真的这样通信</li>
</ul>
<p>通过以下图结合来理解，在平行上，应用进程之间是通过运输层进行通信的（逻辑通信），但实际上数据的传递依旧还是要通过下一层网络层及下下层再通过路由器进行传递的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406162844136.png" alt="image-20210406162844136"></p>
<p>这里举个形象的栗子：你要写信给你的盆友，你只要记得门口邮箱在哪个位置，然后投进你的信件，而不需要考虑它是怎样进行运输从而到达盆友门口邮箱里的，盆友也只用直接从他家门口邮箱里取即可，这里的邮箱好比就是运输层，你们的交流就好像是通过邮箱（逻辑通信）进行的，但实际上邮件还是依然要通过多个运输环节（五层协议）才能到达盆友家。</p>
<h2 id="屏蔽作用"><a href="#屏蔽作用" class="headerlink" title="屏蔽作用"></a>屏蔽作用</h2><blockquote>
<p>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
</blockquote>
<p>正因为前面的逻辑通信，所以我们可以专注于运输层的两个进程通信问题，而不必去关心底层的实现</p>
<p>从IP层来说，通信的两端是两台主机。</p>
<p>从运输层的角度看，通信的真正端点并不是主机而是主机中的<strong>进程</strong>。也就是说，端到端的通信是<strong>应用进程之间的通信</strong>。</p>
<p><strong>端系统之间通信的含义</strong>：运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。端到端的通信是进程之间的通信</p>
<h2 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h2><p>复用：多个应用层进程汇聚成一个传输层进程</p>
<p>分用：传输层的单个进程通向多个应用层进程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406163750181.png" alt="image-20210406163750181"></p>
<p>形象来说：复用就是多车道变成单车道运输层，分用就是单车道分多车道通向多个应用进程（UDP会涉及到）</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><ul>
<li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406164635108.png" alt="image-20210406164635108"></p>
<h3 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h3><ul>
<li><strong>无连接</strong>的协议，提供无连接服务;</li>
<li>其传送的运输协议数据单元TPDU是UDP报文或用户数据报;</li>
<li>支持单播、多播、厂播;</li>
<li><strong>不提供可靠交付</strong>;</li>
<li>简单。适用于很多应用，如: 多媒体应用等。</li>
</ul>
<h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul>
<li>面向连接的协议，提供面向连接服务;</li>
<li>其传送的运输协议数据单元TPDU是TCP报文;</li>
<li>支持点对点单播，<strong>不支持多播、广播</strong>;</li>
<li>提供可靠服务;</li>
<li>复杂，用于大多数应用，如:万维网、电子邮件、文件传送等。</li>
</ul>
<h3 id="各自的应用范围"><a href="#各自的应用范围" class="headerlink" title="各自的应用范围"></a>各自的应用范围</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406165018430.png" alt="image-20210406165018430"></p>
<p>其中动态主机配置DHCP是在应用层ip地址动态分配时的相关应用，HTTP协议是客户端与服务器端交互的相关规则与约定</p>
<h2 id="IP数据报、TCP和UDP的关系"><a href="#IP数据报、TCP和UDP的关系" class="headerlink" title="IP数据报、TCP和UDP的关系"></a>IP数据报、TCP和UDP的关系</h2><ul>
<li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。<ul>
<li>IP 数据报要经过互连网中许多路由器的存储转发。</li>
<li>UDP 用户数据报是在运输层的端到端抽象的<strong>逻辑信道</strong>中传送的。</li>
</ul>
</li>
<li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却<strong>不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接</strong>。 </li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote>
<p>运行在计算机中的进程是用进程标识符来标志的。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406165416517.png" alt="image-20210406165416517"></p>
<h3 id="为什么会有端口"><a href="#为什么会有端口" class="headerlink" title="为什么会有端口"></a>为什么会有端口</h3><ol>
<li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li>
<li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li>
<li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li>
</ol>
<p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<p>形象地说：ip地址更像是标识你家在哪栋楼，端口更像是标识你是哪间房</p>
<h3 id="硬件端口和软件端口"><a href="#硬件端口和软件端口" class="headerlink" title="硬件端口和软件端口"></a>硬件端口和软件端口</h3><ul>
<li>在协议栈层间的抽象的协议端口是软件端口。</li>
<li>路由器或交换机上的端口是硬件端口。</li>
</ul>
<p>也就是说：硬件端口是 用来连接各个硬件设备的，而软件端口则是应用层的<strong>各种协议进程与运输实体进行层间交互</strong>的一种地址</p>
<h3 id="端口位数"><a href="#端口位数" class="headerlink" title="端口位数"></a>端口位数</h3><p>端口用一个 16 位端口号进行标志，允许有65,535（2¹⁶）个不同的端口号</p>
<p>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p>
<p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）。</p>
<h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><ul>
<li>服务器端使用的端口号<ul>
<li>熟知端口，数值一般为 0 ~ 1023。</li>
<li>登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
</ul>
</li>
<li>客户端使用的端口号<ul>
<li>又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。</li>
<li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406170331878.png" alt="image-20210406170331878"></p>
<h1 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h1><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能</p>
<ol>
<li><strong>复用和分用</strong>的功能</li>
<li><strong>差错检测</strong>的功能</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406194530087.png" alt="复用和分用"></p>
<p>前面已经简单的介绍了UDP的特点了，这里补充其它的特点以及这些特点的优点</p>
<ul>
<li><strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。</li>
<li><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li>
<li><strong>UDP 是面向报文的。</strong>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 </li>
<li><strong>UDP 没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li>
<li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</li>
<li><strong>UDP 的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ul>
<p>再来看看UDP的这两个特点</p>
<ul>
<li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li>
<li>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</li>
</ul>
<p>这意味着什么，接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p>
<p>所以如果你的报文太长，UDP把它交给IP层后，IP层再传送时就可能要分片，这会降低IP层的效率，而如果报文太短，则IP数据报的首部相对于报文会太长，同样也会降低IP层效率，所以应用程序必须选择合适的报文长度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406200653561.png" alt="image-20210406200653561"></p>
<h2 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h2><p>用户数据报 UDP 有两个字段：数据字段和首部字段。<br>首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节</p>
<p>在计算检验和时，临时把 12 字节的“伪首部”和 UDP 用户数据报连接在一起。<strong>伪首部仅仅是为了计算检验和</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406200825674.png" alt="image-20210406200825674"></p>
<p>计算检验和这里不展开说（因为没去算），感兴趣可以通过书本理解</p>
<h1 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h1><blockquote>
<p>TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。</p>
</blockquote>
<p>同样以复用和分用进行通信</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201305393.png" alt="image-20210406201305393"></p>
<h2 id="TCP-最主要的特点"><a href="#TCP-最主要的特点" class="headerlink" title="TCP 最主要的特点"></a>TCP 最主要的特点</h2><ul>
<li>TCP 是面向连接的运输层协议。</li>
<li>每一条 TCP 连接<strong>只能有两个端点</strong> (endpoint)，每一条 TCP 连接<strong>只能是点对点</strong>的（一对一）。 </li>
<li>TCP 提供<strong>可靠交付</strong>的服务。</li>
<li>TCP 提供<strong>全双工</strong>通信。</li>
<li><strong>面向字节流</strong><ol>
<li>TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。</li>
<li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是<strong>一连串无结构的字节流</strong>。</li>
</ol>
</li>
</ul>
<p>TCP面向流的具体说明</p>
<blockquote>
<p>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。</p>
<p>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201834256.png" alt="image-20210406201834256"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201944463.png" alt="image-20210406201944463"></p>
<p>注意：</p>
<ol>
<li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li>
<li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li>
<li>TCP 根据对方给出的<strong>窗口值</strong>（<a href="#TCP的流量控制">流量控制</a>）和<strong>当前网络拥塞</strong>（<a href="#TCP的拥塞控制">拥塞控制</a>）的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li>
<li>TCP 可把太长的数据块<strong>划分</strong>短一些再传送。</li>
<li>TCP 也可<strong>等待积累</strong>有足够多的字节后再构成报文段发送出去。</li>
</ol>
<p>后面几节会具体展示其是如何工作的（可靠传输），以及这些关键点的实现</p>
<h2 id="TCP的连接（套接字）"><a href="#TCP的连接（套接字）" class="headerlink" title="TCP的连接（套接字）"></a>TCP的连接（套接字）</h2><ul>
<li>TCP 把连接作为<strong>最基本的抽象</strong>。</li>
<li>每一条 TCP 连接有两个<strong>端点</strong>。</li>
<li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字 (socket) 或插口</strong>。</li>
<li><strong>端口号拼接到 (contatenated with) IP 地址即构成了套接字。</strong> </li>
</ul>
<p>下面通过图理解套接字</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406202414660.png" alt="image-20210406202414660"></p>
<p>套接字的格式：<strong>套接字 socket = (IP地址 : 端口号)</strong></p>
<p>例子：<strong>套接字 socket = (192.169.1.20 : 2028)</strong></p>
<p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406202530840.png" alt="image-20210406202530840"></p>
<p>根据以上可以得出</p>
<ul>
<li>TCP 连接就是由协议软件所提供的一种抽象。</li>
<li>TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。</li>
<li>同一个 IP 地址可以有多个<strong>不同的 TCP 连接</strong>。</li>
<li>同一个端口号也可以出现在多个不同的 TCP 连接中。</li>
</ul>
<p>Socket其实有多种含义，在不同的场景其含义不同，比如</p>
<ul>
<li>应用编程接口  API  称为 socket API, 简称为 socket。</li>
<li>socket API 中使用的一个函数名也叫作 socket。</li>
<li>调用 socket 函数的端点称为 socket。</li>
<li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</li>
<li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现</li>
</ul>
<h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>直接上图——TCP也就是建立在IP协议不可靠传输上的可靠传输（前面有讲过）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406203105228.png" alt="image-20210406203105228"></p>
<p>让我们试想一下：我们希望的传输是不会出差错的，也就是不论发送何种文件，你都希望它能稳定可靠的传输到目的地去，以及接收方能准时无误的接收到你传送的文件，不希望它在某个过程中出现差错，以致于你要重新去传输该文件，所以理想传输总结起来有两点：</p>
<ol>
<li>传输信道不产生差错。</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ol>
<p>然而实际上网络并非如此，它都不具备以上两个理想条件，所以我们必须使用一些可靠传输协议（TCP），在不可靠的传输信道（IP）实现可靠传输</p>
<h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><blockquote>
<p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
</blockquote>
<p>我们知道：TCP是提供全双工工作方式的，也就是通信双方即是发送方也可以是接收方，但是这里为了方便，只考虑单方向（双方向工作原理一致）。定为A→发送方，B→接收方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406204405025.png" alt="image-20210406204405025"></p>
<p>A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。如此循环反复下去。</p>
<p>那么问题来了，出错了咋办，让我们先来看看接收方B在传输过程可能会出现的错误</p>
<p>在接收方 B 会出现两种情况：</p>
<ol>
<li>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。</li>
<li>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li>
</ol>
<p>在这两种情况下，B 都不会发送任何信息。但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。那么问题又来了，A怎么知道自己是否该重传分组了呢，没错，超时重传</p>
<h3 id="超时重传（自动重传请求-ARQ）"><a href="#超时重传（自动重传请求-ARQ）" class="headerlink" title="超时重传（自动重传请求 ARQ）"></a>超时重传（自动重传请求 ARQ）</h3><ol>
<li>A 为每一个已发送的分组都设置了一个超时计时器。</li>
<li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li>
<li>若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406205258419.png" alt="image-20210406205258419"></p>
<h3 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h3><p>接下来，看看超时重传会遇到的问题</p>
<blockquote>
<p>若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？</p>
</blockquote>
<p>解决方法便是“编号”</p>
<ul>
<li>A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。</li>
<li>B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。</li>
<li>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</li>
</ul>
<h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p>好滴，又有问题了（你这问题怎么这么多！！！）</p>
<ol>
<li><p>如果接收方Bd的确认在路上直接丢失了呢（确认丢失）</p>
<p>又或者</p>
</li>
<li><p>传输过程中没有出现差错，但 B 对分组 M1 的确认迷路了，走了点弯路，然后迟到了呢（确认迟到）</p>
</li>
</ol>
<p>让我们先来解决第一个问题</p>
<blockquote>
<p>首先，A会<strong>超时重发</strong>，然后收到确认，这没啥可说的，重点是B，接收方B会收到两次分组，那么它会怎么做，是的，<strong>丢掉当前这一个分组并重传确认分组</strong>。为什么要重传确认，B说它之前不是发过一次了吗，当然要发，它不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</p>
</blockquote>
<p>第二个问题的解决</p>
<blockquote>
<p>首先，A收到了B延迟的M1确认，这时，它已经将缓冲的备份分组发出去了，那么当他收到第二次重复的确认时，<strong>它会丢弃重复的确认</strong></p>
<p>而B也仍然会收到重复的 M1，它同样会<strong>丢弃重复的 M1</strong>，并重传确认分组。</p>
</blockquote>
<p>最后，用一个图来理解这两个概念</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406211258525.png" alt="image-20210406211258525"></p>
<p><strong>注意</strong></p>
<ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</li>
<li>分组和确认分组都必须进行编号。（区分不同的分组以及确认）</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 （以防迷了点小路而导致重传浪费性能）</li>
</ul>
<p>总结下停止等待协议的要点</p>
<ol>
<li><strong>停止等待</strong>。发送方每次只发送一个分组。在收到确认后再发送下一个分组。</li>
<li><strong>编号</strong>。对发送的每个分组和确认都进行编号。</li>
<li><strong>自动重传请求</strong>。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。</li>
<li><strong>简单，但信道利用率太低</strong>。（信道利用率那一节会讲到该特点以及解决方法）</li>
</ol>
<h2 id="自动重传请求-ARQ"><a href="#自动重传请求-ARQ" class="headerlink" title="自动重传请求 ARQ"></a>自动重传请求 ARQ</h2><p>通过上面的学习：我们可以了解到B不论何时都不需要跟A说分组丢失，要它重传了，因为这些分组该来总会来的（超时重传），A不会欠B的。像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p>
<ul>
<li>通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</li>
<li>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</li>
</ul>
<h2 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h2><p>不知道你们有没有发现：每次A发送分组后，需要等待B的确认分组到达后才会发送下次分组，这样的信道利用率是不是会有点低</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212057270.png" alt="image-20210406212057270"></p>
<p>信道利用率公式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212330913.png" alt="image-20210406212330913"></p>
<p>可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。<br>若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。</p>
<h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。<br>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。<br>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212431804.png" alt="image-20210406212431804"></p>
<h3 id="连续-ARQ协议"><a href="#连续-ARQ协议" class="headerlink" title="连续 ARQ协议"></a>连续 ARQ协议</h3><p>基本思想：</p>
<ol>
<li>发送方一次可以发出<strong>多个分组</strong>。</li>
<li>使用<strong>滑动窗口协议</strong>控制发送方和接收方所能发送和接收的分组的数量和编号。</li>
<li>协议规定：每收到一个确认，发送方就把发送窗口<strong>向前滑动</strong>。</li>
<li>接收方一般采用<strong>累积确认</strong>的方式。</li>
<li>采用<strong>回退N</strong>（Go-Back-N）方法进行重传（后面有解释）。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212801263.png" alt="image-20210406212801263"></p>
<h4 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h4><blockquote>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p>
</blockquote>
<ol>
<li>优点：容易实现，即使确认丢失也不必重传。</li>
<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213216445.png" alt="image-20210406213216445"></p>
<p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。<br>这就叫做 <strong>Go-back-N（回退 N）</strong>，表示需要再退回来重传已发送过的 N 个分组。<br>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213809411.png" alt="image-20210406213809411"></p>
<p>TCP 连接的每一端都必须设有两个窗口——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。<br>TCP 的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP 所有的确认都是基于序号而不是基于报文段。<br>TCP 两端的四个窗口经常处于<strong>动态变化</strong>之中。<br>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法<strong>估算较为合理的重传时间</strong>。 </p>
<p>滑动窗口协议比较复杂，是 TCP 协议的精髓所在。<br>发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p><strong>通过图片理解</strong></p>
<p>首先：定义一个发送窗口以及接收窗口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213310884.png" alt="image-20210406213310884"></p>
<p>开始发送</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213550163.png" alt="image-20210406213550163"></p>
<p>接收到正确分组</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213611980.png" alt="image-20210406213611980"></p>
<p>继续下个窗口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213625768.png" alt="image-20210406213625768"></p>
<h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><blockquote>
<ol>
<li>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。</li>
<li>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。</li>
<li>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406215738080.png" alt="image-20210406215738080"></p>
<p>接下来，对每个部分进行说明</p>
<p><strong>源端口和目的端口字段</strong>——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 </p>
<p><strong>序号字段seq</strong>——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 为当前端成功发送的数据位数</p>
<p><strong>确认号字段ack</strong>——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </p>
<p>若确认号 = N，则表明：到序号N-1为止所有的数据都已正确收到</p>
<p><strong>数据偏移（即首部长度）</strong>——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 </p>
<p><strong>保留字段</strong>——占 6 位，保留为今后使用，但目前应置为 0。 </p>
<p><strong>紧急 URG</strong> —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </p>
<p><strong>确认 ACK</strong> —— 只有当 ACK =1 时确认号字段才有效。当 ACK =0 时，确认号无效。 </p>
<p><strong>推送 PSH (PuSH)</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p>
<p><strong>复位 RST (ReSeT)</strong> —— 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </p>
<p><strong>同步 SYN</strong> —— 同步 SYN = 1 表示这是一个连接请求（ACK = 0）或连接接受报文（ACK = 1）。 </p>
<p><strong>终止 FIN (FINish)</strong> —— 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </p>
<p><strong>窗口字段</strong> —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
<p><strong>检验和</strong> —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>在计算检验和时，临时把 12 字节的“伪首部”和 TCP 报文段连接在一起。伪首部仅仅是为了计算检验和。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406220316580.png" alt="image-20210406220316580"></p>
<p><strong>紧急指针字段</strong> —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 </p>
<p><strong>选项字段</strong> —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的<strong>缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</strong>。” </p>
<ul>
<li><p>MSS (Maximum Segment Size)<br>是 TCP 报文段中的数据字段的最大长度。<br>数据字段加上 TCP 首部才等于整个的 TCP 报文段。<br>所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。</p>
</li>
<li><p>为什么规定MSS</p>
<blockquote>
<p>MSS 与接收窗口值没有关系。</p>
<p>若选择较小的 MSS 长度，网络的利用率就降低。</p>
<p>若 TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。</p>
<p>因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。</p>
<p>但最佳的 MSS 是很难确定的。</p>
</blockquote>
</li>
</ul>
<p><strong>其他选项</strong></p>
<ul>
<li><strong>窗口扩大选项</strong> ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li>
<li><strong>时间戳选项</strong>——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</li>
<li><strong>选择确认选项</strong>——在后面的”TCP可靠传输的实现”介绍。 </li>
</ul>
<p><strong>填充字段</strong> —— 这是为了使整个首部长度是 4 字节的整数倍。 </p>
<h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><h2 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h2><p>前面讲了可靠传输原理中的流水线传输以及连续 ARQ协议以及后面实现的图示，这里通过回顾来补充和引入新知识点</p>
<ul>
<li>TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。</li>
<li>TCP 的滑动窗口是以字节为单位的。</li>
<li>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</li>
<li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li>
<li>接收窗口表示：只允许接收落入窗口内的数据。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407150007573.png" alt="image-20210407150007573"></p>
<p>通过图，可以知道：</p>
<ul>
<li>首先，根据 B 给出的接收窗口值，A 构造出自己的发送窗口。但是不能大于B的窗口，否则可能超出B的接收范围</li>
<li>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 </li>
<li>发送窗口里面的序号表示允许发送的序号。</li>
<li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但其实它还是会收到一些其它因素的影响，比如网络堵塞，后面会讲到</li>
</ul>
<p>图里讲到TCP标准强烈不建议发送窗口前沿向后收缩，这是为啥嘞，因为在你收缩的时候这些数据可能已经发送出去了，到时候等窗口移过去你又发送一遍，就会发生错误</p>
<p>现在假设A发送了11个字节的数据，但B这边出了点状况，有部分字节没有按序收到，可能是31出错了，导致32、33没有按序收到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407150227334.png" alt="image-20210407150227334"></p>
<p>这时候B会怎么做，它会等待缺少的数据到来（这里要注意：如同前面讲的，发送方会未确认序号开始一次性把后面的数据发送来，尽管接收方已经接收到了后面的数据。且等新数据到来后接收方依旧会丢弃掉这些重复的数据）</p>
<p>而等到数据正确到来，接收方也准确无误把它们交付给上一层后，窗口就会丢掉这些值，并向前移动<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152428236.png" alt="image-20210407152428236"></p>
<p>而如果当A 的发送窗口内的序号都已用完，但还没有再收到确认，那么A就必须停止发送。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407151335623.png" alt="image-20210407151335623"></p>
<h3 id="发送缓存与接收缓存"><a href="#发送缓存与接收缓存" class="headerlink" title="发送缓存与接收缓存"></a>发送缓存与接收缓存</h3><p>发送方以及接收方的窗口都会包含缓存，用于存储临时数据</p>
<p>发送方的应用进程会把字节流写入 TCP 的发送缓存。直到接收方正确接收了，它就会把缓存删除。发送缓存存放的数据主要为两种</p>
<ol>
<li>暂存TCP准备发送的数据；</li>
<li>暂时存放TCP 已发送出但尚未收到确认的数据。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152605336.png" alt="image-20210407152605336"></p>
<p>接收方的应用进程也会从 TCP 的接收缓存中读取字节流。</p>
<p>所以其会暂时存取两种数据</p>
<ol>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152743085.png" alt="image-20210407152743085"></p>
<p>根据以上，我们需要强调以及知道以下三点</p>
<p>第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</p>
<p>第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</p>
<p>第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 </p>
<p>对于接收方：它可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点：</p>
<ol>
<li><p>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。</p>
</li>
<li><p>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</p>
</li>
</ol>
<h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>重传时间的选择是 TCP 最复杂的问题之一。</p>
<p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。</p>
<p>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p>
<p>因此TCP 采用了一种<strong>自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3><ul>
<li>TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）。</li>
<li>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154611456.png" alt="image-20210407154611456"></p>
<p>式中，0 ＜= α ＜ 1。若 α 很接近于零，表示 RTT 值更新较慢。若选择 α 接近于 1，则表示 RTT 值更新较快。<br>RFC 6298 推荐的 α 值为 1/8，即 0.125。 </p>
<h3 id="超时重传时间-RTO"><a href="#超时重传时间-RTO" class="headerlink" title="超时重传时间 RTO"></a>超时重传时间 RTO</h3><p>RTO (Retransmission Time-Out) 应<strong>略大于</strong>上面得出的加权平均往返时间 RTTS。</p>
<p>RFC 6298 建议使用下式计算 RTO：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154857678.png" alt="image-20210407154857678"></p>
<p>RTTD 是 RTT 的偏差的加权平均值。<br>RFC 6298 建议这样计算RTTD 。第一次测量时， RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD ：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154926977.png" alt="image-20210407154926977"></p>
<p>β是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p>
<h3 id="往返时间-RTT-的测量相当复杂"><a href="#往返时间-RTT-的测量相当复杂" class="headerlink" title="往返时间 (RTT) 的测量相当复杂"></a>往返时间 (RTT) 的测量相当复杂</h3><p>现在假设这样一种情况，TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。<br>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155147444.png" alt="image-20210407155147444"></p>
<p>在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。<br>这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。<br>但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p>
<h3 id="修正的-Karn-算法"><a href="#修正的-Karn-算法" class="headerlink" title="修正的 Karn 算法"></a>修正的 Karn 算法</h3><p>报文段每重传一次，就把 RTO 增大一些：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155238710.png" alt="image-20210407155238710"></p>
<p>系数 λ的典型值是 2 。<br>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。<br>实践证明，这种策略较为合理。 </p>
<h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>前面我们知道，当接收方收到没有正确按序的数据时，发送方会将包括这部分数据也一起发送来，这看起来是不是极其耗费性能，那么我们能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？</p>
<p>选择确认 SACK  (Selective ACK) 就是一种可行的处理方法</p>
<p>接收方可以将正确接收到的数据序号发送回发送方，使发送方不要再发送这些数据，这里要注意序号的问题。如图，你接受到了1—1000的数据那么确认号就要在右边界上再加1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155722884.png" alt="image-20210407155722884"></p>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</p>
<p>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</p>
<p>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
<p>最后，也是重要的一点</p>
<p><strong>因为SACK文档没有指明发送方应当怎样响应SACK，因此大多数的实现还是重传所有未被确认的数据块</strong></p>
<h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。<br>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。<br>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>
<p>用一个图来表示这个过程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407162855529.png" alt="image-20210407162855529"></p>
<p>这便是通过滑动窗口机制来来同台控制数据流量</p>
<p>但是，有这么一个情况，当B不允许A发送过后一段时间内，需要重新进行数据传输，但是巧了，这时候B的请求在路上丢失了，咋办，这个互不搭理（停止传输数据）的状态不就会这样一直保持下去吗</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407163156764.png" alt="image-20210407163156764"></p>
<p>这种互相等待的状态也成为<strong>死锁</strong>局面，如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>而为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。</p>
<p>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</p>
<p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<p>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</p>
<p>若窗口不是零，则死锁的僵局就可以打破了。 皆大欢喜</p>
<h2 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h2><p>前面有提到：当应用程序把数据传送到TCP的发送缓冲后，剩下的发送任务就由TCP控制了，可以用不同的机制来控制 TCP 报文段的发送时机</p>
<ol>
<li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li>
<li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。</li>
<li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ol>
<p>如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。</p>
<h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>在了解怎么合理控制发送时机前，我们首先来了解一个概念：糊涂窗口综合症</p>
<blockquote>
<p>糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164102037.png" alt="image-20210407164102037"></p>
<h3 id="发送方糊涂窗口综合症"><a href="#发送方糊涂窗口综合症" class="headerlink" title="发送方糊涂窗口综合症"></a>发送方糊涂窗口综合症</h3><p><strong>现象：</strong>发送方 TCP 每次接收到一字节的数据后就发送。<br>这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。</p>
<p><strong>解决方法：</strong>使用 Nagle 算法。</p>
<p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。<br>只有在收到对前一个报文段的确认后才继续发送下一个报文段。<br>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164246900.png" alt="image-20210407164246900"></p>
<h3 id="接收方糊涂窗口综合症"><a href="#接收方糊涂窗口综合症" class="headerlink" title="接收方糊涂窗口综合症"></a>接收方糊涂窗口综合症</h3><p>这个的现象主要如下</p>
<p>当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。<br>若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164353139.png" alt="image-20210407164353139"></p>
<p><strong>原因：</strong>接收方应用进程消耗数据太慢，例如：每次只读取一个字节。</p>
<p><strong>解决方法：</strong>让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p>
<h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h2><p>首先：看看拥塞的现象</p>
<p>在某段时间，若对网络中<strong>某资源的需求超过了该资源所能提供的可用部分</strong>(信道不够用)，网络的性能就要变坏。这种现象称为拥塞 (congestion)。<br>最坏结果：系统崩溃。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407165856238.png" alt="image-20210407165856238"></p>
<p>出现<strong>拥塞</strong>的原因，可能如下</p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<p>总的来说便是 </p>
<p><strong>∑ 对资源需求  &gt; 可用资源</strong></p>
<p>那么，通过增加资源能解决拥塞吗？</p>
<p>不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。</p>
<p>网络拥塞往往是由许多因素引起的。例如：<br>增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；<br>提高处理机处理的速率会会将瓶颈转移到其他地方；</p>
<p>这时候我们就要用到拥塞控制去降低网络拥塞带来的影响</p>
<h3 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h3><p>首先，我们来区别拥塞控制和流量控制</p>
<p>拥塞控制与流量控制的关系密切，它们之间也存在一些差别</p>
<blockquote>
<p>拥塞控制：</p>
<p>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载；</p>
<p>是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素。</p>
</blockquote>
<blockquote>
<p>流量控制：</p>
<p>抑制发送端发送数据的速率，以使接收端来得及接收；</p>
<p>是点对点通信量的控制，是端到端的问题；</p>
</blockquote>
<h3 id="拥塞控制的一般原理-1"><a href="#拥塞控制的一般原理-1" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>拥塞控制的前提：网络能够承受现有的网络负荷。<br>实践证明，拥塞控制是很难设计的，因为它是一个动态问题。<br>分组的丢失是网络发生拥塞的征兆而不是原因。<br>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407170728128.png" alt="image-20210407170728128"></p>
<h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>在面对设计网络时，我们通常采用开环控制方法和闭环控制方法，通俗来讲就是，前者就是尽量不让问题发生，后者是在问题发生时及时控制</p>
<blockquote>
<p><strong>开环控制</strong></p>
<p>在设计网络时，事先考虑周全，力求工作时不发生拥塞；</p>
<p><strong>思路：</strong>力争避免发生拥塞。</p>
</blockquote>
<blockquote>
<p><strong>闭环控制</strong></p>
<p>基于反馈环路的概念；</p>
<p>根据网络当前的运行状态采取相应控制措施；</p>
<p><strong>思路：</strong>在发生拥塞后，采取措施进行控制，消除拥塞。</p>
</blockquote>
<p>属于闭环控制的有以下几种措施：<br>(1) 监测网络系统，以便检测到拥塞在何时、何处发生。<br>(2) 将拥塞发生的信息传送到可采取行动的地方。<br>(3) 调整网络系统的运行以解决出现的问题。</p>
<p><strong>那么如何检测网络拥塞嘞</strong>，主要指标有：</p>
<ol>
<li>由于缺少缓存空间而被丢弃的分组的百分数；</li>
<li>平均队列长度；</li>
<li>超时重传的分组数；</li>
<li>平均分组时延；</li>
<li>分组时延的标准差，等等。</li>
</ol>
<p>上述这些指标的上升都标志着拥塞的增长。</p>
<p><strong>那么怎么去知道拥塞发生了呢</strong></p>
<ol>
<li>发送通知拥塞发生的分组；</li>
<li>在分组中保留表示拥塞状态的字段；</li>
<li>周期性地发出探测分组等。</li>
</ol>
<p><strong>那么这个时机该如何把握嘞</strong></p>
<p>过于频繁，会使系统产生不稳定的振荡；<br>过于迟缓地采取行动又不具有任何实用价值。</p>
<p><strong>解决拥塞的两条思路</strong></p>
<p>增加网络可用资源；<br>减少用户对资源的需求。</p>
<h2 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h2><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p>
<p>TCP发送方维持一个拥塞窗口 cwnd (Congestion Window)<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p>
<p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：</p>
<blockquote>
<p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</p>
<p>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p>
<h3 id="判断拥塞"><a href="#判断拥塞" class="headerlink" title="判断拥塞"></a>判断拥塞</h3><p>重传定时器超时：网络已经发生了拥塞。</p>
<p>收到三个重复的 ACK：预示网络可能会出现拥塞（实际可能还未发生拥塞）。</p>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><h4 id="慢开始-slow-start"><a href="#慢开始-slow-start" class="headerlink" title="慢开始 (slow-start)"></a>慢开始 (slow-start)</h4><p><strong>目的：</strong>用来确定网络的负载能力或拥塞程度。</p>
<p><strong>算法的思路：</strong>由小到大逐渐增大拥塞窗口数值。</p>
<p><strong>两个变量：</strong></p>
<blockquote>
<p>拥塞窗口：</p>
<p>初始拥塞窗口值：2 种设置方法。<br>    1 至 2 个最大报文段 （旧标准）<br>    2 至 4 个最大报文段 （RFC 5681）</p>
<p>窗口值逐渐增大。</p>
</blockquote>
<blockquote>
<p>慢开始门限：</p>
<p>防止拥塞窗口增长过大引起网络拥塞。</p>
</blockquote>
<p>拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。</p>
<blockquote>
<p>拥塞窗口 cwnd 每次的增加量 = min (N, SMSS)     </p>
</blockquote>
<p>其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。<br>不难看出，当 N &lt; SMSS 时，拥塞窗口每次的增加量要小于 SMSS。<br>用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172825021.png" alt="image-20210407172825021"></p>
<p>发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172914039.png" alt="image-20210407172914039"></p>
<p>每经过一个传输轮次，拥塞窗口就加倍。</p>
<p>使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。 </p>
<p>一个传输轮次所经历的时间其实就是往返时间 RTT。</p>
<p>“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 </p>
<p><strong>慢开始门限 ssthresh 的用法如下：</strong></p>
<p>当 cwnd &lt; ssthresh 时，使用慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</p>
<h4 id="拥塞避免-congestion-avoidance"><a href="#拥塞避免-congestion-avoidance" class="headerlink" title="拥塞避免 (congestion avoidance)"></a>拥塞避免 (congestion avoidance)</h4><p><strong>思路：</strong>让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。</p>
<p>每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。</p>
<p>使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172914039.png" alt="image-20210407172914039"></p>
<p>在超时之前，每经过一个传输轮次就使 cwnd 加 1。 </p>
<p><strong>当网络出现拥塞时</strong></p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：<br>ssthresh = max (cwnd/2，2)<br>cwnd = 1<br>执行慢开始算法<br>目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173243947.png" alt="image-20210407173243947"></p>
<p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。</p>
<p>慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p>
<p>慢开始和拥塞避免算法的实现GIF图举例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.gif" alt="拥塞控制"></p>
<p><strong>必须强调指出</strong></p>
<p>“拥塞避免”<strong>并非指完全能够避免了拥塞</strong>。利用以上的措施要完全避免网络拥塞还是不可能的。</p>
<p>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173752095.png" alt="image-20210407173752095"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173815321.png" alt="image-20210407173815321"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173824284.png" alt="image-20210407173824284"></p>
<h4 id="快重传-fast-retransmit"><a href="#快重传-fast-retransmit" class="headerlink" title="快重传 (fast retransmit)"></a>快重传 (fast retransmit)</h4><p>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p>
<p>使用快重传可以使整个网络的吞吐量提高约20%。 </p>
<blockquote>
<p>不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 </p>
</blockquote>
<p>采用快重传 FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<p>快重传 算法<strong>首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173936005.png" alt="image-20210407173936005"></p>
<h4 id="快恢复-fast-recovery"><a href="#快恢复-fast-recovery" class="headerlink" title="快恢复 (fast recovery)"></a>快恢复 (fast recovery)</h4><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：</p>
<ol>
<li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li>
<li>新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</li>
<li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 </li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174035629.png" alt="image-20210407174035629"></p>
<p>因此，在图的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh = cwnd / 2 = 8，同时设置拥塞窗口 cwnd = ssthresh = 8（见图中的点5），并开始执行拥塞避免算法。</p>
<h3 id="加法增大，乘法减小-AIMD"><a href="#加法增大，乘法减小-AIMD" class="headerlink" title="加法增大，乘法减小 (AIMD)"></a>加法增大，乘法减小 (AIMD)</h3><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI (Additive Increase)。</p>
<p>当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD (Multiplicative Decrease)。</p>
<p>二者合在一起就是所谓的 AIMD 算法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174136186.png" alt="image-20210407174136186"></p>
<p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p>
<blockquote>
<p>发送窗口的上限值 = Min [rwnd, cwnd]</p>
</blockquote>
<p>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。</p>
<p>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。 </p>
<p>也就是说，rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</p>
<h2 id="主动队列管理-AQM"><a href="#主动队列管理-AQM" class="headerlink" title="主动队列管理 AQM"></a>主动队列管理 AQM</h2><p>TCP 拥塞控制和网络层采取的策略有密切联系。</p>
<p>若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。</p>
<p>重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。</p>
<p>对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。</p>
<h3 id="“先进先出”FIFO-处理规则"><a href="#“先进先出”FIFO-处理规则" class="headerlink" title="“先进先出”FIFO 处理规则"></a>“先进先出”FIFO 处理规则</h3><p>路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。</p>
<p>当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。</p>
<p>路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/AQM%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA.gif" alt="AQM先进先出"></p>
<p>分组丢弃使发送方出现超时重传，使 TCP 连接进入拥塞控制的慢开始状态。如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174557236.png" alt="image-20210407174557236"></p>
<h3 id="全局同步"><a href="#全局同步" class="headerlink" title="全局同步"></a>全局同步</h3><p>更为严重的是，在网络中通常有很多的 TCP 连接，这些连接中的报文段通常是复用在网络层的 IP 数据报中传送的。</p>
<p>在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为全局同步 (global syncronization)。</p>
<p>全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/AQM%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E5%85%A8%E5%B1%80.gif" alt="AQM先进先出全局"></p>
<p>分组丢弃使发送方出现超时重传，使多个 TCP 连接同时进入拥塞控制的慢开始状态，发生全局同步。如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174833876.png" alt="image-20210407174833876"></p>
<h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>1998 年提出了主动队列管理 AQM (Active Queue Management)。</p>
<p>所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组，而是在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。</p>
<p>AQM 可以有不同实现方法，其中曾流行多年的就是随机早期检测 RED (Random Early Detection)。</p>
<p>使路由器的队列维持两个参数：队列长度最小门限 THmin 和最大门限 Thmax 。</p>
<p>RED 对每一个到达的分组都先计算平均队列长度 LAV 。</p>
<ol>
<li>若平均队列长度小于最小门限 THmin，则将新到达的分组放入队列进行排队。</li>
<li>若平均队列长度超过最大门限 Thmax ，则将新到达的分组丢弃。</li>
<li>若平均队列长度在最小门限 THmin 和最大门限 Thmax 之间，则按照某一概率 p 将新到达的分组丢弃。</li>
</ol>
<p>RED 将路由器的到达队列划分成为三个区域： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407175008385.png" alt="image-20210407175008385"></p>
<p>当 LAV  &gt;  Thmin 时，丢弃概率 p = 0。<br>当 LAV  &gt;  Thmax 时，丢弃概率 p = 1。<br>当 Thmin &lt; LAV &lt; Thmax时，  0 &lt; p  &lt; 1 。</p>
<p>在 RED 的操作中，最难处理的就是丢弃概率 p 的选择，因为 p 并不是个常数。例如，按线性规律变化，从 0 变到 pmax。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407175116102.png" alt="image-20210407175116102"></p>
<p>多年的实践证明，RED 的使用效果并不太理想。</p>
<p>2015 年公布的 RFC 7567 已经把 RFC 2309 列为“陈旧的”，并且不再推荐使用 RED。</p>
<p>对路由器进行主动队列管理 AQM 仍是必要的。</p>
<p>AQM 实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。</p>
<p>现在已经有几种不同的算法来代替旧的 RED，但都还在实验阶段。</p>
<h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><p>TCP 是面向连接的协议。<br>TCP 连接有三个阶段：</p>
<ol>
<li>连接建立</li>
<li>数据传送</li>
<li>连接释放</li>
</ol>
<p>TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行</p>
<p><strong>TCP 连接建立过程中要解决的三个问题</strong></p>
<ol>
<li><p>要使每一方能够确知对方的存在。</p>
</li>
<li><p>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</p>
</li>
<li><p>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</p>
</li>
</ol>
<p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户 (client)。被动等待连接建立的应用进程叫做服务器 (server)。</p>
<h2 id="TCP-的连接建立（三报文握手）"><a href="#TCP-的连接建立（三报文握手）" class="headerlink" title="TCP 的连接建立（三报文握手）"></a>TCP 的连接建立（三报文握手）</h2><p>TCP 建立连接的过程叫做握手。<br>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>通过连续的动画来理解这个过程</p>
<p>存在这样两台机子——客户A，服务器B，它们都处于关机状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073223940.png" alt="image-20210408073223940"></p>
<p>现在B的 TCP 服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073248750.png" alt="image-20210408073248750"></p>
<p>这时候A想要和B进行通信，它开机了，然后A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073345058.png" alt="image-20210408073345058"></p>
<p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。<br>B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073403752.png" alt="image-20210408073403752"></p>
<p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。<br>A 的 TCP 通知上层应用进程，连接已经建立。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073424503.png" alt="image-20210408073424503"></p>
<p>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。他们之间可以进行数据通信了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073447876.png" alt="image-20210408073447876"></p>
<p>完整的TCP三报文握手示意图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073500365.png" alt="image-20210408073500365"></p>
<h3 id="为什么要采取三报文握手"><a href="#为什么要采取三报文握手" class="headerlink" title="为什么要采取三报文握手"></a>为什么要采取三报文握手</h3><p>这里初学会有一个疑问，为什么要采取三报文握手呢，客户为什么还要再发一次确认收到呢，除了网上大家通俗的理解：为了让服务器知道我知道了外，主要还有以下原因——<strong>为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</strong></p>
<p>形象理解一下这句话，假设现在不需要第三个报文，然后发生这么一个故事</p>
<p>客户端在发送请求的过程中，第一个请求因为某些原因，在路上迷路了，客户端会再发送一次请求，以建立连接，等到连接释放，他想要的数据服务器已经给回它了的时候，巧了，迷路的请求来到服务器这边了，服务器就误以为客户端又要发起一次连接，于是响应过去，连接建立，但客户端此时不需要交互了啊，所以它也觉得莫名其妙，你服务器和我连接干啥，又没叫你，自作多情，然后客户端就没搭理服务器端，就这样，服务器端白白浪费了资源，一直处于连接过程</p>
<p>所以，为了解决客户端是真心想要和服务器建立连接的，它必须发送确认报文，用以确认连接正式建立</p>
<h3 id="TCO三次握手翻译得并不准确"><a href="#TCO三次握手翻译得并不准确" class="headerlink" title="TCO三次握手翻译得并不准确"></a>TCO三次握手翻译得并不准确</h3><p>还有一点需要注意：网上广而流传的TCP三次握手这个说法并不准确，书中提到，three way handshake，直译过来成三报文握手更合适，因为handshake是单数，而不是复数，这意味着，它们更像是通过握手上下摇晃三次，而不是握了三次手，RFC 793 文档中也有另外的表述，three way （three message）handshake，更加印证了这个译名。</p>
<h3 id="TCP四报文握手"><a href="#TCP四报文握手" class="headerlink" title="TCP四报文握手"></a>TCP四报文握手</h3><p>B发送给A的报文段可以分成两个，也就是先发送一个确认报文段（ACK = 1, ack = x + 1），然后再发送一个同步报文段（SYN = 1， seq = y），这样就变成了四报文握手，但效果一样</p>
<h2 id="TCP-的连接释放（四报文握手）"><a href="#TCP-的连接释放（四报文握手）" class="headerlink" title="TCP 的连接释放（四报文握手）"></a>TCP 的连接释放（四报文握手）</h2><p>TCP 连接释放过程比较复杂。</p>
<p>数据传输结束后，通信的双方都可释放连接。</p>
<p>TCP 连接释放过程是四报文握手。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>数据传输结束后，通信的双方都可释放连接。<br>现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。<br>A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080755867.png" alt="image-20210408080755867"></p>
<p>B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。<br>TCP 服务器进程通知高层应用进程。<br>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。<strong>B 若发送数据，A 仍要接收</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080834500.png" alt="image-20210408080834500"></p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080857738.png" alt="image-20210408080857738"></p>
<p> A 收到连接释放报文段后，必须发出确认。 </p>
<p> 在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080923219.png" alt="image-20210408080923219"></p>
<p>完整图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408081005627.png" alt="image-20210408081005627"></p>
<h3 id="A-必须等待-2MSL-的时间"><a href="#A-必须等待-2MSL-的时间" class="headerlink" title="A 必须等待 2MSL 的时间"></a>A 必须等待 2MSL 的时间</h3><p>在这个图中你会发现：A 必须等待 2MSL 的时间，为什么呢，原因有两个</p>
<ol>
<li><p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</p>
<p>假设A最后一个确认连接释放报文没有被B正常收到时，B会超时重传连接释放报文，而如果这时候A急着关闭，就不知道B发过来了，所以需要等一会时间保证自己的报文成功被B收到</p>
</li>
<li><p>防止 “已失效的连接请求报文段”出现在本连接中。</p>
<p>同前面讲的一样，在经过2MSL时间后，A会将本连接的所有产生的报文从网络上消失掉，不管你是否丢失，都把你逮住，然后让你消失，防止下一次新连接中会出现旧连接的请求报文</p>
</li>
</ol>
<h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p><strong>干啥的</strong>：用来防止在TCP连接出现长时期的空闲。</p>
<p><strong>工作方式</strong>是啥：保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 </p>
<h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>不行了不行了，整理不下去了，写不下去了，直接丢图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408082211484.png" alt="image-20210408082211484"></p>
<p>解释下图内标注含义⬇</p>
<p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头。</p>
<ol>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>细线箭头表示异常变迁。 </li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Dong-666.github.io">天际线上的猪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/">http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Dong-666.github.io" target="_blank">Dong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/img/code.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络-网络层"><img class="cover" src="/img/code.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络-网络层</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/" title="基于Vue的新拟态版ToDoList（待办事项）"><img class="cover" src="/img/Vue-ToDoList.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于Vue的新拟态版ToDoList（待办事项）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/28/http%E5%8D%8F%E8%AE%AE/" title="http协议"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-28</div><div class="title">http协议</div></div></a></div><div><a href="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络-应用层"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-18</div><div class="title">计算机网络-应用层</div></div></a></div><div><a href="/2021/03/05/%E7%89%A9%E7%90%86%E5%B1%82/" title="计算机网络-物理层"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="title">计算机网络-物理层</div></div></a></div><div><a href="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络-数据链路层"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-18</div><div class="title">计算机网络-数据链路层</div></div></a></div><div><a href="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" title="计算机网络概述"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-18</div><div class="title">计算机网络概述</div></div></a></div><div><a href="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络-网络层"><img class="cover" src="/img/code.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-18</div><div class="title">计算机网络-网络层</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">天际线上的猪</div><div class="author-info__description">记录生活，记录学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dong-666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://message/?uin=2834471179&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">小破站一个🍕🍔🍟！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.</span> <span class="toc-text">逻辑通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">屏蔽作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">复用与分用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%8EUDP"><span class="toc-number">1.4.</span> <span class="toc-text">TCP与UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">UDP特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">TCP特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.4.3.</span> <span class="toc-text">各自的应用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">IP数据报、TCP和UDP的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">为什么会有端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%AB%AF%E5%8F%A3%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.2.</span> <span class="toc-text">硬件端口和软件端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E4%BD%8D%E6%95%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">端口位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">常见端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP"><span class="toc-number">2.</span> <span class="toc-text">用户数据报协议UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">UDP的首部格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">传输控制协议TCP概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">TCP 最主要的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">TCP的连接（套接字）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">可靠传输的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">停止等待协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%88%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82-ARQ%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">超时重传（自动重传请求 ARQ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%8F%B7"><span class="toc-number">4.1.2.</span> <span class="toc-text">编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">确认丢失和确认迟到</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82-ARQ"><span class="toc-number">4.2.</span> <span class="toc-text">自动重传请求 ARQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">4.3.</span> <span class="toc-text">信道利用率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93"><span class="toc-number">4.3.1.</span> <span class="toc-text">流水线传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD-ARQ%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.2.</span> <span class="toc-text">连续 ARQ协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E7%A7%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">累积确认</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">TCP报文段的首部格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">TCP可靠传输的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">以字节为单位的滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">发送缓存与接收缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">6.2.</span> <span class="toc-text">超时重传时间的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4"><span class="toc-number">6.2.1.</span> <span class="toc-text">加权平均往返时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4-RTO"><span class="toc-number">6.2.2.</span> <span class="toc-text">超时重传时间 RTO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4-RTT-%E7%9A%84%E6%B5%8B%E9%87%8F%E7%9B%B8%E5%BD%93%E5%A4%8D%E6%9D%82"><span class="toc-number">6.2.3.</span> <span class="toc-text">往返时间 (RTT) 的测量相当复杂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E7%9A%84-Karn-%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.4.</span> <span class="toc-text">修正的 Karn 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4-SACK"><span class="toc-number">6.3.</span> <span class="toc-text">选择确认 SACK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">7.1.</span> <span class="toc-text">利用滑动窗口实现流量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="toc-number">7.2.</span> <span class="toc-text">TCP 的传输效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="toc-number">7.2.1.</span> <span class="toc-text">糊涂窗口综合症</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="toc-number">7.2.2.</span> <span class="toc-text">发送方糊涂窗口综合症</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="toc-number">7.2.3.</span> <span class="toc-text">接收方糊涂窗口综合症</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">拥塞控制的一般原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">8.1.1.</span> <span class="toc-text">拥塞控制和流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">8.1.2.</span> <span class="toc-text">拥塞控制的一般原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E5%92%8C%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">8.1.3.</span> <span class="toc-text">开环控制和闭环控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">TCP 的拥塞控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">8.2.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%8B%A5%E5%A1%9E"><span class="toc-number">8.2.2.</span> <span class="toc-text">判断拥塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">TCP拥塞控制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B-slow-start"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">慢开始 (slow-start)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-congestion-avoidance"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">拥塞避免 (congestion avoidance)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0-fast-retransmit"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">快重传 (fast retransmit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%81%A2%E5%A4%8D-fast-recovery"><span class="toc-number">8.2.3.4.</span> <span class="toc-text">快恢复 (fast recovery)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%A2%9E%E5%A4%A7%EF%BC%8C%E4%B9%98%E6%B3%95%E5%87%8F%E5%B0%8F-AIMD"><span class="toc-number">8.2.4.</span> <span class="toc-text">加法增大，乘法减小 (AIMD)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86-AQM"><span class="toc-number">8.3.</span> <span class="toc-text">主动队列管理 AQM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E2%80%9DFIFO-%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-number">8.3.1.</span> <span class="toc-text">“先进先出”FIFO 处理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%90%8C%E6%AD%A5"><span class="toc-number">8.3.2.</span> <span class="toc-text">全局同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM"><span class="toc-number">8.3.3.</span> <span class="toc-text">主动队列管理AQM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">TCP的运输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%88%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">TCP 的连接建立（三报文握手）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E5%8F%96%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B"><span class="toc-number">9.1.2.</span> <span class="toc-text">为什么要采取三报文握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCO%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%BF%BB%E8%AF%91%E5%BE%97%E5%B9%B6%E4%B8%8D%E5%87%86%E7%A1%AE"><span class="toc-number">9.1.3.</span> <span class="toc-text">TCO三次握手翻译得并不准确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B"><span class="toc-number">9.1.4.</span> <span class="toc-text">TCP四报文握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%EF%BC%88%E5%9B%9B%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">TCP 的连接释放（四报文握手）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2MSL-%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">9.2.2.</span> <span class="toc-text">A 必须等待 2MSL 的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">9.2.3.</span> <span class="toc-text">保活计时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">9.3.</span> <span class="toc-text">TCP 的有限状态机</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/Docker/" title="Docker入门笔记"><img src="/img/sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker入门笔记"/></a><div class="content"><a class="title" href="/2023/12/05/Docker/" title="Docker入门笔记">Docker入门笔记</a><time datetime="2023-12-04T16:00:00.000Z" title="发表于 2023-12-05 00:00:00">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/Linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" title="Linux入门"><img src="/img/sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux入门"/></a><div class="content"><a class="title" href="/2023/11/10/Linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" title="Linux入门">Linux入门</a><time datetime="2023-11-09T16:00:00.000Z" title="发表于 2023-11-10 00:00:00">2023-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/01/Nginx/" title="Nginx"><img src="/img/sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/2023/11/01/Nginx/" title="Nginx">Nginx</a><time datetime="2023-10-31T16:00:00.000Z" title="发表于 2023-11-01 00:00:00">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/Redis/" title="Redis入门笔记"><img src="/img/sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis入门笔记"/></a><div class="content"><a class="title" href="/2023/10/15/Redis/" title="Redis入门笔记">Redis入门笔记</a><time datetime="2023-10-14T16:00:00.000Z" title="发表于 2023-10-15 00:00:00">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/SpringCloud/" title="SpringCloud"><img src="/img/sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud"/></a><div class="content"><a class="title" href="/2022/10/26/SpringCloud/" title="SpringCloud">SpringCloud</a><time datetime="2022-10-25T16:00:00.000Z" title="发表于 2022-10-26 00:00:00">2022-10-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/code.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 天际线上的猪</div><div class="footer_custom_text">Hi, Welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'K4oel47dX9gLB9DECHDKW5HF-gzGzoHsz',
      appKey: 'FI26zV0So19K2wVMY6Ds4nAA',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>