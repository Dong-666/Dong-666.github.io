<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dong</title>
  
  <subtitle>y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dong-666.github.io/"/>
  <updated>2022-03-08T00:38:37.672Z</updated>
  <id>http://dong-666.github.io/</id>
  
  <author>
    <name>天际线上的猪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端知识小汇总</title>
    <link href="http://dong-666.github.io/2022/03/05/study/"/>
    <id>http://dong-666.github.io/2022/03/05/study/</id>
    <published>2022-03-05T09:58:15.000Z</published>
    <updated>2022-03-08T00:38:37.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><p>🔴重点🟠难点🟡性能🟢算法🔵JS高阶🟣框架</p><h2 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h2><ol><li><p>get、post（请求参数长度限制）——HTTP协议</p><ol><li><a href="https://juejin.cn/post/6844903433674178574" target="_blank" rel="noopener">两者区别</a></li><li><a href="https://juejin.cn/post/6992933721703710750" target="_blank" rel="noopener">GET 和 POST</a></li></ol></li><li><p>原型链</p><ol><li><p>gitee -&gt; 原型链代码</p></li><li><p>processOn <a href="https://mp.processon.com/view/link/604b5ac963768958e9989002#map" target="_blank" rel="noopener">思维导图</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211217103257781.png" alt="image-20211217103257781"></p></li></ol></li><li><p>mouseover、mouseenter</p><ol><li><p><a href="https://blog.csdn.net/LPLIFE/article/details/80436623" target="_blank" rel="noopener">文章</a></p></li><li><p>共同点：鼠标移入元素触发事件</p></li><li><p>不同点：</p><ul><li><p>mouseover：若存在子元素，则会冒泡触发多次mouseover事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseover.gif" alt="mouseover"></p></li><li><p>mouseenter：不存在子元素冒泡，也就是鼠标移入只会触发一次mouseenter事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseenter.gif" alt="mouseenter"></p></li></ul></li></ol></li><li><p><a href="https://juejin.cn/post/6844904126199889927" target="_blank" rel="noopener">可视区域高度</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/js%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.png" alt></p><p>可视区域就是不包括上下左右的工具栏、状态栏（滚动条特殊）。代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可视区域宽度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="comment">//可视区域高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"><span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><p>document.documentElement也可以为document.body</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平滚动条的位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft</span><br><span class="line"><span class="comment">//垂直滚动条位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollRight</span><br></pre></td></tr></table></figure></li><li><p>defer（异步加载js)</p><ol><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ol></li><li><p>防抖节流</p><ol><li><p>防抖（高阶）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, context, param</span>) </span>&#123;</span><br><span class="line">        clearTimeout(method.tId);</span><br><span class="line">        method.tId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          method.apply(context, param);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>防抖（闭包型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> out = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">          clearTimeout(out);</span><br><span class="line">          out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            method.call(that, args);</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>节流（自定义）</p><p><a href="https://juejin.cn/post/6844903669389885453" target="_blank" rel="noopener">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throlle</span>(<span class="params">method, timeout = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out;</span><br><span class="line">  <span class="keyword">let</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; timeout) &#123;</span><br><span class="line">      clearTimeout(out);</span><br><span class="line">      out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        method(...args);</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      method(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>事件流</p><ol><li><p><a href="https://juejin.cn/post/6844903741783556109" target="_blank" rel="noopener">JS事件流和事件委托</a></p></li><li><p><a href="https://juejin.cn/post/6844903834075021326" target="_blank" rel="noopener">你真的理解 事件冒泡 和 事件捕获</a>吗</p></li><li><p>阻止冒泡,阻止默认事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c 冒泡'</span>);</span><br><span class="line">    e.stopPropagation();<span class="comment">//阻止冒泡</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span><span class="comment">//阻止默认事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身</p></blockquote></li><li><p><a href="https://juejin.cn/post/6844903450493321223" target="_blank" rel="noopener">javascript 事件流</a></p></li></ol></li><li><p>JS拖拽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖动开始--&gt;拖动过程中--&gt;拖动结束</span></span><br><span class="line"><span class="comment">// 监听目标DOM的onmousedown事件→document的onmousemove→document的onmouseup</span></span><br><span class="line"><span class="comment">//记录旧坐标鼠标移动后记录下新坐标,通过新坐标减去旧坐标得出变化的坐标,然后改变其位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldX, oldY, newX, newY; <span class="comment">//存储新旧鼠标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素点击事件</span></span><br><span class="line">  ele.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    oldX = e.clientX; <span class="comment">//存储鼠标当前位置(初始化位置)</span></span><br><span class="line">    oldY = e.clientY;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.style.left &amp;&amp; !<span class="keyword">this</span>.style.top) &#123;</span><br><span class="line">      <span class="comment">//如果元素无初始值,则需要赋值</span></span><br><span class="line">      <span class="keyword">this</span>.style.left = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.style.top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      newX = e.clientX; <span class="comment">//存储移动后的鼠标位置</span></span><br><span class="line">      newY = e.clientY;</span><br><span class="line">      <span class="comment">// 移动后的位置 = 当前位置 - (移动后的鼠标位置-移动前的鼠标位置)</span></span><br><span class="line">      ele.style.top = <span class="built_in">parseFloat</span>(ele.style.top) + (newY - oldY) + <span class="string">'px'</span>;</span><br><span class="line">      ele.style.left = <span class="built_in">parseFloat</span>(ele.style.left) + (newX - oldX) + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">      oldX = newX; <span class="comment">//移动完后旧鼠标位置为新鼠标位置</span></span><br><span class="line">      oldY = newY;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标松开事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 解绑事件</span></span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js drag api</p><p><a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="noopener">HTML5 拖放（Drag 和 Drop）详解与实例 - 风雨后见彩虹 - 博客园 (cnblogs.com)</a></p><p>在被拖动的元素上需定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./PoinkoParrot2.jpeg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"draggable"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在拖放的过程中会触发以下事件：</p><ul><li><p>在拖动目标上触发事件(源元素):</p><ul><li>ondragstart - 用户开始拖动元素时触发</li><li>ondrag - 元素正在拖动时触发</li><li>ondragend - 用户完成元素拖动后触发</li></ul></li><li><p>释放目标时触发的事件:</p><ul><li>ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件</li><li>ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件</li><li>ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件</li><li>ondrop - 在一个拖动过程中，释放鼠标键时触发此事件</li></ul></li></ul></li><li><p>eval</p><ul><li><a href="https://juejin.cn/post/6938775708739207182" target="_blank" rel="noopener">Eval</a></li><li><a href="https://juejin.cn/post/6844903713140637709" target="_blank" rel="noopener">你不知道的 eval</a></li><li><a href="https://juejin.cn/post/6954380745871720462" target="_blank" rel="noopener">欺骗词法 eval 和 with</a></li></ul></li><li><p>AMD、CMD、CommonJs</p><ul><li><a href="https://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现 - ECMAScript 6入门</a></li><li><a href="https://juejin.cn/post/6844903576309858318" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul></li><li><p>🟠js监听对象属性改变（vue属性监听）</p><ul><li><a href="https://juejin.cn/post/6844903842828533767" target="_blank" rel="noopener">论如何监听一个对象某个属性的变化</a></li></ul></li><li><p>JS实现跨域</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li></ul></li><li><p>JS深度拷贝（浅拷贝、深拷贝…）</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211222145748666.png" alt="image-20211222145748666"></p></li><li><p>重排重绘</p><ul><li><a href="https://juejin.cn/post/6844903745914929165" target="_blank" rel="noopener">浏览器重绘(repaint)重排(reflow)与优化</a></li></ul></li><li><p>🟠JS全排列</p><ul><li><p><a href="https://juejin.cn/post/6844904191379374087" target="_blank" rel="noopener">前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">...chunks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span> (<span class="params">chunkIndex, prev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = chunks[chunkIndex];</span><br><span class="line">    <span class="keyword">let</span> isLast = chunkIndex === chunks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> chunk) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = prev.concat(val);</span><br><span class="line">      <span class="keyword">if</span> (isLast) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span></span><br><span class="line">        res.push(cur); <span class="comment">//将最后一个数组的所有选项分别压入</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        helper(chunkIndex + <span class="number">1</span>, cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 从属性数组下标为 0 开始处理</span></span><br><span class="line">  <span class="comment">// 并且此时的 prev 是个空数组</span></span><br><span class="line">  helper(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'iPhone X'</span>, <span class="string">'iPhone XS'</span>];</span><br><span class="line">  <span class="keyword">let</span> colors = [<span class="string">'黑色'</span>, <span class="string">'白色'</span>];</span><br><span class="line">  <span class="keyword">let</span> storages = [<span class="string">'64g'</span>, <span class="string">'256g'</span>];</span><br><span class="line">  <span class="keyword">let</span> res = combine(names, colors, storages);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="comment">/* result</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '256g' ]</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>  <img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211224151929493.png" alt="image-20211224151929493"></p></li></ul></li><li><p>this指向、隐式丢失、显式绑定</p><ul><li><a href="https://juejin.cn/post/6844904113352736776" target="_blank" rel="noopener">this绑定的四种方式：new，显式，隐式，默认</a></li></ul></li><li><p>🟠virtual dom</p><ul><li><a href="https://juejin.cn/post/6844903609667321863" target="_blank" rel="noopener">探索Virtual DOM的前世今生</a></li><li><a href="https://juejin.cn/post/6844903615652610055" target="_blank" rel="noopener">深入框架本源系列 —— Virtual Dom</a></li><li><a href="https://juejin.cn/post/6844903921442422791" target="_blank" rel="noopener">面试官问: 如何理解Virtual DOM？</a></li></ul></li><li><p>vue生命周期</p></li><li><p>🔴🟠Promise底层实现</p></li><li><p>事件监听</p><ul><li><a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">HTML DOM 事件对象</a></li><li><a href="https://juejin.cn/post/6844903886960984072" target="_blank" rel="noopener">一篇文章能否解决你事件监听的许多疑问</a></li><li>🔴🔵<a href="https://juejin.cn/post/6844903647197790221" target="_blank" rel="noopener">撸一个JS的事件管理</a></li><li>🔵<a href="https://juejin.cn/post/6844904069820055560" target="_blank" rel="noopener">🔥JavaScript 自定义事件如此简单！</a></li></ul></li><li><p>Generator</p><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112" target="_blank" rel="noopener">generator</a></p></li><li><p>基本使用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>生成自增id函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">next_id</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// !不是阻塞执行，是yield时跳出函数并储存当时的状态。</span></span><br><span class="line">    <span class="comment">// !执行next()时还原当时的状态，从上次yield的位置向下执行</span></span><br><span class="line">    <span class="keyword">yield</span> ++id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = next_id();</span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li></ul><ol start="22"><li><p>arguments（箭头函数）</p><ul><li><a href="https://juejin.cn/post/6844903616231260174" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li><li><a href="https://juejin.cn/post/6844903801799835655" target="_blank" rel="noopener">详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景</a></li><li><a href="https://juejin.cn/post/6844904152640782343" target="_blank" rel="noopener">曾经我以为我很懂箭头函数</a></li><li><a href="https://juejin.cn/post/6844904133409914894" target="_blank" rel="noopener">对阮一峰《ES6 入门》中箭头函数 this 描述的探究</a></li></ul></li><li><p>🔴🟠🔵继承</p><ul><li><a href="https://juejin.cn/post/6844903696111763470" target="_blank" rel="noopener">JavaScript常用八种继承方案</a></li><li><a href="https://juejin.cn/post/6844904094948130824" target="_blank" rel="noopener">🔥比继承家业还要简单的JS继承题-封装篇(牛刀小试)</a></li><li><a href="https://juejin.cn/post/6844903475021627400" target="_blank" rel="noopener">JS原型链与继承</a></li></ul></li><li><p>🔴script——async属性</p><ul><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ul></li><li><p>🔴jsonp——跨域的解决</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li><li><a href="https://juejin.cn/post/6844903462551945230" target="_blank" rel="noopener">原生 JavaScript 实现 AJAX、JSONP</a></li><li><a href="https://juejin.cn/post/6844903976505344013" target="_blank" rel="noopener">一分钟说完JSONP请求</a></li></ul></li><li><p>🔴ajax的返回状态——Fetch</p><ul><li><a href="https://juejin.cn/post/6844903618764603399" target="_blank" rel="noopener">Ajax原理一篇就够了</a></li><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/" target="_blank" rel="noopener">AJAX笔记 | Dong</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html" target="_blank" rel="noopener">Fetch API 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul></li><li><p>dns预加载（缓存）dns-preFetch</p><ul><li><a href="https://juejin.cn/post/6844903492490887182" target="_blank" rel="noopener">DNS Prefetching 的正确使用姿势</a></li><li><a href="https://juejin.cn/post/6915204591730556935" target="_blank" rel="noopener">preload、prefetch、preconnect 和 dns-prefetch 知多少</a></li></ul></li><li><p>🔵函数柯里化（currying）</p><ul><li><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">详解JS函数柯里化</a></li></ul></li><li><p>骨架屏</p><p><a href="https://www.jianshu.com/p/a72263d2d105" target="_blank" rel="noopener">什么是骨架屏 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/96455668" target="_blank" rel="noopener">如何实现优美的骨架屏 - 知乎 (zhihu.com)</a></p></li><li><p>🔴启动性能（异步）（前端性能优化）</p><ul><li><a href="https://juejin.cn/post/6892994632968306702" target="_blank" rel="noopener">前端性能优化 24 条建议（2020） - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6904517485349830670" target="_blank" rel="noopener">工作中如何进行前端性能优化(21种优化+7种定位方式) - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7020212914020302856" target="_blank" rel="noopener">写在 2021 的前端性能优化指南 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6844904195707895816" target="_blank" rel="noopener">前端性能优化总结 - 掘金 (juejin.cn)</a></li></ul></li><li><p>HTTP缓存机制</p><p><a href="https://juejin.cn/post/6844904100035821575#heading-59" target="_blank" rel="noopener">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903634002509832" target="_blank" rel="noopener">面试精选之http缓存 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903517702848526" target="_blank" rel="noopener">HTTP—-HTTP缓存机制 - 掘金 (juejin.cn)</a></p></li><li><p>websocket、AJAX</p><p><a href="https://juejin.cn/post/6844903544978407431" target="_blank" rel="noopener">WebSocket：5分钟从入门到精通 - 掘金 (juejin.cn)</a></p></li><li><p>TCP/IP模型（计算机网络）</p><p><a href="https://ypigy.gitee.io/2021/04/18/运输层/#传输控制协议TCP概述" target="_blank" rel="noopener">计算机网络-运输层 | Dong (gitee.io)</a></p><p>[计算机网络-网络层 | Dong (gitee.io)](<a href="https://ypigy.gitee.io/2021/04/18/网络层/#网际协议" target="_blank" rel="noopener">https://ypigy.gitee.io/2021/04/18/网络层/#网际协议</a> IP)</p></li><li><p>🟠gulp、webpack（打包原理）</p><p><a href="https://juejin.cn/post/6844903802382860296#heading-6" target="_blank" rel="noopener">Webpack 模块打包原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6917069979913289736#heading-15" target="_blank" rel="noopener">对比webpack，你更应该先掌握gulp【10分钟教你彻底掌握gulp】 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904038543130637#heading-22" target="_blank" rel="noopener">webpack打包原理 ? 看完这篇你就懂了 ! - 掘金 (juejin.cn)</a></p></li><li><p>PWA</p><p><a href="https://juejin.cn/post/6844904052166230030" target="_blank" rel="noopener">面试官：请你实现一个PWA 我：😭 - 掘金 (juejin.cn)</a></p></li><li><p>🔴单元测试</p><p><a href="https://juejin.cn/post/7039108357554176037" target="_blank" rel="noopener">如何做前端单元测试 - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/7049293284883038238" target="_blank" rel="noopener">前端单元测试入门与最佳实践 - 掘金 (juejin.cn)</a></p></li><li><p>🔴seo优化</p><p><a href="https://segmentfault.com/a/1190000019623624_vueseo" target="_blank" rel="noopener">基于Vue SEO的四种方案 - SegmentFault 思否</a></p><p><a href="https://juejin.cn/post/6980167371864424456" target="_blank" rel="noopener">前端搜索引擎优化（SEO）的技巧 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903824428105735#heading-4" target="_blank" rel="noopener">前端SEO优化 - 掘金 (juejin.cn)</a></p></li><li><p>grid栅格布局</p><p><a href="https://juejin.cn/post/6854573220306255880" target="_blank" rel="noopener">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p></li><li><p>bigint</p><p><a href="https://juejin.cn/post/6844903902295359502" target="_blank" rel="noopener">JS最新基本数据类型：BigInt - 掘金 (juejin.cn)</a></p></li><li><p>🔴🟠0.1+0.2 ？（是0.3吗）</p><p><a href="https://juejin.cn/post/7056934829920616461" target="_blank" rel="noopener">用了一天时间，我终于彻底搞懂了 0.1+0.2 是否等于 0.3！ - 掘金 (juejin.cn)</a></p></li><li><p>osi七层模型（计算机网路）</p><p><a href="https://ypigy.gitee.io/categories/计算机网络/" target="_blank" rel="noopener">分类: 计算机网络 | Dong (gitee.io)</a></p></li><li><p>🔴head、状态码</p><p><a href="https://ypigy.gitee.io/2020/07/28/http协议/" target="_blank" rel="noopener">http协议 | Dong (gitee.io)</a></p><p><a href="https://blog.csdn.net/wzx19840423/article/details/79073087" target="_blank" rel="noopener">http状态码总结_wzx19840423的专栏-CSDN博客_http状态码</a></p><p><a href="https://blog.csdn.net/u014346301/article/details/53995333" target="_blank" rel="noopener">HTTP状态码（HTTP Status Code）_Sweet oDream-CSDN博客</a></p></li><li><p>声明式绑定（REACT Query/ Apollo GtaphQL Client）<br>等有学react再来吧</p></li><li><p>假数据生产（Yapi、RAP2、Apifox）</p><ol><li><a href="https://hellosean1025.github.io/yapi/index.html" target="_blank" rel="noopener">YApi 接口管理平台 (hellosean1025.github.io)</a></li><li><a href="http://rap2.taobao.org/account/login" target="_blank" rel="noopener">RAP接口管理平台 (taobao.org)</a></li><li><a href="https://github.com/thx/rap2-delos" target="_blank" rel="noopener">阿里妈妈前端团队出品的开源接口管理工具RAP第二代</a></li><li><a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a></li></ol></li><li><p>BFF架构</p><p><a href="https://juejin.cn/post/6950530370810937352" target="_blank" rel="noopener">第 016 期 前后端经常争吵？ - BFF 了解一下 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7008840813069205512" target="_blank" rel="noopener">微服务/API时代的前端开发] BFF入门–5个实用的BFF使用案例 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903959333699598" target="_blank" rel="noopener">初识BFF架构设计 - 掘金 (juejin.cn)</a></p></li><li><p>🔴文档碎片</p><p><a href="https://juejin.cn/post/7012073594918273032" target="_blank" rel="noopener">前端性能优化：创建文档碎片 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/408738417" target="_blank" rel="noopener">性能优化之文档碎片 - 知乎 (zhihu.com)</a></p></li><li><p>🔴宏任务、微任务（同步异步）</p><p>直接看js代码and思维导图（可以的话整个笔记）</p></li><li><p>compose函数</p><p><a href="https://juejin.cn/post/6844904061821517832" target="_blank" rel="noopener">JavaScript中的compose函数和pipe函数 - 掘金 (juejin.cn)</a></p></li><li><p>forEach跳出循环（终止并返回值）</p><p><a href="https://juejin.cn/post/6971972782292729886" target="_blank" rel="noopener">面试官问我JS中forEach能不能跳出循环 - 掘金 (juejin.cn)</a>看完看看评论，挺有意思的</p></li><li><p>shell命令</p><p><a href="https://juejin.cn/post/6844903489911406599" target="_blank" rel="noopener">Shell常见命令实践 - 掘金 (juejin.cn)</a></p></li><li><p>git命令</p><ol><li>合并代码冲突（merge&amp;rebase）</li><li>代码回滚（reset&amp;checkout）</li><li>代码暂存（stash）</li></ol></li><li><p>linux命令</p></li><li><p>Element.</p><ol><li>getBounding</li><li>IntersectionOberver</li><li>createNodeIterator</li><li>getComputedStyle</li><li>getPropertyValue</li><li>MutationObserver</li></ol></li><li><p>ES6常用方法</p><ul><li><a href="https://juejin.cn/post/6906398702269628424" target="_blank" rel="noopener">混子前端24个解决工作问题的ES6代码片段 - 掘金 (juejin.cn)</a></li></ul></li></ol><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol><li><a href="https://chinese.freecodecamp.org/learn" target="_blank" rel="noopener">编程学习</a></li><li>面试题：<ul><li><a href="https://juejin.cn/post/6989422484722286600" target="_blank" rel="noopener">2021年我的前端面试准备 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7035259189966405668" target="_blank" rel="noopener">面试的时候面试官是这样问我Js基础的，角度真刁钻 - 掘金 (juejin.cn)</a></li></ul></li><li><a href="https://juejin.cn/post/7013247812628381704" target="_blank" rel="noopener">组件库</a></li><li><a href="https://juejin.cn/post/7026339412799651876" target="_blank" rel="noopener">Vue源码(一些数据结构)</a></li><li><a href="https://juejin.cn/post/7025868886914400293" target="_blank" rel="noopener">现代web开发困局</a></li><li><a href="https://www.zhihu.com/question/458213150" target="_blank" rel="noopener">为什么 WeakSet 和 WeakMap 无法获取到元素的数量，也无法迭代其中的元素</a></li><li><a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">JS垃圾回收机制</a></li><li><a href="https://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="noopener">前端性能优化</a></li><li><a href="https://segmentfault.com/a/1190000012571492" target="_blank" rel="noopener">gzip</a></li><li><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener">PWA</a></li><li><a href="https://juejin.cn/post/7007206194276204575#heading-26" target="_blank" rel="noopener">前端学习路线以及知识体系：</a></li><li><a href="https://juejin.cn/post/7038297948630827039" target="_blank" rel="noopener">11个非常有用的HTML单行代码🎃 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7048916480032768013" target="_blank" rel="noopener">「前端该如何优雅地Mock数据🏃」每个前端都应该学会的技巧 - 掘金 (juejin.cn)</a></li></ol>]]></content>
    
    <summary type="html">
    
      记录一下看过的前端知识点，进行汇总并整理
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
      <category term="前端" scheme="http://Dong-666.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>K最近邻算法KNN</title>
    <link href="http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-20T10:00:00.000Z</published>
    <updated>2022-03-02T08:00:45.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>KNN（K- Nearest Neighbor）法即K最邻近法，最初由 Cover和Hart于1968年提出，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路非常简单直观：如果一个样本在特征空间中的K个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别 </p><p>该方法的不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最邻近点。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。另外还有一种 Reverse KNN法，它能降低KNN算法的计算复杂度，提高分类的效率 </p><p>KNN算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分</p></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>准备数据，对数据进行预处理 。</li><li>计算测试样本点（也就是待分类点）到其他每个样本点的距离</li><li>对每个距离进行排序，然后选择出距离最小的K个点</li><li>对K个点所属的类别进行比较，根据少数服从多数的原则，将测试样本点归入在K个点中占比最高的那一类</li></ol><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221648768.png" alt="image-20220221221648768"></p><p>使用毕达哥拉斯公式计算A和B的相似性（距离），值越小，相似性越大</p><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221215435440.png" alt="image-20220221215435440"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221838593.png" alt="image-20220221221838593"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>原理上挺简单的，所以没解释，直接上代码，包含两个函数，一个毕达哥拉斯公式，一个KNN算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毕达哥拉斯  Math.sqrt((x1-x2)² + (y1 - y2)²)</span></span><br><span class="line"><span class="comment">// 传参：目标对象1，目标对象2，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pythagoras</span>(<span class="params">obj1, obj2, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> common = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj2[key]) &#123;</span><br><span class="line">      res.push(<span class="built_in">Math</span>.pow(<span class="built_in">parseFloat</span>(obj1[key]) - <span class="built_in">parseFloat</span>(obj2[key]), <span class="number">2</span>)); <span class="comment">//差值取平方</span></span><br><span class="line">      common.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">Math</span>.sqrt(res.reduce(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> (cur += next), <span class="number">0</span>)).toFixed(<span class="number">2</span>); <span class="comment">//累加取平方根且保留两位小数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; res, common &#125;;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法-KNN-毕达哥拉斯比较距离</span></span><br><span class="line"><span class="comment">// 传参：对象集合，当前对象，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kNN</span>(<span class="params">objs, newObj, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allDistance = []; <span class="comment">//存储所有距离</span></span><br><span class="line">  <span class="keyword">let</span> minDistance = <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//存储最小距离,默认js能读的最大数值</span></span><br><span class="line">  <span class="keyword">let</span> minObjName; <span class="comment">//存储最小对象名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> objs) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = pythagoras(objs[key], newObj); <span class="comment">//对每个对象执行毕达哥拉斯公式</span></span><br><span class="line">    allDistance.push(&#123; <span class="attr">distance</span>: res, <span class="attr">targetName</span>: key &#125;); <span class="comment">//将所有结果压入</span></span><br><span class="line">    <span class="comment">// res &lt; minDistance &amp;&amp; ((minDistance = res), (minObjName = key));</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历查找最小距离对象</span></span><br><span class="line">  <span class="keyword">let</span> resultObj = allDistance.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.distance - b.distance)[<span class="number">0</span>];</span><br><span class="line">  minObjName = resultObj[<span class="string">'targetName'</span>];</span><br><span class="line">  minDistance = resultObj[<span class="string">'distance'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; allDistance, minDistance, minObjName &#125;;</span><br><span class="line">  <span class="keyword">return</span> minObjName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟数据以及测试"><a href="#模拟数据以及测试" class="headerlink" title="模拟数据以及测试"></a>模拟数据以及测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">//数据库已有用户及其喜欢的电影类型的打分</span></span><br><span class="line"><span class="keyword">let</span> favoriteType = &#123;</span><br><span class="line">  xiaoming: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">3</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaohong: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">4</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaolv: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">1</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaozi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoqi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">2</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">3</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoquan: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = kNN(favoriteType, &#123; <span class="attr">terror</span>: <span class="number">1</span>, <span class="attr">comedy</span>: <span class="number">4</span>, <span class="attr">love</span>: <span class="number">2</span>, <span class="attr">action</span>: <span class="number">5</span>, <span class="attr">scienceFiction</span>: <span class="number">5</span> &#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allDistance: [</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.12'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoqi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.36'</span>, <span class="attr">targetName</span>: <span class="string">'xiaozi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.00'</span>, <span class="attr">targetName</span>: <span class="string">'xiaohong'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.10'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoquan'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.20'</span>, <span class="attr">targetName</span>: <span class="string">'xiaolv'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'6.78'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoming'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  minDistance: <span class="string">'4.12'</span>,</span><br><span class="line">  minObjName: <span class="string">'xiaoqi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221222005339.png" alt="image-20220221222005339"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。 </li><li>回归就是预测结果（如数字）。 </li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 </li><li>能否挑选合适的特征事关KNN算法的成败</li></ol>]]></content>
    
    <summary type="html">
    
      KNN（K- Nearest Neighbor）法即K最邻近法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-02-13T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:49.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式</p></blockquote><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221172703812.png" alt="image-20220221172703812"></p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180313039.png" alt="image-20220221180313039"></p><p>解决方式就是采用动态规划</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180638182.png" alt="image-20220221180638182"></p><p>背包分割的最小重量取决于能拿的最小物品重量，如果此时最小物品为0.5，那么背包就要被划分成4/0.5 = 8，8列</p><p>在每一行， <strong>可偷的商品都为当前行的商品以及之前各行的商品</strong>，逐行进行计算，比如第一行，可拿的物品只有吉他，那么接下来四格，就都只能考虑吉他，所以全都填充为单个吉他的价值，等到第二行时，可选的选项就有音响和前一行的吉他了，这时候每个单元格再根据物品价值和质量综合判断来进行数据填充，音响重量有4，所以前面依旧沿用吉他的价值，直接到音响的重量所处格子，这时候我们发现音响价值在4的时候大于1500，也就是音响本身价值大于吉他，所以进行替换，接下来亦是如此，到第三行第四个格子我们发现笔记本电脑的价格加上<strong>上一行</strong>4-笔记本重量所处单元格的价值大于上一行4所处价值，所以得出最终的结果</p><p>计算结果如下</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180723661.png" alt="image-20220221180723661"></p><p>计算每个单元格的价值时，使用的公式如下</p><p>在1和2之间进行比较，选择大的那方</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221182208929.png" alt="image-20220221182208929"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p><strong>各行的排列顺序无关紧要</strong></p><p>也就是说哪个物品先判断都行，你想把音响放在最开始进行分析都可以，不影响结果（但在后面的代码中为了方便我还是会为数据进行排序，从最轻的拿起，可以思考下我为什么那样做，当然也有可能会是我想不到（不足）的地方（怕打脸哈哈哈））</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183039104.png" alt="image-20220221183039104"></p></li><li><p><strong>使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分（你只能把它当作一个最小的整体，不能继续分割的整体）</strong></p><p>如果想处理像偷大米、黄豆之类可以拆出来倒到背包的问题时，则可以使用贪婪算法</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183404146.png" alt="image-20220221183404146"></p></li><li><p>相互依赖的情况</p><p>没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是<strong>离散</strong>的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了子问题会相互产生影响的问题</p></li><li><p>为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包</p><p>形象来说就是一分为二，再在每个子背包中一分为二（有点类似二叉树）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183745856.png" alt="image-20220221183745856"></p></li><li><p>最优解可能会导致背包没装满</p><p>假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路如下</p><ol><li>因为从上面的算法得出：每次计算当前行都只会用到上一行的数据，所以我并没有像书里一样使用表格去记录这个过程，我使用了两个二维数组prices、goods分别用来存储每格的价值和所含物品，每次每行计算后的最新结果goods[1]会重新赋值给goods[0]，计算前又将goods[0]默认赋值给goods[1]，这样就可以只在价格有改变时改变单元格即可， prices同理</li><li>然后对初始数据initData进行排序，这样可以保证最开始那一行是有数据的，如果是别的比较重的物品，则最开始那几个空格就会为空，就又要去做一些多余的判断或者赋默认值，挺麻烦的，怕代码冗余和出现一些问题</li><li>内层（列）遍历，每次都只用从当前物品重量对应单元格开始算，毕竟前几格你也放不下嘛，默认当前格的上一行值即可，减少代码判断</li><li>核心判断语句不变，跟上面一致</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDeep</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetGoods</span>(<span class="params">data, bagWeight</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initData = <span class="built_in">Array</span>.from(data); <span class="comment">//数据初始化，防止修改到原数据</span></span><br><span class="line">  <span class="keyword">let</span> prices = [[], []]; <span class="comment">//存放价值的数组</span></span><br><span class="line">  <span class="keyword">let</span> goods = [[], []]; <span class="comment">//存放每个最大价值所含物品</span></span><br><span class="line">  initData.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.weight - b.weight); <span class="comment">//数据初始化排序，从小到大</span></span><br><span class="line">  <span class="keyword">let</span> baseWeight = initData[<span class="number">0</span>][<span class="string">'weight'</span>]; <span class="comment">//获得基础容量</span></span><br><span class="line">  <span class="keyword">let</span> pricesLength = <span class="built_in">Math</span>.floor(bagWeight / baseWeight); <span class="comment">//获得背包应分割的数量,向下取整，排除书包额外容量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据,相当于遍历第一件商品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pricesLength; i++) &#123;</span><br><span class="line">    prices[<span class="number">0</span>].push(initData[<span class="number">0</span>][<span class="string">'price'</span>]);</span><br><span class="line">    goods[<span class="number">0</span>].push([initData[<span class="number">0</span>][<span class="string">'name'</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除当前商品，避免参与下面的算法执行</span></span><br><span class="line">  <span class="keyword">delete</span> initData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心，从第二件商品开始遍历，对每一件商品进行数据填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initData) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = initData[key];</span><br><span class="line">    <span class="keyword">let</span> elementWeightIndex = element[<span class="string">'weight'</span>] / baseWeight - <span class="number">1</span>; <span class="comment">//物品重量对应索引</span></span><br><span class="line"></span><br><span class="line">    prices[<span class="number">1</span>] = copyDeep(prices[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line">    goods[<span class="number">1</span>] = copyDeep(goods[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = elementWeightIndex; i &lt; pricesLength; i++) &#123;</span><br><span class="line">      <span class="comment">//第一种情况：当前物品重量同当前背包小格重量相等</span></span><br><span class="line">      <span class="keyword">if</span> (i == elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品及价格</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>]];</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况，当前物品重量大于当前背包小格重量</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格加上（当前背包质量-当前物品质量）的价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品和（当前背包质量-当前物品质量）的物品总和及价格总和</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>], ...goods[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prices[<span class="number">0</span>] = copyDeep(prices[<span class="number">1</span>]);</span><br><span class="line">    goods[<span class="number">0</span>] = copyDeep(goods[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    goods: goods[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">    price: prices[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下"><a href="#运行下" class="headerlink" title="运行下"></a>运行下</h4><p>模拟数据有点多，不要介意，确保可靠嘛</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'吉他'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'音响'</span>, <span class="attr">price</span>: <span class="number">3000</span>, <span class="attr">weight</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'笔记本电脑'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'iphone'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ipad'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'自行车'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'钻石'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'花'</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'巧克力'</span>, <span class="attr">price</span>: <span class="number">500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'耳机'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = dynamicToGetGoods(data, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; goods: [ '音响', '钻石', 'iphone', '吉他', '耳机', '巧克力' ], price: 58500 &#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 </li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴</li></ol><p>每次用的时候问问自己</p><blockquote><ol><li>单元格中的值是什么？</li><li>如何将这个问题划分为子问题？ </li><li>网格的坐标轴是什么？</li></ol></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>建立表格</li><li>确定每一个格的值代表什么 </li><li>如何将大问题划分为具有相同解法的子问题</li><li>确定网格坐标轴</li></ol><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185431847.png" alt="image-20220221185431847"></p><p>尝试一下，在纸上绘制网格，将每个单词分解（子问题）</p><p>答案如下（思考下，这是如何得出的）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185929563.png" alt="image-20220221185929563"></p><p>解决这个问题核心的伪代码类似于下面这样</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185552675.png" alt="image-20220221185552675"></p><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ol><li><p>对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190054121.png" alt="image-20220221190054121"></p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>你可以先尝试着根据上面的思路自己写一下</p><p>在写的过程中你是否会发现一个问题，在代码的实现上，我们会发现上面的公式会有些问题，毕竟我们是用二维数组去记录这个过程，所以某些情况下会出现<code>data[index1 - 1][index2 - 1]</code>报错的情况，什么情况下呢</p><p>如下图，这些情况下的值在你按部就班时运行会报错的，因为它缺少斜对角的值，毕竟没有<code>data[-1][-1]</code>这样的值出现</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220222085726502.png" alt="image-20220222085726502"></p><p>怎么解决，有两种方法，第一种是每次到该计算都做一下判断，判断是否有值，我嫌太麻烦了，且影响从代码上去理解这个算法的思路，所以使用第二种，给你一个二维数组，你就会理解了，然后我就懒得解释了哈哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在里面，我会用一个函数<code>fillDataByWordLength</code>去填充第一行的0，以及在内层循环（列）中每次一开始填充一个0</p><p>还有一点，我使用了<code>max</code>和<code>maxWord</code>在每次判断时去分别存储<strong>最长公共子串长度</strong>和<strong>最长公共子串</strong>，免得后面再在二维数组去找一个最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br></pre></td></tr></table></figure><p><code>getMaxWord</code>函数主要用作获得最长的公共子串，比如，fish和fosh最长的公共子串就为sh</p><p>然后再看看下面的代码，应该没啥问题了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得最长的公共子串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxWord</span>(<span class="params">word, maxWordPosition, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = maxWordPosition - max + <span class="number">1</span>; i &lt;= maxWordPosition; i++) &#123;</span><br><span class="line">    res += word[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">//存储最长公共子串数</span></span><br><span class="line">  <span class="keyword">let</span> maxWord; <span class="comment">//存储最长公共子串</span></span><br><span class="line">  <span class="keyword">let</span> maxWord1Position; <span class="comment">//存储最长公共子串截至位置</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">        data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不相等则赋值为0</span></span><br><span class="line">        data[index1][index2] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxWord = getMaxWord(word1, maxWord1Position, max);</span><br><span class="line">  <span class="keyword">return</span> &#123; max, maxWord &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-1"><a href="#运行下-1" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190426458.png" alt="image-20220221190426458"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190516948.png" alt="image-20220221190516948"></p><p>这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的 字母数。如何计算最长公共子序列呢</p><p>计算过程如下：图很重要！！！！！！（懒得打字了）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190615957.png" alt="image-20220221190615957"></p><p>核心伪代码</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190713163.png" alt="image-20220221190713163"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>思路是和上面例子很相近的，只是判断语句不同了而已，直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若不相等，则从左边或上边的邻居方格中取一个最大值</span></span><br><span class="line">        data[index1][index2] = <span class="built_in">Math</span>.max(data[index1][index2 - <span class="number">1</span>], data[index1 - <span class="number">1</span>][index2]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">res</span>: data[word1.length][word2.length], <span class="attr">calculationMatrix</span>: data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-2"><a href="#运行下-2" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221191104618.png" alt="image-20220221191104618"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="动态规划的实际应用"><a href="#动态规划的实际应用" class="headerlink" title="动态规划的实际应用"></a>动态规划的实际应用</h3><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 </li><li>你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ol>]]></content>
    
    <summary type="html">
    
      动态规划算法通常用于求解具有某种最优性质的问题
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法</title>
    <link href="http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-10T06:00:00.000Z</published>
    <updated>2022-03-02T08:00:37.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，<strong>算法得到的是在某种意义上的局部最优解</strong></p><p>换句话说：贪婪算法就是每步都选择局部最优解，最终得到的就是全局最优解</p></blockquote><p>贪心算法也存在如下问题：</p><ol><li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑</li><li>贪心算法一般用来解决求最大或最小解</li><li>贪心算法只能确定某些问题的可行性范围</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150319952.png" alt="image-20220220150319952"></p><h3 id="集合覆盖问题（广播站问题）"><a href="#集合覆盖问题（广播站问题）" class="headerlink" title="集合覆盖问题（广播站问题）"></a>集合覆盖问题（广播站问题）</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150857304.png" alt="image-20220220150857304"></p><p>这一节的算法代码会在后面放出来，我们先专注于这个算法以及其应用先，毕竟会用但不知道在哪用就跟不会用差不多嘛</p><p>通过上面两个例子，我们可以得出如简介一样的总结，贪婪算法不算最优解，但是在某些复杂的问题下我们用它可以达到非常接近最优解的解，那什么又是复杂的问题，也就是哪些问题才需要用到贪婪算法呢</p><h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><blockquote><p>NP完全问题的简单定义：以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常 聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。</p></blockquote><p>比如<a href="https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/7737042" target="_blank" rel="noopener">旅行商问题</a>，这个<a href="https://zhuanlan.zhihu.com/p/159266077" target="_blank" rel="noopener">链接</a>会讲述TSP问题以及帮你引入到贪婪算法里，懂了这一节的例子也可以不用看了</p><p>比如有这么三个城市-北京、石家庄、呼和浩特，你都想去旅游，于是有一天，你开始规划路线，那么从哪里出发，最后去哪里，你会如何规划呢</p><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220152241040.png" alt="image-20220220152241040"></p><p>我们先不考虑起点从哪，假设我们想先去石家庄，然后去呼和浩特，最后再到北京，这便是其中一条路线，但我们想找出最短的那条路程，比较把时间花在路上，玩的很累不是吗，那么怎么选呢，<strong>穷举法</strong>？好像很不错的样子，我们来试试</p><blockquote><p>北京-石家庄-呼和浩特</p><p>北京-呼和浩特-石家庄</p><p>石家庄-北京-呼和浩特</p><p>石家庄-呼和浩特-北京</p><p>呼和浩特-北京-石家庄</p><p>呼和浩特-石家庄-北京</p></blockquote><p>然后就是在里面挑出一条最佳路线，显然，这个方法的时间复杂度是<strong>O(n！)</strong></p><p>这可是阶乘啊，意味着啥，当你越来越富，想玩的地方越来越多，你要挑选出一条最佳路线的难度可是越来越大，原来有钱人也不是那么好的</p><p>那么这个时候我们就要选择贪婪算法了</p><h3 id="如何识别-NP-完全问题"><a href="#如何识别-NP-完全问题" class="headerlink" title="如何识别 NP 完全问题"></a>如何识别 NP 完全问题</h3><p>NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小</p><p>下面几点可作为辨别NP问题的参考</p><ol><li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一 个NP完全问题吗？</li><li>在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？</li><li>你要制作中国地图，需要用不同的颜色标出相邻的省。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻省的颜色都不同。请问这是NP完全问题吗？</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说完上面，我们来看看JavaScript如何实现广播站问题的贪婪算法</p><p>首先，运行该算法我们需要什么样的数据格式，一个用于存储省名的数组、一个用于表达广播站及其可以广播的省份的映射关系-散列表，在里面，我们用字母来表示广播站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省份缩写</span></span><br><span class="line"><span class="keyword">let</span> address = [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>, <span class="string">'SC'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播站-散列表</span></span><br><span class="line"><span class="keyword">let</span> radioStation = &#123;</span><br><span class="line">  a: [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>],</span><br><span class="line">  b: [<span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'SC'</span>],</span><br><span class="line">  c: [<span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>],</span><br><span class="line">  d: [<span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  e: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  f: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'SC'</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着就是算法的实现了</p><p>记住我们的步骤</p><p>(1) 选出这样一个广播台，即它覆盖了<strong>最多的未覆盖</strong>省份。即便这个广播台覆盖了一些已覆盖的省，也没有关系。</p><p> (2) 重复第一步，直到覆盖了所有的州。</p><p>根据第二步，我们就应该会感觉到可能要用到迭代了</p><p>首先先不管用不用迭代，我们来分析下这个过程</p><p>最核心的一步：我们要找出<strong>最多的未覆盖</strong>省份的广播站，那么这一步如何实现</p><p>通过<strong>遍历</strong>广播站，找出广播站和所需要覆盖的省份间的<strong>交集</strong>，谁的交集包含的元素<strong>最多</strong>，就选哪个，这就是最核心的了，遍历、交集、最多，这三个名称就是算法核心代码了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line"><span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line"><span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">  <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">  <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">  intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着遍历完第一遍，有可能会剩下其他省份还没找出广播站呢，那该如何做呢，再对剩下的省份执行上述步骤嘛，这不就要用到迭代了，代码如下，我们用<code>res</code>这个变量用于存储最终的广播站结果集合，然后记得把当前选到的广播站从下次执行的函数参数中的数据删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line"><span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line"><span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br></pre></td></tr></table></figure><p>既然是迭代，那肯定要有终止条件，不然就无限迭代下去了，这个问题的基线条件是所有的地址都已找到所能广播的广播站了，换成代码的解释就是address长度为零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line"><span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是这个算法的大致代码了，等等，如果有一个地址没有任何广播站能广播到呢，出现这种情况怎么办，这种问题我们只能当作无解，毕竟没有广播站能广播到你要的地址，说明数据有问题，需求也就根本无法解决</p><p>代码上也就是，两者交集没有任何结果，如果address长度还没为0时，没有结果意味着没有广播站可以服务该地址了，所以注意该代码位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法： 参数：所有地点（数组）、广播站（散列表）、最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greedy</span>(<span class="params">address, radioStation, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line">  <span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line">  <span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line">  <span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">    <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">    <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">    intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br><span class="line"></span><br><span class="line">  res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">  address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line">  <span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line">  <span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 </li><li>对于NP完全问题，还没有找到快速解决方案。 </li><li>面临NP完全问题时，最佳的做法是使用近似算法。 </li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol><h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><p>三个都是NP问题，快去用贪婪算法试着解出来吧！加油💪</p>]]></content>
    
    <summary type="html">
    
      贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>狄克斯特拉算法</title>
    <link href="http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T14:00:00.000Z</published>
    <updated>2022-03-02T07:59:40.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800" target="_blank" rel="noopener">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>假设给定一个二维数组，里面存储着各个相邻点之间的距离，</p><p>比如第一个<code>[&#39;a&#39;, &#39;b&#39;, 20]</code>，表示着从A点到B点的距离为20，以此类推</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">30</span>],</span><br><span class="line">  [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="string">'e'</span>, <span class="string">'a'</span>, <span class="number">20</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而我们的需求则是，以某个确定的点为起点，得出其到其余点的最短距离，比如以a为起点，我们想得到其到b、c、d、e的最短距离</p><p>那么这个算法该如何在js上实现</p><p>单纯从这个数组来看，好像有点想不出解法，我们先试着把它转化成图形关系，从而更加容易理解点</p><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220218093850197.png" alt="image-20220218093850197"></p><p>从这个图，我们可以更加直观的理解每个点之间的位置距离关系，比如A，可以直接到达B、C、E，但却不能直接到达D，要想过去，还得通过一些“中介点”</p><p>接着，我们来简略介绍下狄克斯特拉算法的使用步骤</p><blockquote><p>(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 </p><p>(2) 更新该节点的邻居的开销。</p><p>(3) 重复这个过程，直到对图中的每个节点都这样做了。</p><p> (4) 计算最终路径。</p></blockquote><p>在默认初始化条件下：我们用一个表来记录默认起点下到其他点的最短距离</p><table><thead><tr><th>次数</th><th>S</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>{a}</td><td>20</td><td>3</td><td>∞</td><td>20</td></tr><tr><td>2</td><td>{a,c}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>3</td><td>{a,c,b}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>4</td><td>{a,c,b,d}</td><td>20</td><td>3</td><td>8</td><td>14</td></tr></tbody></table><p>用一个表格记录更新完最短距离表格后的目标地点的上一个节点</p><table><thead><tr><th>次数</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>2</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>3</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>4</td><td>a</td><td>a</td><td>c</td><td>d</td></tr></tbody></table><p>阐述下这个过程</p><p>首先，我们将A到各个其他点的距离记录进去，接着按<strong>初始距离从短到长</strong>的顺序将a,b、a,c、a,d这三个当作一个整体去更新表格(注意：这里不是简单的就是a→b，而是他们之间的最短路径)</p><p>记住，每次我们都从最短的路径入手，比如a到c的距离最短，那么我们就从该点c入手，其次就是在b和d中选择</p><p>比如在接下来，我们把a→c当作一个整体，它的默认权重为3，然后去对比其他各个点，注意看图，根据结果去刷新最短距离，比如c到e的距离是30，加上默认权重（a→c）3，是33，比a直接到达e还远，所以我们不更新该距离，以及c的最短距离的上一个节点还是a，其他类似，每一步更新完，即可得出起点到达该点的最短距离了</p><p>我们重点看下第三次和第四次，在第三次，a到b，c还是不变，但是c可以直接到d了,也就是说，在原先的基础a到c的距离3上加5，得出该距离为8，同时途径点可以更新为c</p><p>第四次，我们发现d到e的距离为6，加上a到d的最短距离8可以达到14，比a直接过去还短，所以我们更新表格，最短距离为14，上个节点为e</p><p>我们可以看到这样的规律，如果当前节点pass到终点end的距离(passEnd)加上起点start到当前节点pass的距离(startPass)小于默认起点start到终点end的距离(startEnd)，那么就更新表格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果startPass + passEnd &lt; startEnd</span><br><span class="line">则startEnd = startPass + passEnd（更新）</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>我们用一个对象来存储当个点到其他点的距离，比如下面</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    instance: 20,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    instance: 3,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个函数来格式化该操作，data为数组数据，startPoint为起点，targetPoint为终点集合（数组），格式完数据后，我们把起点到起点的数据删掉，因为该点并没有什么用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着，我们用另一个对象把所有数据包裹起来，</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   起点1:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2: &#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;,</span><br><span class="line">   起点2:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;...</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现该操作的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对比长度的函数，通过前面的介绍我们可以知道这个过程的实现，无需多言，直接看代码，入参含义为（数组数据，起点名称，当前点名称，终点名称）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>主函数入口：最主要的就是迭代，对每个点进行迭代执行analyse函数，再对每个点下的终点距离进行遍历判断</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>将结果进行描述的函数，在这里对于算法来说没啥用处，主要就是结果的文字展示</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>拿前面的数据进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = dijkstra(data, <span class="string">'a'</span>, [<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br><span class="line"><span class="keyword">let</span> res1Text = roadPoint(res1, <span class="string">'e'</span>) <span class="comment">//文字描述</span></span><br><span class="line"><span class="built_in">console</span>.log(res1Text);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220219164513219.png" alt="image-20220219164513219"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪杰斯特拉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法</li><li>狄克斯特拉算法用于在加权图中查找最短路径。 </li><li>仅当权重为正时狄克斯特拉算法才管用。 </li><li>如果图中包含负权边，请使用贝尔曼福德算法。</li></ol>]]></content>
    
    <summary type="html">
    
      迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广度优先搜索</title>
    <link href="http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2021-10-01T12:00:00.000Z</published>
    <updated>2022-03-02T08:26:26.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>宽度优先<a href="https://baike.baidu.com/item/搜索算法/2988274" target="_blank" rel="noopener">搜索算法</a>（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra<a href="https://baike.baidu.com/item/单源最短路径/6975204" target="_blank" rel="noopener">单源最短路径</a>算法和Prim<a href="https://baike.baidu.com/item/最小生成树" target="_blank" rel="noopener">最小生成树</a>算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>广度优先搜索的运行时间为O(顶点 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数</p><p>对于检查过的人（顶点），务必不要再去检查，否则可能导致无限循环</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ol><h2 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h2><p>有向图是单向的</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904144514052.png" alt="image-20210904144514052"></p><p>无向图没有箭头，直接相连的节点互为邻居，无向图相邻的两个结点彼此指向对方，其实就是一个环，跟上图一样</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>有这么一个人员数据表，他们都有各自的<strong>职业</strong>和<strong>邻居</strong>，假设你是其中一个人：a——工地搬砖工。有一天，你想吃新鲜的蔬菜，但是你不相信陌生人，所以你打算问你的邻居，看看有没有什么认识的人（职业为农民）可以提供保证新鲜的蔬菜给你，如何操作呢（下面为思路）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'worker'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>],</span><br><span class="line">    profession: <span class="string">'panter'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'teacher'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    neighbor: [<span class="string">'c'</span>, <span class="string">'e'</span>],</span><br><span class="line">    profession: <span class="string">'doctor'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  e: &#123;</span><br><span class="line">    neighbor: [<span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'police'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  f: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'farmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  g: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>],</span><br><span class="line">    profession: <span class="string">'programmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据广度优先搜素算法，我们首先根据各个人员的邻居构建出图模型</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904145548745.png" alt="image-20210904145548745"></p><p>接着就是从你（a）自己入手，首先你从b和c开始找起，如若b和c就是农民，那么久返回该对象的名字,我们可以将这两人压入待查找数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c];</span><br></pre></td></tr></table></figure><p>b如果不是，那么就把b的邻居加入数组，一起找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c,a,f,g];</span><br></pre></td></tr></table></figure><p>同时把b弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c,a,f,g];</span><br></pre></td></tr></table></figure><p>当然，a也不是，否则查找会造成循环，不断去找a，所以一开始我们需要定义一个数组用以存储已查过的对象，然后每次查完一个放进一个，后面的每次查找待找数组时在已查找数组中查看是否已查过，是则把该值从待找数组中丢掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finded = [<span class="string">'a'</span>];</span><br></pre></td></tr></table></figure><p>继续上面几个步骤，对后面的数据进行查找↓</p><p>接下来是c，c也不是，所以把c的邻居也加进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,f,g,a,f,d];</span><br></pre></td></tr></table></figure><p>重复这几个步骤，直到找出最终的结果</p><p>方法代码如下</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/carbon.png" alt="carbon"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>广度优先搜索指出是否有从A到B的路径。</li><li>如果有，广度优先搜索将找出最短路径。</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来 解决问题。</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 </li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约 会，而rachel也与ross约会”。</li><li>队列是先进先出（FIFO）的。 </li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必 须是队列。 </li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环。</li></ol>]]></content>
    
    <summary type="html">
    
      宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2021-08-30T08:00:00.000Z</published>
    <updated>2022-03-02T08:26:48.472Z</updated>
    
    <content type="html"><![CDATA[<p>必看：<a href="https://zhuanlan.zhihu.com/p/95156642" target="_blank" rel="noopener">来吧！一文彻底搞定哈希表！</a></p><p>进阶：<a href="https://baike.baidu.com/item/哈希表/5981869?fr=aladdin" target="_blank" rel="noopener">哈希表_百度百科 (baidu.com)</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20210904161554231.png" alt="image-20210904161554231"></p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型</li><li>一种包含额外逻辑的数据结构</li><li>也被称为散列映射、映射、字典和<br>关联数组</li><li>散列表的查找、插入和删除速度都非常快</li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>查找（模拟映射关系）</li><li>防止重复</li><li>用作缓存</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="什么是冲突"><a href="#什么是冲突" class="headerlink" title="什么是冲突"></a>什么是冲突</h4><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20220216142535367.png" alt="image-20220216142535367"></p><blockquote><p>冲突很糟糕，应使用可以最大限度减少冲突的散列函数</p></blockquote><p>避免方法：</p><ol><li>较低的填装因子<ul><li>填装因子越低，发生冲突的可能性越小，<br>散列表的性能越高</li><li>经验：一旦填装因子大于0.7，就调整散列表的长度</li><li>虑到调整长度所需的时间，散列表操作所需的时间也为O(1)</li></ul></li><li>良好的散列函数<ul><li>良好的散列函数让数组中的值呈均匀分布</li><li>糟糕的散列函数让值扎堆，导致大量的冲突</li><li>散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置</li></ul></li></ol><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100</li></ol><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="伪散列函数查找商品价格"><a href="#伪散列函数查找商品价格" class="headerlink" title="伪散列函数查找商品价格"></a>伪散列函数查找商品价格</h3><p>功能：</p><ol><li>添加商品及其价格</li><li>输入商品，得到其价格</li></ol><p>思路：</p><ol><li>使用类存储</li><li>获取商品价格方法<ul><li>通过遍历已有商品得到其价格并返回出去</li></ul></li><li>添加商品方法<ul><li>通过添加商品将该数据添加到对象中</li></ul></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/6130935fe401fd1fb6a2dfb5.png" alt="6130935fe401fd1fb6a2dfb5"></p><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h3><p>该散列表默认按照最高长度为24来进行字符串存储</p><p>slots用于初始化散列表时的数据存储</p><ul><li>add方法<ul><li>得到当前传入值的字符串长度</li><li>判断当前长度对应的数组位置是否还未开辟出新的数组，是则开辟出新的内存地址</li><li>将当前字符串添加到散列表（slots）中去</li></ul></li><li>delete方法<ul><li>从散列表中查找该字符串长度对应的数组位置</li><li>获得该元素在该数组（对应字符串长度的数组）中的<strong>位置</strong></li><li>将该数据从散列表中数组对应的位置删除</li></ul></li><li>get方法<ul><li>通过<strong>过滤函数（filter）</strong>将数据从散列表中取出来，并返回该值</li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/613095421efad40d9391d4ad.png" alt="613095421efad40d9391d4ad"></p>]]></content>
    
    <summary type="html">
    
      是根据关键码值(Key value)而直接进行访问的一种数据结构
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js原型小记（大记）</title>
    <link href="http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/</id>
    <published>2021-08-22T08:00:00.000Z</published>
    <updated>2022-03-04T08:44:41.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型、原型链、-proto-、prototype"><a href="#原型、原型链、-proto-、prototype" class="headerlink" title="原型、原型链、__proto__、prototype"></a>原型、原型链、__proto__、prototype</h1><blockquote><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p></blockquote><p>也就是说，在js中，我们是可以通过克隆创造世界，看下面的代码，首先我们创建一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个构造函数，暂且将它想象成类，然后我们来new一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>我们创造了一个admin对象，接着，如果有一个admin和上面所创造的对象同名同年龄时，我们该怎么创建呢，有人说：这还不简单嘛，再new一个不就得了，确实，在这里new一个难度不大，但当我们构造同一个对象需要的参数很多时，那又该怎么办，按着原来的参数继续new吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, height, weigt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.height = height,</span><br><span class="line">  <span class="keyword">this</span>.weight = weight,</span><br><span class="line">  <span class="comment">//... 还有其它很多的属性</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经创建了一个对象</span></span><br><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>,<span class="number">177</span> ,<span class="number">110</span>,...)</span><br><span class="line"><span class="comment">// 要再创建同个对象</span></span><br></pre></td></tr></table></figure><p>这样的参数要我们一个一个填进去，但我们已经新建了一个完全的一样的对象，而且这样子做还要防止参数一不小心填错导致对象不同</p><p>所以我们采用克隆的方式来创造一个一模一样的对象，ECMAScript 5提供了Object.create 方法，可以用来克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneAdmin = <span class="built_in">Object</span>.create( admin);</span><br></pre></td></tr></table></figure><p>这，便是js的克隆，在这时候，cloneAdmin.__proto__会指向admin，__proto__是啥，后面我们会提到，这里你只需要知道，这时候的cloneAdmin已经继承admin几乎所有属性包括方法了</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>我们再来了解下原型和原型链，什么是原型，就像上面举的例子，cloneAdmin是通过admin克隆而来的，那么它的原型便是admin，如果现在有一个对象clone2，克隆自cloneAdmin，那么clone2的原型便是cloneAdmin，而从它到admin这一条线上的所有对象便是原型链</p><blockquote><p>js的继承：基于原型链的委托机制就是原型继承的本质</p></blockquote><p>如何理解这句话，我们继续上面的例子，现在cloneAdmin克隆自admin，那么它是可以使用admin的所有属性和方法的，前提是它没有覆盖掉原型的方法，这类似于我们学习其它语言的继承特性</p><p>所以我们也就可以知道：<strong>当对象无法响应某个请求时，会把该请求委托给它自己的原型</strong></p><p>所以，通过以上，可以得出：原型编程范型至少包括以下基本规则</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><h2 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h2><p>JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。</p><p>在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。</p><h2 id="JS的克隆"><a href="#JS的克隆" class="headerlink" title="JS的克隆"></a>JS的克隆</h2><p>JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。</p><h2 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h2><p>JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。</p><p>__proto__就是对象跟“对象构造器的原型”联系起来的纽带。（__proto__：指向该对象的构造函数的原型对象，prototype指向该构造函数的原型对象——来自<a href="https://www.zhihu.com/question/34183746/answer/58155878" target="_blank" rel="noopener">知乎</a>，强烈建议阅读该文章）</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h2><p>JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。</p><p>如：我们可以创建一个无原型的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一参数为原型指向，第二个为对象属性编辑</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'hhh'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原型链并不是无限长的，当对象通过原型链找某个属性找到根节点而找不到时，则会返回undefined（Object.prototype 的原型是 null）</p><h1 id="基于原型的继承以及constructor"><a href="#基于原型的继承以及constructor" class="headerlink" title="基于原型的继承以及constructor"></a>基于原型的继承以及constructor</h1><p>通过上面，我们可以知道继承是可以通过原型实现，通过上面的继承原型图，我们进行相应的练习</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><p>首先创建构造函数User</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getDetail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，我们新建一个对象zhangsan</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>现在我们想新建另一个对象李四，让它直接继承于张三（也就是张三的儿子），我们可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> lisi = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(lisi, zhangsan)</span><br><span class="line">lisi.name = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure><p>ok，这样我们就简单的实现了继承，然后，提出一个问题，张三、李四以及构造函数User之间的关系是怎样的（通过上图理解）</p><p>弄清楚之后，你便会对__proto__、prototype、原型继承、原型和原型链有了更深刻的理解(下面是答案，记住一点，prototype是构造函数独有的，对象并没有这个属性，且这个属性指向构造函数原型)</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt="原型继承"></p><p>通过这张图，我们也可以知道</p><p><code>User.prototype.constructor() === User()</code></p><p>也就是说，你也可以通过<code>new User.prototype.constructor()</code>创建对象，当然正常人不会这样做（麻烦）</p><h1 id="构造函数-对象的原型检测"><a href="#构造函数-对象的原型检测" class="headerlink" title="构造函数/对象的原型检测"></a>构造函数/对象的原型检测</h1><p>我们想要对某一个对象的原型进行判断，有两种方法，一种是通过判断构造函数，另一种则是直接判断对象</p><p>首先我们声明三个类、定义它们间的关系以及实例化出各自的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">B.prototype = a</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line">C.prototype = b</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br></pre></td></tr></table></figure><ol><li><p>instanceof方法（构造函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> C)</span><br></pre></td></tr></table></figure><p>结果都为真</p></li><li><p>dad isPrototypeOf(son)（对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(b))</span><br><span class="line"><span class="built_in">console</span>.log(b.isPrototypeOf(c))</span><br><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(c))</span><br></pre></td></tr></table></figure><p>结果也都为真</p></li></ol><p>两个方法都会循着原型链向上找，唯一不同的便是instanceof需要传入构造函数，而另一个方法则是传入对象</p><h1 id="原型链中的对象遍历"><a href="#原型链中的对象遍历" class="headerlink" title="原型链中的对象遍历"></a>原型链中的对象遍历</h1><p>首先胡乱设置两个对象，同时这两个对象有继承关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">  A() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我叫"</span> + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  age: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.__proto__ = a</span><br></pre></td></tr></table></figure><p>好的，也就是说a是b的爸爸，然后我们来遍历一下b对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是什么(name 、age、A())</p><p>由此我们可以得出：in遍历是会遍历出包含原型链上其它原型的属性方法，那么如果我们只是想要遍历b独有的方法呢</p><p>这时候可以利用hasOwnProperty()方法去判断方法属性是否属于当前调用对象独有的，使用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被检测对象.hasOwnProperty(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure><p>所以我们就可以使用for_in循环遍历出当前对象的属性方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="comment">// 判断当前属性是否为当前对象独有</span></span><br><span class="line">  <span class="keyword">if</span> (b.hasOwnProperty( key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出的结果就是b自己独有的属性方法啦</p><h1 id="借用其他原型链方法"><a href="#借用其他原型链方法" class="headerlink" title="借用其他原型链方法"></a>借用其他原型链方法</h1><p>现在我们有个数组arr，当有个需求要我们求出这个数组的最大值时，你会咋做嘞</p><p>有些人可能会这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>也有可能这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">v, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt; v ? c : v</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>但是嘞，这些都是基于数组原型的方法实现的，声明的数组类型本来就是指向该原型的，那如果这时候我想调用Math里面的方法去实现这一需求，Math.max()方法不需要上面那么复杂的逻辑实现，更简单有木有，但是要如何做呢</p><p>这时候我们就要用到apply或call方法啦（两个函数都可以改变方法的this指向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><p>这样得出来的结果也是一样的，更简单明了是不，他的原理便是改变原函数max的指向，使得我们可以调用不处于同一条原型链的其它对象的方法</p><p>再来一个例子，我们利用数组的过滤来对Dom进行操作，需求是这样的：给出两个input控件，我们想要获得指定的控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"我是a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"我是b"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想要获得name=a的元素，怎么做呢，很简单：1.获取所有input控件 2.调用数组的filter方法进行过滤筛选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = <span class="built_in">document</span>.querySelectorAll(<span class="string">'[v-model]'</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Array</span>.prototype.filter.call(ts, e =&gt; e.getAttribute(<span class="string">'name'</span>) === <span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//下面的方法也行</span></span><br><span class="line"><span class="comment">// let res = [].filter.call(ts,e =&gt; e.getAttribute('name') === 'a')</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>].value)</span><br></pre></td></tr></table></figure><h1 id="构造函数原型方法和构造函数内的方法"><a href="#构造函数原型方法和构造函数内的方法" class="headerlink" title="构造函数原型方法和构造函数内的方法"></a>构造函数原型方法和构造函数内的方法</h1><p>从前面我们可以知道，用构造函数实例化出来的对象，他的原型是构造函数的prototype属性，那么当我们给构造函数的prototype对象添加方法时，这个实例化出来的对象也可以使用该方法，那要是将一个对象的__proto__指向该构造函数的prototype时，它是否可以使用构造函数内部定义的方法呢，让我们看一下</p><p>首先定义一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age= <span class="number">18</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给它的原型新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个对象，并分别调用构造函数内的方法和构造函数prototype的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">'user1'</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1.getAge())</span><br><span class="line">user1.getName()</span><br></pre></td></tr></table></figure><p>结果都可以正常显示</p><p>接着我们直接定义另一个对象，并强制将其原型指向User.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = &#123;&#125;</span><br><span class="line">user3.__proto__ = User.prototype</span><br></pre></td></tr></table></figure><p>调用getAge()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user3.getAge())</span><br></pre></td></tr></table></figure><p>正常显示，调用getName()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user3.getName()</span><br></pre></td></tr></table></figure><p>无法执行，程序报错，显示该错误：user3.getName is not a function</p><p>所以由此我们可以得出，构造函数内部定义的方法，只有在由他实例化出来的对象才会得到，而将一个自定义对象原型指向该构造函数的prototype对象时，是无法使用该构造函数内部的方法的，但是毫无疑问的，它可以使用该构造函数的prototype对象内的方法</p><h1 id="设置和获得原型"><a href="#设置和获得原型" class="headerlink" title="设置和获得原型"></a>设置和获得原型</h1><p>上面我们可以知道，设置对象的原型可以直接使用obj.__proto__属性强制绑定，下面是Object自带的两个方法进行原型设置以及获得当前对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置原型</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(son, dad)</span><br></pre></td></tr></table></figure><p>该方法和son.__proto__ = dad一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(son)</span><br></pre></td></tr></table></figure><p>使用该方法即可获得他爹了</p><h1 id="proto-原理（get、set）"><a href="#proto-原理（get、set）" class="headerlink" title="__proto__原理（get、set）"></a>__proto__原理（get、set）</h1><p>不知道你们有没有试过，将对象的__proto__属性定义成出对象外的其它值类型数据是不可行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;&#125;</span><br><span class="line">obj.__proto__ = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这样是没有任何效果的，为什么呢，因为__proto__实际上是访问器(get/set)构造而成的，他会对设置的值进行过滤，只有符合对象类型的数据，它才会赋值，让我们来仿造一个，了解其实质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Obj  = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> _proto_() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.obj</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> _proto_(e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Obj._proto_ = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj._proto_);</span><br></pre></td></tr></table></figure><p>核心代码便是<code>e instanceof Object</code>，即判断当前传入类型是否为对象，是则赋值成功，否则忽略该赋值</p><h1 id="基于原型面向对象的多态"><a href="#基于原型面向对象的多态" class="headerlink" title="基于原型面向对象的多态"></a>基于原型面向对象的多态</h1><p>js也可以多态，你没骗我吧，没有的事呢，那就让我们来看看js的多态究竟是个啥</p><p>假设现在有个情况，你家里来客人了，你爸叫你和你妹跟客人打招呼，你说了句“叔叔好，我是我爸的儿子jie（假设你叫jie）”，你妹说：“叔叔好，我是我爸的女儿hua（假设你妹叫hua）”</p><p>看到没有，同样的一个行为，哥哥和妹妹的表现是不同的，这便是多态。让我们用代码实现一下</p><p>首先定义爸爸构造函数，然后 给爸爸原型定义一个介绍的方法（毕竟指令由爹地发出的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.introduction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.show());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着构造儿子，并继承于老爸，然后定义儿子的介绍方法show()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使得Son.prototype.__proto__指向Father.prototype</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Son.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是儿子'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来就是女儿，和儿子一样，但是其show()方法和儿子有所不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Daughter.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Daughter.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是女儿'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是实例化一个儿子和女儿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="keyword">new</span> Son(<span class="string">'jie'</span>)</span><br><span class="line"><span class="keyword">let</span> hua = <span class="keyword">new</span> Daughter(<span class="string">'hua'</span>)</span><br></pre></td></tr></table></figure><p>假设此时他们接收到了父亲的指令，于是乎分别调用introduction方法并介绍自己</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jie.introduction() <span class="comment">//我是儿子jie</span></span><br><span class="line">hua.introduction() <span class="comment">//我是女儿hua</span></span><br></pre></td></tr></table></figure><p>这便是js的多态实现</p><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>没啥好说的，就是继承父类的方法，但是由自己的实现方式，需要重新定义，这便是重写，直接理解代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个father构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建son对象</span></span><br><span class="line"><span class="keyword">let</span> son = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化爹地</span></span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 让son的原型指向爹地对象</span></span><br><span class="line">son = <span class="built_in">Object</span>.create(father);</span><br><span class="line">son.hi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写son方法</span></span><br><span class="line">son.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'son hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">son.hi();</span><br></pre></td></tr></table></figure><h1 id="禁止自定义函数原型的constructor被遍历"><a href="#禁止自定义函数原型的constructor被遍历" class="headerlink" title="禁止自定义函数原型的constructor被遍历"></a>禁止自定义函数原型的constructor被遍历</h1><p>之前我们已经了解过consructor，它是构造函数原型里面指向构造函数的一个属性，如下，两者是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.constructor === User</span><br></pre></td></tr></table></figure><p>但当我们想让一个构造函数的原型继承于另一个构造函数时，会发生一点意外</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'son'</span></span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br></pre></td></tr></table></figure><p>在这里面，我们让Son的prototype原型指向Father.prototype，看起来好像一切都正常，也不影响继承，但是仔细观察你会发现，里面的constructor不见了，通过打印<code>console.dir(Son.prototype)</code>，我们可以发现它的constructor确实不见了</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528202637586.png" alt="image-20210528202637586"></p><p>这会造成什么问题，你会无法通过下列方法实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son.prototype.constructor();</span><br></pre></td></tr></table></figure><p>所以，为了避免它原先的constructor丢失造成的问题，我们需要把它纠正回来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure><p>OK啦，只要在每次继承之后加上这句代码，就可以防止constructor丢失了，但其实在这里，还会有一个问题，让我们来遍历一下这个原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> Son.prototype) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到什么结果：hi以及constructor，我们希望constructor出现吗，并不会，我们希望这些原本对象自带的属性是隐藏且不可遍历的，但是在这里，我们将原本丢失的自带构造器添加上去，导致其暴露并可以遍历出来，所以我们要将其可枚举的属性设置为false，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，最后，当我们需要构造函数继承时，需要以下三个步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复原有构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="父类构造函数初始化属性"><a href="#父类构造函数初始化属性" class="headerlink" title="父类构造函数初始化属性"></a>父类构造函数初始化属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>， 我今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我们定义的一个父类构造函数，也就是说，有一个构造函数会继承它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如何正确继承，哎对了，三步走实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Admin.prototype = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line"></span><br><span class="line">Admin.prototype.constructor = Admin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Admin.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Admin,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，我们现在想让Admin不用自定义的同时也可以同User一样初始化对象（name、age），怎么实现呢</p><p>前面有讲过的，改变User的this指向不就可以实现了吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  User.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过args传值同时改变User实例化的this指向，从而实现Admin同User一样初始化属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mayun = <span class="keyword">new</span> Admin(<span class="string">'mayun'</span>, <span class="number">22</span>);</span><br><span class="line">mayun.show();</span><br></pre></td></tr></table></figure><p>正确输出啦</p><h1 id="原型工厂封装属性"><a href="#原型工厂封装属性" class="headerlink" title="原型工厂封装属性"></a>原型工厂封装属性</h1><p>每次对构造函数原型进行继承，都要三步走，是不是有点麻烦，要是多个构造函数原型都要继承，岂不是要写很多次，所以我们把它给封装了吧，这样每次就可以直接调用啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">child, dad</span>) </span>&#123;</span><br><span class="line">  child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">    value: child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后的函数也称为原型工厂，我们来看看它的使用方法把</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Son, Father);</span><br></pre></td></tr></table></figure><p>OK，这样子每次继承就不会很麻烦了，直接调用该函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Daughter, Father);</span><br></pre></td></tr></table></figure><h1 id="对象工厂派生对象实现继承"><a href="#对象工厂派生对象实现继承" class="headerlink" title="对象工厂派生对象实现继承"></a>对象工厂派生对象实现继承</h1><p>我们之前已经了解过Object.create()可以实现对象继承，现在让我们来封装一个函数，来理解下构造函数实例化对象的原理，从而实现继承吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' is '</span> + <span class="keyword">this</span>.age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有这么一个构造函数，我们想用它创造出许多子对象（类似于构造函数初始化），如何实现呢</p><p>第一步便是克隆出构造函数原型对象（creat）</p><p>第二步初始化对象(call、apply（前面刚讲过）)</p><p>第三步便是返回这个对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象工厂造对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line">  User.call(instance, name, age);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来实例化看看吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dy = admin(<span class="string">'dy'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dy.show())</span><br></pre></td></tr></table></figure><p>成功！</p><h1 id="使用mixin实现多继承"><a href="#使用mixin实现多继承" class="headerlink" title="使用mixin实现多继承"></a>使用mixin实现多继承</h1><p>在上面，我们了解到了可以借用其他原型链上的方法满足需求，但有没有其它方式可以使用其它原型链的方法呢。</p><p>“这个我知道，继承那个原型不就好嘛”，哎哟，好像有点道理哦，但这样却可能会导致继承的混乱。</p><p>我们知道，原型链为线形的，也就是说，你只能单向继承，大白话就是你只能有一个亲生爸爸，而如果这时候，跟上面的需求一样，arr数组想用Math对象中的方法时怎么办，</p><p>有小朋友提到了，我可以让Math当Array的爸爸嘛，这样顺着一条原型链上去就能实现方法了嘛，是的没错，但你有没有想过在这个过程中，只是你一个数组需要用到Math中的方法，如果其他数组不需要呢，那么它们也没办法，依然会被绑定到这条原型链上，这样就会造成这条原型链混乱且复杂。</p><p>我们更加希望，事物是有序的，一条继承链下来，对象之间都是有需求的，都是相关联且合理的，所以，这个方法并不可取</p><p>那么有什么方法可以实现这一需求呢：mixin思想，我们使用混入来实现类似多继承的效果，从而使得原原型链（主干）不受影响</p><p>这里要用到Object的一个方法实现类似mixin的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj1, obj2);</span><br></pre></td></tr></table></figure><p>首先创造一个事物构造函数还有其原型的一个方法show</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫`</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创造两个事物构造函数分别继承它，extend详见上面的原型工厂继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Human, Thing);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Car, Thing);</span><br></pre></td></tr></table></figure><p>然后实例化对象并验证下是否继承到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohong = <span class="keyword">new</span> Human(<span class="string">'xiaohong'</span>);</span><br><span class="line">xiaohong.show();</span><br><span class="line"><span class="keyword">let</span> benchi = <span class="keyword">new</span> Car(<span class="string">'banchi'</span>);</span><br><span class="line">benchi.show();</span><br></pre></td></tr></table></figure><p>很幸运，可以使用父类方法展示自己（我叫xiaohong，我叫banchi）</p><p>然后我们创建一个行为类action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我跑'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我叫'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想让benchi和xiaohong都能使用这个类中的方法，但是他们已经有爹地了，这时候我们用mixin思想实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(benchi, action);</span><br><span class="line"><span class="built_in">Object</span>.assign(xiaohong, action);</span><br></pre></td></tr></table></figure><p>然后就执行方法吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">benchi.move(); <span class="comment">//banchi给我跑</span></span><br><span class="line">xiaohong.call(); <span class="comment">//xiaohong给我叫</span></span><br></pre></td></tr></table></figure><p>成功！我们实现了类似多继承</p><h1 id="mixin的内部继承以及super"><a href="#mixin的内部继承以及super" class="headerlink" title="mixin的内部继承以及super"></a>mixin的内部继承以及super</h1><p>还是依照上面的例子，我们想让mixin内部的对象实现继承且，banchi和xiaohong可以调用得到，如何实现嘞</p><p>假设有个todo类，想让它当action的爸爸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todo = &#123;</span><br><span class="line">  doing() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'在 '</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实还是和前面一样的继承，让action的__proto__继承todo即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.__proto__ = todo;</span><br></pre></td></tr></table></figure><p>这样便成功继承，然后我们稍微修改下action里面的方法，使得它可以调用父类todo的方法，这里我们用到<strong>super</strong>关键字</p><blockquote><p>super === this(action).__proto__（this指<strong>当前定义</strong>的对象）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'跑'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'叫'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后同上面一样运行一下，结果也是正常显示啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(benchi.move());</span><br><span class="line"><span class="built_in">console</span>.log(xiaohong.call());</span><br></pre></td></tr></table></figure><p>我们来看一下他们之间的继承关系（可以多画画这种继承图帮助理解）</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/mixin%E6%8C%87%E5%90%91.png" alt="mixin指向"></p><p>好哒，这一部分我们就了解了mixin内部继承以及super代替原型（son.__proto__）这两个重要的知识点啦</p><h1 id="继承操作Dom（综合案例）"><a href="#继承操作Dom（综合案例）" class="headerlink" title="继承操作Dom（综合案例）"></a>继承操作Dom（综合案例）</h1><p>现在有这样一个需求，我们有三个几乎一样的组件，我们想让他们的功能一致，只是样式稍微不同而已，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214206292.png" alt="image-20210528214206292"></p><p>三者都是点击切换按钮切换状态语且改变背景颜色，点击隐藏，下面的状态语模块消失，同时按钮提示语改变，开始动手吧</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214431075.png" alt="image-20210528214431075"></p><p>样式不说，直接上核心代码</p><p>首先创造动作构造函数，并且定义三个方法——隐藏、显示、背景颜色以及提示语改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animation</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animation.prototype.hide = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.change = <span class="function"><span class="keyword">function</span> (<span class="params">color, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.backgroundColor = color;</span><br><span class="line">  <span class="keyword">this</span>.innerHTML = value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创造APP构造函数用于创建展示模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">id, data=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">  <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span><br><span class="line">    value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span><br><span class="line">    tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span><br><span class="line">  &#125;,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让它继承于动作构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(App, Animation);</span><br></pre></td></tr></table></figure><p>接着为两个按钮注册点击事件，同时调用父类的显示隐藏以及切换背景方法</p><p>显示隐藏切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.changeIf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态语切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.toggle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及首次打开页面的初始化方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span><br><span class="line">  <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是执行这三个方法的启动函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.toggle();</span><br><span class="line">  <span class="keyword">this</span>.changeIf();</span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以实例化对象，调用run方法啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span><br><span class="line"> color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span><br><span class="line"> value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span><br><span class="line">&#125;);</span><br><span class="line">div1.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span><br><span class="line">div2.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span><br><span class="line">  color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">div3.run()</span><br></pre></td></tr></table></figure><p>就算你有其它需要类似功能的模块，你也可以直接实例化该对象并执行run方法，而不用每个同功能的模块书写多次相同冗余的代码了</p><p>全部代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        margin: 5px;</span><br><span class="line">        border: 2px solid rgba(226, 121, 247);</span><br><span class="line">        height: 300px;</span><br><span class="line">        width: 500px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      *<span class="selector-attr">[name=<span class="string">"sec"</span>]</span> &#123;</span></span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 80%;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">        color: pink;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">input</span><span class="selector-attr">[name]</span> &#123;</span></span><br><span class="line">        background-color: pink;</span><br><span class="line"><span class="css">        <span class="comment">/* border: pink; */</span></span></span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 10%;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">Animation</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="actionscript">      Animation.prototype.hide = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.change = <span class="function"><span class="keyword">function</span> <span class="params">(color, value)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.backgroundColor = color;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.innerHTML = value;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// * 原型继承工厂函数</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(child, dad)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span></span><br><span class="line">        child.prototype.constructor = child;</span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span></span><br><span class="line">          value: child,</span><br><span class="line"><span class="actionscript">          enumerable: <span class="literal">false</span>,</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">App</span><span class="params">(id, data=&#123;&#125;)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span></span><br><span class="line"><span class="actionscript">          color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span></span><br><span class="line"><span class="actionscript">          value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span></span><br><span class="line"><span class="actionscript">          tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span></span><br><span class="line">        &#125;,data)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      extend(App, Animation);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.changeIf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.toggle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.init = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.run = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.toggle();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.changeIf();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.init()</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">       color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span></span><br><span class="line"><span class="actionscript">       value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span></span><br><span class="line">      &#125;);</span><br><span class="line">      div1.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span></span><br><span class="line">      div2.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span></span><br><span class="line">      &#125;)</span><br><span class="line">      div3.run()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>思维导图总结</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210529101210203.png" alt="image-20210529101210203"></p><p>这便是对以上全部知识点综合练习的案例了，不足之处还望批评指出，<strong>请多多指教</strong></p>]]></content>
    
    <summary type="html">
    
      来吧，快七千字的js原型笔记，好好嚼吧，😭😭😭
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://Dong-666.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-20T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:01.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-amp-C（分而治之）"><a href="#D-amp-C（分而治之）" class="headerlink" title="D&amp;C（分而治之）"></a>D&amp;C（分而治之）</h2><p>工作原理：</p><ol><li>找出简单的基线条件；</li><li>确定如何缩小问题的规模，使其符合基线条件</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>对一块400m * 640m的土地进行划分</p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165345879.png" alt="image-20210829165345879" style="zoom:50%;"><p>对于640 m × 400 m的土地，可从中划出的最 大方块为400 m × 400 m。 这将余下一块更小的土地，其尺寸为400 m × 240 m</p><p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165421947.png" alt="image-20210829165421947"></p><blockquote><p>重点：适用于这小块地的最大方块（正方形），也是适用于整块地的最大方块</p><p>这是关于“欧几里得算法”的知识</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>采用分而治之的思想进行排序，是对<a href="https://baike.baidu.com/item/冒泡排序/4602306" target="_blank" rel="noopener">冒泡排序</a>算法的一种改进</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p>1) 选择基准值。</p><p>2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 </p><p>3) 对这两个子数组进行快速排序。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>使用快速排序进行排序</p><ol><li>定义左数组存储比当前值小的值，右数组存储比当前数值大的值，以及当前比较目标值</li><li>定义基线条件：当当前传参数组索引小于等于1时，停止执行下面代码并返回当前数组</li><li>定义递归条件<ol><li>截取当前数组内要进行比较的目标值，避免参与遍历导致无限循环</li><li>进行遍历：大于当前值放至右数组，小于当前值放至左数组</li></ol></li><li>返回左数组＋当前值+右数组</li></ol><p>![carbon (1)](快速排序/carbon (1).png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 </li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 </li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n) 快得多。</li></ol>]]></content>
    
    <summary type="html">
    
      采用分而治之的思想进行排序，是对冒泡排序算法的一种改进
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-12T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:41.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h2><p>这里涉及的数据类型为<a href="https://blog.csdn.net/Oralinge/article/details/103585108" target="_blank" rel="noopener">引用类型</a>，计算机就像是很多抽屉的集合体，每个抽屉都有地址，当你往里面存储数据时，计算机会将每个数据存储到各自的“抽屉”去，然后用一个内存地址指向该抽屉，方便你根据内存地址去拿取你所需的值</p><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。</p><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>这里只会简单阐述数组和链表的概念，更多会讲述这两种不同数据类型的区别</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>链表是一种物理<a href="https://baike.baidu.com/item/存储单元/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/存储结构/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/数据元素/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/数据元素" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>域。 </p></blockquote><p>简单来说，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。所以，<strong>链表的优势在插入元素方面</strong>。</p><p>当你要往数组插入元素时，计算机要根据数组的长度去寻找一块连续的跟该数组长度相匹配的内存去进行存储，而链表只要存储下个元素的内存地址即可，所以即使链表中的各个数据是分开的不连续的，但还是能通过上一个数据去寻找下个数据的位置。所以在插入数据方面，链表无需考虑其他，直接往内存插入新值即可</p><p>这里举个例子，你和两个朋友去看电影，一般来说，你们三个如果关系太好了，好基友那种，分不开了，你们一般会买三张连续座位的票，从而可以坐在一起看，这便是数组，而当没有三张连续的电影票时，你们只能分开看，但可以根据电影票上的座位位置去找你的小伙伴，这便是链表。这里的座位编号便是内存地址，而你们就是一个又一个的数据。</p><p>在删除方面：链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p><strong>数组</strong>（Array）是有序的元素序列。 [1] 若将有限个类型相同的变量的<a href="https://baike.baidu.com/item/集合/2908117" target="_blank" rel="noopener">集合</a>命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为<a href="https://baike.baidu.com/item/下标变量/12713827" target="_blank" rel="noopener">下标变量</a>。用于区分数组的各个元素的数字编号称为下标。数组是在<a href="https://baike.baidu.com/item/程序设计/223952" target="_blank" rel="noopener">程序设计</a>中，为了处理方便， 把具有相同类型的若干元素按<strong>有序</strong>的形式组织起来的一种形式。  这些有序排列的同类数据元素的集合称为数组</p></blockquote><p>数组的优势：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素</p><h3 id="两者总结"><a href="#两者总结" class="headerlink" title="两者总结"></a>两者总结</h3><ul><li>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起</li><li>数组的元素都在一起</li><li>数组的读取速度比链表快</li><li>链表的插入和删除速度比数组快</li><li>在同一个数组中，所有元素的类型都必须相同</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418" target="_blank" rel="noopener">选择排序（Selection sort）</a>是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><p>有没有思考过对一组数进行排序时的过程是怎样的</p><p>比如要对【1，3，9，5，2】数组进行排序</p><ol><li>我们首先在原数组内进行比较，找出最大值，结果是9，所以我们把他放到新建数组第一个位置【9】</li><li>接着在剩下的数组遍历找出最大的值，是5，放到新数组第二个位置【9，5】</li><li>继续对剩下的三个数字进行同样操作【1，3，2】，得出最终结果【9，5，3，2，1】</li></ol><p>这便是选择排序的过程，一共需要几步呢上面，每次都对原数组进行比较排序，需要进行5趟比较，每趟比较又是和另外几个数的比较，也是5次，所以最终的所需的步数是25，也就是n²</p><blockquote><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n² )呢</p><p>确实，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n – 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但<strong>大O表示法省略诸如1/2这样的常数</strong></p></blockquote><h2 id="选择排序实例代码"><a href="#选择排序实例代码" class="headerlink" title="选择排序实例代码"></a>选择排序实例代码</h2><ol><li><p>数组内比较使用一个函数max进行最大值获取，对数组内每个值进行遍历，找出最大值的索引，具体思路如下</p><blockquote><p>使用变量存储最大值以及最大值索引，给其赋初始值，即为数组第一个数据，接着对数组内数据进行遍历，若遍历到的数据比当前数值大，即将当前变量赋值为它，不断执行该操作，直到遍历完返回该数值索引</p></blockquote></li><li><p>对数组进行排序sort的主函数，使用新数组进行存储排序后的值，接着对原数组进行遍历和最大值查找，找出一个便在原数组删除该数据，避免引起无限循环导致内存泄漏，重复执行，直到最终结果出来</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      arr[minIndex] &gt; arr[j] &amp;&amp; (minIndex = j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一种简单直观的排序算法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-01T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:54.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</p><h2 id="简单查找"><a href="#简单查找" class="headerlink" title="简单查找"></a>简单查找</h2><p>我们在日常生活中经常会玩一个游戏：找数字</p><p>提问者给出该数字的范围，然后回答者根据这个范围进行猜数，如果比正确答案大，提问者便会说大了，如若小了，则提问者回答小了，直至猜出正确答案</p><p>比如：提问者随便想出一个数字-57，范围是0-100，回答者开始猜，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829090857846.png" alt="算法图解-简单查找"></p><p>等到他猜到57，便成功猜到正确答案了，这便是简单查找，回答者一个一个说，直到正确答案出来</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>更简单的查找方式，根据方法名即可猜到，将猜测范围一分为二，比如0-100，那么你猜50，无论是大了还是小了，你立即就可以排除掉一半的数字，接着重复一分为二的操作进行猜数，最后得出正确答案</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091346823.png" alt="image-20210829091346823"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091357416.png" alt="image-20210829091357416"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091407604.png" alt="image-20210829091407604"></p><p>梳理下这个猜数的过程，我们一共进行了几步</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091706567.png" alt="image-20210829091706567"></p><p>回过头去，如果你采用暴力式简单查找，那么你猜的数字便是n（答案n）步，如果目标数字小，还好，如果是99呢，你就得猜到99才能猜到</p><p>引用书籍的另一个例子——</p><blockquote><p>假设你要在字典中查找一个单词，而该字典包含240 000个单词， 你认为每种查找最多需要多少步？ 如果要查找的单词位于字典末尾，使用简单查找将需要240 000步。使用二分查找时，每次排除一半单词，直到最后只剩下一个单词。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829092007999.png" alt="image-20210829092007999"></p><p>可见，随着要猜的范围越来越大，二分查找的优势也越加凸显，而二分查找所需的步数也符合对数的规律</p><blockquote><p>二分查找最多需要log2n步</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单查找-1"><a href="#简单查找-1" class="headerlink" title="简单查找"></a>简单查找</h3><p>我们首先看简单查找的代码实现（这里包括后面只会给出图片格式的代码，因为更多的希望通过实操去理解每个算法的过程）</p><p>直接通过遍历，一个一个判断，最后返回结果</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%AE%80%E5%8D%95%E6%9F%A5%E6%89%BE.png" alt></p><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>看看二分查找的实现代码（因为是根据自己的理解所写，所以多多少少可能会有不合理的地方，望指出）</p><ol><li>首先是写一个回答函数，相当于提问者的回答，传入参数包括回答者的数字和正确的数字</li><li>接着便是使用二分法进行猜数，每次猜中间数，对了返回，不对就根据情况进行数组裁剪，裁剪完继续重复该函数（递归思想）</li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png" alt="二分查找"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>O(log n)比O(n)快（也就是二分法比简单查找快），当需要搜索的元素越多时，前者比后者快得越多</p></blockquote>]]></content>
    
    <summary type="html">
    
      二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/"/>
    <id>http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/</id>
    <published>2021-07-22T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>作用：递归只是让解决方案更清晰，并没有性能上的优势，如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解(但在我看来，递归有时候也很难理解)</p></blockquote><p><a href="https://ypigy.gitee.io/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/" target="_blank" rel="noopener">斐波那契数列</a>就是运用递归的想法进行计算</p><h2 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h2><blockquote><p>每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件</span></span><br><span class="line"><span class="keyword">if</span> (newArr.length === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> newArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归条件</span></span><br><span class="line"><span class="keyword">return</span> newArr.pop() + sum(newArr);</span><br></pre></td></tr></table></figure><p>上面为利用递归进行累加的函数</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>栈只有两种操作：压入 （插入）和弹出（删除并读取）</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829162227622.png" alt="image-20210829162227622"></p><p>数组的压入与弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.pop() <span class="comment">//弹出</span></span><br><span class="line">array.push() <span class="comment">//压入</span></span><br></pre></td></tr></table></figure><p>计算机在内部使用被称为调用栈的栈</p><h3 id="函数与调用栈"><a href="#函数与调用栈" class="headerlink" title="函数与调用栈"></a>函数与调用栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  hi();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bye'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bye();</span><br></pre></td></tr></table></figure><p>下面分析调用bye()发生的事</p><p>首先会为bye分配内存控件，以及该函数所创建的变量也会放到内存</p><p>接着里面会调用另一个函数，所以会在bye上面压入另一个函数hi()，开辟新的内存，同时为其变量分配内存，最后如下图，就像压入一样的操作，根据调用顺序压入内存</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829163034381.png" alt="image-20210829163034381"></p><p>接着就是函数执行，从上到下执行，先弹出最顶部的函数（对应嵌套最深的函数）进行执行，接着一步一步往下执行，最后到最底部的函数（就是最外层函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">hi</span><br><span class="line">bye</span><br></pre></td></tr></table></figure><h2 id="实操-阶乘"><a href="#实操-阶乘" class="headerlink" title="实操-阶乘"></a>实操-阶乘</h2><p>简单阶乘的实现使用了递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fact = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * fact(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析其调用栈如何变化</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164134539.png" alt="image-20210829164134539"></p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164213432.png" alt="image-20210829164213432"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>递归指的是调用自己的函数。 </li><li>每个递归函数都有两个条件：基线条件和递归条件。</li><li>栈有两种操作：压入和弹出。</li><li>所有函数调用都进入调用栈。</li><li>调用栈可能很长，这将占用大量的内存。</li></ul>]]></content>
    
    <summary type="html">
    
      从前有座山，山里有座庙，庙里有个老和尚。。。
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大O表示法</title>
    <link href="http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2021-07-20T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:36.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><blockquote><p>大O表示法指出了算法有多块</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095256434.png" alt="image-20210829095256434"></p><ol><li>大 O 表示法指出了最糟情况下的运行时间（算法执行步数）<ul><li>除最糟情况下的运行时间外，还应考虑平均情况的运行时间</li></ul></li></ol><h2 id="一些常见的大-O-运行时间"><a href="#一些常见的大-O-运行时间" class="headerlink" title="一些常见的大 O 运行时间"></a>一些常见的大 O 运行时间</h2><ol><li>O(log n)，也叫对数时间，这样的算法包括二分查找。 </li><li>O(n)，也叫线性时间，这样的算法包括简单查找。</li><li>O(n * log n)，一种速度较快的排序算法。</li><li>O(n2 )，一种速度较慢的排序算法。</li><li>O(n!)，包括旅行商问题等——一种非常慢的算法。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095521599.png" alt="image-20210829095521599"></p><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><blockquote><p>算法的速度指的并非时间，而是操作数的增速。</p><p>谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 </p><p>算法的运行时间用大O表示法表示。</p><p>大O表示法省略诸如1/2这样的常数</p></blockquote>]]></content>
    
    <summary type="html">
    
      大O表示法指出了算法有多块
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-数据链路层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:30:46.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先看看不同定义下的计算机网络体系结构</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412184905304.png" alt="image-20210412184905304"></p><p>在OSI和五层协议里面，数据链路层都在其中扮演着重要的角色，在TCP/IP的体系结构里，数据链路层及以下则被抽象掉了</p><p>数据链路层是实现设备之间通信的非常重要的一层，不管经过的是什么网络，电话网、局域网、广域网等，需要注意的是：在里面，<strong>路由器在转发分组时只用到下三层协议</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185205003.png" alt="image-20210412185205003"></p><p>再来看看处于交换机下的数据链路层</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185623966.png" alt="image-20210412185623966"></p><p>若主机H1向H2发送数据，则实际上数据的流动是通过五层从左向右，从上向下传递过去的，但若只从数据链路层来看的话，数据是从H1→R1→R2→R2→R3→H2的链路层传过去的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185733062.png" alt="image-20210412185733062"></p><p>数据链路层使用的信道主要有以下两种类型</p><p>(a) <strong>点对点信道</strong>：这种信道使用一对一的点对点通信方式。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412190326192.png" alt="image-20210412190326192"></p><p>(b) <strong>广播信道</strong>：使用一对多的广播通信方式。必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412190337871.png" alt="image-20210412190337871"></p><h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><h2 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h2><h3 id="链路和数据链路的区别"><a href="#链路和数据链路的区别" class="headerlink" title="链路和数据链路的区别"></a>链路和数据链路的区别</h3><p><strong>链路 (link)</strong> 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>简单来说：一条链路只是一条通路的一个组成部分。</p><p><strong>数据链路 (data link)</strong> 除了物理线路外，还必须有<strong>通信协议</strong>来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 </p><p>也有人采用另外的术语。这就是把链路分为<strong>物理链路</strong>和<strong>逻辑链路</strong>。<br>物理链路就是上面所说的链路。逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。</p><p>早期的数据通信协议曾叫做<strong>通信规程 (procedure)</strong>。因此在数据链路层，<strong>规程和协议是同义语</strong>。</p><h3 id="数据链路层传送的是帧"><a href="#数据链路层传送的是帧" class="headerlink" title="数据链路层传送的是帧"></a>数据链路层传送的是帧</h3><p>数据链路层通过将网络层传下来的ip数据包进行<strong>封装成帧</strong>然后再传给物理层，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412191405152.png" alt="image-20210412191405152"></p><p>通常，我们会在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412191726824.png" alt="image-20210412191726824"></p><p>数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。在之后的学习也是一样，随着往上层的学习，有时候为了屏蔽掉下层带给自己的干扰，我们大多时候会直接考虑数据是在对等层之间进行传递（实际上并不是）</p><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：</p><ol><li><strong>封装成帧</strong></li><li><strong>透明传输</strong></li><li><strong>差错控制</strong> </li></ol><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p><p>首部和尾部的一个重要作用就是进行帧定界。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194144658.png" alt="image-20210412194144658"></p><p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。</p><p>控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194215116.png" alt="image-20210412194215116"></p><p>如果<strong>数据中</strong>的某个字节的<strong>二进制代码</strong>恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194504407.png" alt="image-20210412194504407"></p><p>为啥会出现这种情况呢，因为数据链路层在传递数据的时候是“透明”的，即透明传输</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p>透明：指某一个实际存在的事物看起来却好像不存在一样。（想象一个完全透明的玻璃在你面前）</p></blockquote><p>“在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。这便是透明传输，也就是说，对面的数据链路层也会去解析你的整个帧，一不小心解析到了本存在于数据而不是帧定界的EOT时，就会误认终止而抛弃掉后面的帧</p><p>解决方法：<strong>字节填充 (byte stuffing)</strong> 或<strong>字符填充 (character stuffing)</strong>。</p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195139392.png" alt="image-20210412195139392"></p><h2 id="差错检错"><a href="#差错检错" class="headerlink" title="差错检错"></a>差错检错</h2><p>在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195225962.png" alt="image-20210412195225962"></p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER (Bit Error Rate)。</strong></p><p>误码率与<strong>信噪比</strong>有很大的关系。</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种<strong>差错检测</strong>措施。 下面介绍一种检测措施——循环循环冗余检验码</p><h3 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h3><p>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验 CRC</strong> 的<strong>检错技术。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195833103.png" alt="image-20210412195833103"></p><p>在发送端，先把数据划分为组。假定每组 k 个比特。 </p><p>在每组 M 后面再添加供差错检测用的 n 位冗余码，然后一起发送出去。 </p><h3 id="冗余码的计算"><a href="#冗余码的计算" class="headerlink" title="冗余码的计算"></a>冗余码的计算</h3><p>用二进制的模 2 运算进行 2n 乘数据M 的运算，这相当于<strong>在 M 后面添加 n 个 0</strong>。</p><p>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 </p><p>将余数 R 作为冗余码拼接在数据 M 后面，一起发送出去。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412200326411.png" alt="image-20210412200326411"></p><p>接收端会对收到的每一帧进行 CRC 检验</p><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。</p><p>(2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。<br>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p><p>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 </p><h3 id="冗余码的计算举例"><a href="#冗余码的计算举例" class="headerlink" title="冗余码的计算举例"></a>冗余码的计算举例</h3><p>现在 k = 6, M = 101001。<br>设 n = 3, 除数 P = 1101，<br>被除数是 2的n次*M = 101001000。<br>模 2 运算的结果是：商 Q = 110101，余数 R = 001。<br>把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R，即：101001001，共 (k + n) 位。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412200553273.png" alt="image-20210412200553273"></p><h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p><p>循环冗余检验 CRC 和帧检验序列 FCS 并不等同。<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。<br><strong>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。</strong> </p><p>最后应当注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)。</p><p>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。</p><p>应当明确，<strong>“无比特差错”</strong>与<strong>“无传输差错”</strong>是不同的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。要做到“无差错传输”（即发送什么就收到什么）就必须再加上<strong>确认和重传机制。</strong> 本章介绍的数据链路层协议都<strong>不是可靠传输</strong>的协议。</p><h1 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h1><h2 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h2><p>对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p><p>PPP 协议在 1994 年就已成为互联网的正式标准。</p><p>用户到 ISP 的链路使用 PPP 协议 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412201655878.png" alt="用户到ISP的链路使用PPP协议 "></p><p><strong>PPP 协议应满足的需求</strong></p><ol><li><strong>简单 —— 这是首要的要求。</strong></li><li><strong>封装成帧</strong> —— 必须规定特殊的字符作为帧定界符。</li><li><strong>透明性</strong> —— 必须保证数据传输的透明性。</li><li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li><li>多种类型链路 —— 能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li><li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</li></ol><p><strong>PPP 协议有三个组成部分：</strong></p><ol><li>一个将 IP 数据报封装到串行链路的方法。</li><li><strong>链路控制协议 LCP</strong> (Link Control Protocol)。</li><li><strong>网络控制协议 NCP</strong> (Network Control Protocol)。 </li></ol><h2 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h2><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。</p><p>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。</p><p>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。<br>控制字段 C 通常置为 0x03。</p><p><strong>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202618347.png" alt="image-20210412202618347"></p><p>PPP 有一个 2 个字节的协议字段。其值<br>若为 0x0021，则信息字段就是 IP 数据报。<br>若为 0x8021，则信息字段是网络控制数据。<br>若为 0xC021，则信息字段是 PPP 链路控制数据。<br>若为 0xC023，则信息字段是鉴别数据。</p><p><strong>PPP在透明传输的相关问题</strong></p><p>当 PPP 用在异步传输时，就使用一种特殊的<strong>字符填充法</strong>。<br>当 PPP 用在同步传输链路时，协议规定采用硬件来完成<strong>比特填充</strong>（和 HDLC 的做法一样）。  </p><h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。 </p><p>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。</p><p>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202818142.png" alt="image-20210412202818142"></p><h3 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h3><p>PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p><p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。</p><p>接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202911660.png" alt="image-20210412202911660"></p><p> PPP是不提供使用序号和确认的可靠传输的，为什么呢，原因如下</p><ol><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。</li></ol><h2 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h2><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p><p>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p><p>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p><p>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203110510.png" alt="image-20210412203110510"></p><h1 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h1><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p>局域网最主要的特点是：网络为一个单位所拥有；地理范围和站点数目均有限。 </p><p>局域网具有如下主要优点：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203528660.png" alt="image-20210412203528660"></p><p>一开始因为技术原因，没办法制造出廉价的集线器，所以采用的是总线型的局域网，这样的类型有着如下特点：各个主机是在一同条信道上进行通信的，使用一对多的广播通信方式。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203948749.png" alt="image-20210412203948749"></p><p>但是它存在着问题：若多个设备在共享的广播信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p>共享信道要考虑的便是如何让众多用户能够合理方便的共享通信媒体资源，总的分为两种方法</p><ol><li><p>静态划分信道（物理层）</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用 </li></ul></li><li><p>动态媒体接入控制（多点接入）</p><ul><li>随机接入</li><li>受控接入 ，如多点线路探询 (polling)，或轮询。      </li></ul></li></ol><h3 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a><strong>以太网的两个标准</strong></h3><p> DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。<br>IEEE 802.3 是第一个 IEEE 的以太网标准。</p><p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。</p><p>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。</p><h3 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a><strong>数据链路层的两个子层</strong></h3><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层：</p><ol><li><p>逻辑链路控制 LLC (Logical Link Control)子层；</p></li><li><p>媒体接入控制 MAC (Medium Access Control)子层。</p></li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。不管采用何种协议的局域网，对 LLC 子层来说都是透明的（有点像TCP/IP协议）。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412204812504.png" alt="image-20210412204812504"></p><p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 </p><h3 id="适配器（网卡）"><a href="#适配器（网卡）" class="headerlink" title="适配器（网卡）"></a>适配器（网卡）</h3><blockquote><p>网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或“网卡”。 </p></blockquote><p>适配器的重要功能：</p><ol><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412204941268.png" alt="image-20210412204941268"></p><p>当适配器收到正确的帧时，它就会使用中断来通知计算机，并交付给协议栈中的网络层；这里值得注意的是：当收到的是有差错的帧时，适配器会直接丢掉该帧而不会去通知计算机。当计算机要发送ip数据包时，就由协议栈把IP数据包下交给适配器，组装成帧后发送到局域网。</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>最初的以太网是将许多计算机都连接到一根总线上。易于实现<strong>广播通信</strong>。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（当时普遍认为有源器件不可靠，无源的电缆线才是最可靠的）。</p><p> 为了实现一对一通信，将接收站的硬件地址写入帧首部中的目的地址字段中。仅当数据帧中的目的地址与适配器的硬件地址一致时，才能接收这个数据帧。比如下图中的B向D发送数据</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412205728382.png" alt="image-20210412205728382"></p><p>总线当然也有缺点。就像前面说的，若多台计算机或多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412205830005.png" alt="image-20210412205830005"></p><p>在讨论解决冲突或碰撞的方法前，先来看看以太网采取的两种重要的措施</p><p><strong>(1) 采用较为灵活的无连接的工作方式</strong></p><p>不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</p><p>以太网提供的服务是不可靠的交付，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p><p>而如果高层发现丢失了一些数据而进行重传，此时以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 </p><p><strong>(2) 以太网发送的数据都使用曼彻斯特 (Manchester) 编码</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412210100341.png" alt="image-20210412210100341"></p><p>曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p><p>下面就介绍碰撞或冲突的解决方法</p><h3 id="CSMA-CD-协议要点（多点接入、载波监听、碰撞检测）"><a href="#CSMA-CD-协议要点（多点接入、载波监听、碰撞检测）" class="headerlink" title="CSMA/CD 协议要点（多点接入、载波监听、碰撞检测）"></a>CSMA/CD 协议要点（多点接入、载波监听、碰撞检测）</h3><p><strong>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  (Carrier Sense Multiple Access with Collision Detection) 。</strong></p><p><strong>“多点接入”</strong>表示许多计算机以多点接入的方式连接在一根总线上。</p><p><strong>“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</strong> </p><p>总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p><p>实际上，不管在发送前还是发送中，每个站必须不停地检测信道，那么在发送中站是如何检测的呢？</p><p><strong>“碰撞检测”就是站在发送数据过程中对信道进行监听的操作</strong></p><p><strong>“碰撞检测”</strong>就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</p><p>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</p><p>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</p><p>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</p><p>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p><p>CSMA/CD协议工作流程如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412224725977.png" alt="image-20210412224725977"></p><p>为何要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响，比如你现在在开会，两个人都想发言，但你们都克制住了，因为有另一个人在发言，这时候你们采用的便是<strong>载波监听</strong>，等到他讲完了，你们两<strong>载波监听</strong>没有监听到有人在说话准备想讲时，你讲了出来，结果巧了，他也同时讲了出来，两句话便在传播上起了冲突，看似同个时间讲的，其实可能是你早了那么几毫秒讲，但同时他的<strong>载波监听</strong>刚返回确认没有声音传出，他也开讲。而在这时候，如果你们不在讲的时候采取<strong>碰撞检测</strong>，一方停止讲话，那么你们两个人的声音就会彼此“吵架”</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412224847718.png" alt="image-20210412224847718"></p><p>最先发送数据帧的站，在发送数据帧后至多经过时间 2r （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</p><p>以太网的端到端往返时延 2r  称为争用期，或碰撞窗口。</p><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><h3 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h3><blockquote><p>以太网使用截断二进制指数退避算法来确定碰撞后重传的时机</p></blockquote><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ol><li><p><strong>基本退避时间取为争用期 2я。</strong></p></li><li><p>从整数集合 [0, 1, … , (2k - 1)] 中随机地取出一个数，记为 r。重传所需的时延就是 <strong>r 倍</strong>的基本退避时间。</p></li><li><p>参数 k 按下面的公式计算：</p><blockquote><p>k = Min[重传次数, 10]</p></blockquote></li><li><p>当 k ≤10 时，参数 k 等于重传次数。</p></li><li><p>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 </p></li></ol><p>举个栗子<br>第 1 次冲突重传时：<br>    k = 1，r 为 {0，1} 集合中的任何一个数。<br>第 2 次冲突重传时：<br>    k = 2，r 为 {0，1，2，3} 集合中的任何一个数。<br>第 3 次冲突重传时：<br>    k = 3，r 为 {0，1，2，3，4，5，6，7} 集合中的任何一个数。</p><h3 id="10-Mbit-s-以太网争用期的长度"><a href="#10-Mbit-s-以太网争用期的长度" class="headerlink" title="10 Mbit/s 以太网争用期的长度"></a><strong>10 Mbit/s 以太网争用期的长度</strong></h3><p>10 Mbit/s 以太网取 51.2μs 为争用期的长度。<br>对于 10 Mbit/s 以太网，以太网规定了最短有效帧长为 64 字节，在争用期内可发送 512 bit（即 64 字节）。所以凡长度小于 64 字节的帧都是由于冲突而异常中止的<strong>无效帧</strong>。</p><blockquote><p>这意味着：<br>以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</p></blockquote><p>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 </p><h4 id="覆盖范围"><a href="#覆盖范围" class="headerlink" title="覆盖范围"></a>覆盖范围</h4><p>在 10 Mbit/s 以太网 51.2 μs 的争用期内，信号能传输多远的距离？</p><p>以太网上最大的端到端单程时延必须小于争用期的一半（即 25.6 μs），这相当于以太网的最大端到端长度约为 5 km。</p><h3 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h3><blockquote><p>当发送数据的站一旦发现发生碰撞时，除了立即停止发送数据外，还要继续发送32比特或48比特的人为干扰信号，以让所有用户都知道已经发生了碰撞</p></blockquote><p>注意：B 也能够检测到冲突，并立即停止发送数据帧，接着就发送干扰信号。<br>这里为了简单起见，只画出 A 发送干扰信号的情况。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413150301732.png" alt="image-20210413150301732"></p><h3 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h3><ol><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行<strong>双向交替通信（半双工通信）</strong>。</li><li>每个站在发送数据之后的一小段时间内，存在着<strong>遭遇碰撞</strong>的可能性。 </li><li>这种发送的不确定性使整个以太网的平均通信量<strong>远小于</strong>以太网的最高数据率。 </li></ol><p>下面是该协议整个过程的流程图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413150725543.png" alt="image-20210413150725543"></p><h2 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h2><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p><p>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，<strong>叫做集线器 (hub)</strong>。</p><p>传统的总线拓扑结构（前面详细讲过了）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413152754451.png" alt="image-20210413152754451"></p><p>使用集线器的双绞线以太网，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413152825307.png" alt="image-20210413152825307"></p><h3 id="星形以太网-10BASE-T"><a href="#星形以太网-10BASE-T" class="headerlink" title="星形以太网 10BASE-T"></a>星形以太网 10BASE-T</h3><p><strong>10BASE-T特点如下</strong></p><ol><li>使用无屏蔽双绞线，采用星形拓扑。</li><li>每个站需要用两对双绞线，分别用于发送和接收。</li><li>双绞线的两端使用 RJ-45 插头。</li><li>集线器使用了大规模集成电路芯片，因此集线器的可靠性提高。 </li><li>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100m。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413153048104.png" alt="image-20210413153048104"></p><p>这种 10 Mbit/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 具有很高的性价比。</p><p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。从此以太网的拓扑就从总线形变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。 </p><h3 id="集线器特点"><a href="#集线器特点" class="headerlink" title="集线器特点"></a>集线器特点</h3><ol><li>集线器是<strong>使用电子器件来模拟实际电缆线</strong>的工作，因此整个系统仍然像一个传统的以太网那样运行。 </li><li>使用集线器的以太网<strong>在逻辑上仍是一个总线网</strong>，各工作站使用的还是 <strong>CSMA/CD 协议，并共享逻辑上的总线</strong>。 </li><li>集线器很像一个<strong>多接口</strong>的转发器，工作在物理层。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li></ol><p>结构图如下</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413153248800.png" alt="image-20210413153248800"></p><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><p>多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%。</p><p>假设я（该符号暂时找不到，所以统一用这个代替一下） 是以太网单程端到端传播时延。则争用期长度为 2я ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。</p><p>设帧长为 L (bit)，数据发送速率为 C (bit/s)，则帧的发送时间为  T0 = L/C (s)。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413155601307.png" alt="image-20210413155601307"></p><p>一个站在发送帧时出现了碰撞。经过一个争用期 2я 后，可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 T0。</p><p>通过图我们注意到，成功发送一个帧需要占用信道的时间是 T0 + я，比这个帧的发送时间要多一个单程端到端时延я。<strong>这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播</strong>。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是я 。</p><p>因此，必须经过时间T0 + я后以太网的媒体才处于完全空闲状态</p><p>我们在以太网中定义了参数 a ，它是以太网单程端到端时延я与帧的发送时间 T0 之比： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413155822743.png" alt="image-20210413155822743"></p><p>通过公式我们可以知道：要提高以太网的信道利用率，就必须减小я与 T0 之比。</p><p>a → 0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 </p><p>为提高利用率，以太网的参数 a 的值应当尽可能小些。<br>对以太网参数 a 的要求是：当数据率一定时，以太网的连线的长度受到限制，否则я的数值会太大。以太网的帧长不能太短，否则 T0 的值会太小，使 a 值太大。 </p><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是 T0 + я ，而帧本身的发送时间是 T0。于是，我们可计算出理想情况下的极限信道利用率 Smax 为： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413160220692.png" alt="image-20210413160220692"></p><p>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。<br>据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><h3 id="MAC-层的硬件地址"><a href="#MAC-层的硬件地址" class="headerlink" title="MAC 层的硬件地址"></a>MAC 层的硬件地址</h3><blockquote><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 </p></blockquote><p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。</p><p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或路由器就有多个“地址”。更准确些说，这种 48 位“地址”应当是某个接口的标识符。</p><p>IEEE 802 标准规定 MAC 地址字段可采用 6 字节 ( 48位) 或 2 字节 ( 16 位) 这两种中的一种。<br>IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。<br>地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161124465.png" alt="image-20210413161124465"></p><p>所以，一个地址块可以生成 224 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。<br>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址 (hardware address) 或物理地址。<br>“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</p><h4 id="单站地址，组地址，广播地址"><a href="#单站地址，组地址，广播地址" class="headerlink" title="单站地址，组地址，广播地址"></a>单站地址，组地址，广播地址</h4><p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。</p><p>当 I/G 位 = 0 时，地址字段表示一个<strong>单站地址</strong>。</p><p>当 I/G 位 = 1 时，表示<strong>组地址</strong>，用来进行多播（以前曾译为组播）。此时，IEEE 只分配地址字段前三个字节中的 23 位。</p><p>当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 223 个单个站地址和 223 个组地址。</p><p>所有 48 位都为 1 时，为<strong>广播地址</strong>。只能作为目的地址使用。</p><h4 id="全球管理与本地管理"><a href="#全球管理与本地管理" class="headerlink" title="全球管理与本地管理"></a>全球管理与本地管理</h4><p>IEEE 把地址字段第一字节的最低第 2 位规定为 G/L 位，表示 Global / Local。</p><p>当 G/L 位 = 0 时，是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于全球管理。</p><p>当 G/L 位 = 1 时， 是本地管理，这时用户可任意分配网络上的地址。</p><h4 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h4><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是发往本站的帧则收下，然后再进行其他的处理。<br>否则就将此帧丢弃，不再进行其他的处理。</p><blockquote><p>“发往本站的帧”包括以下三种帧： </p><ol><li>单播 (unicast) 帧（一对一）</li><li>广播 (broadcast) 帧（一对全体）</li><li>多播 (multicast) 帧（一对多）</li></ol></blockquote><p>所有的适配器都至少能够识别前两种帧，即<strong>能够识别单播地址和广播地址。有的适配器可用编程方法识别多播地址。</strong></p><p><strong>只有目的地址才能使用广播地址和多播地址。</strong></p><p>以<strong>混杂方式 (promiscuous mode)</strong> 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。</p><h3 id="MAC-帧的格式"><a href="#MAC-帧的格式" class="headerlink" title="MAC 帧的格式"></a>MAC 帧的格式</h3><p>常用的以太网 MAC 帧格式有两种标准：<br><strong>DIX Ethernet V2 标准</strong><br><strong>IEEE 的 802.3 标准</strong></p><h4 id="以太网V2标准下的MAC帧"><a href="#以太网V2标准下的MAC帧" class="headerlink" title="以太网V2标准下的MAC帧"></a>以太网V2标准下的MAC帧</h4><p>最常用的 MAC 帧是以太网 V2 的格式。下面就来讲解以太网V2标准下的MAC帧</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161523396.png" alt="image-20210413161523396"></p><p>其中，目的地址和源地址都是6字节，类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。 </p><p>数据字段的正式名称是 MAC 客户数据字段。<br>最小长度 64 字节 - 18 字节的首部和尾部 = 数据字段的最小长度（46字节） </p><p>当传输媒体的误码率为 1x10-8 时，MAC 子层可使未检测到的差错小于 1x10-14 。 </p><p><strong>注意：当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。</strong> </p><p>在帧的前面插入（硬件生成）的 8 字节中，第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段 1 个字节是帧开始定界符，表示后面的信息就是 MAC 帧。 </p><p>最后，<strong>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</strong></p><h4 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h4><p>无效的MAC帧主要有以下特点</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li></ul><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</p><p>怎么解决这些无效的帧，对的，丢掉，前面有提到过</p><blockquote><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p></blockquote><h4 id="IEEE-802-3-MAC-帧"><a href="#IEEE-802-3-MAC-帧" class="headerlink" title="IEEE 802.3 MAC 帧"></a>IEEE 802.3 MAC 帧</h4><p>下面再来讲讲IEEE 802.3 MAC 帧格式</p><p>与以太网 V2 MAC 帧格式相似，区别在于：</p><ol><li>IEEE 802.3 规定的 MAC 帧的第三个字段是<strong>“长度 / 类型”</strong>。<ol><li>当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。</li><li>当这个字段值小于 0x0600 时才表示“长度”。</li></ol></li><li>当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</li></ol><p>让我们再搬出V2 MAC帧的图进行对比</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161523396.png" alt="image-20210413161523396"></p><blockquote><p>现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p></blockquote><p>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。</p><blockquote><p><strong>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</strong> </p></blockquote><h1 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h1><h2 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h2><p>有两种方式可以对以太网进行扩展</p><ul><li><p>使用光纤扩展<br>主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。 很容易使主机和几公里以外的集线器相连接。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413163939949.png" alt="image-20210413163939949"></p></li><li><p>使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413164058671.png" alt="image-20210413164058671"></p></li></ul><p>使用集线器扩展以太网的优缺点有啥</p><p><strong>优点</strong></p><ol><li><p>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</p></li><li><p>扩大了以太网覆盖的地理范围。</p></li></ol><p><strong>缺点</strong></p><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 </li></ol><p>这里的碰撞域是什么意思</p><blockquote><p>碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。碰撞域越大，发生碰撞的概率越高。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165236969.png" alt="image-20210413165236969"></p><p>这样，即使你使用了多个集线器，但其实它们还是属于同个碰撞域，也就是说，在每个碰撞域里只能由一个站再发送数据，这样吞吐量和一个集线器形成的碰撞域是一样的。</p><p>接下来再来讲讲一种更高效的方法——<strong>交换机</strong></p><h2 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h2><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165441193.png" alt="image-20210413165441193"></p><p>网桥工作在数据链路层。它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。<br>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </p><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong>。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。以太网交换机具有<strong>并行性</strong>。能同时连通多对接口，使多对主机能同时通信。</p><p>相互通信的主机都是独占传输媒体，都能进行无碰撞地传输数据。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165626642.png" alt="image-20210413165626642"></p><p>这样，以太网交换机的每个接口是一个碰撞域，吞吐量相比较单纯集线器大大提高</p><h3 id="以太网交换机特点、优点"><a href="#以太网交换机特点、优点" class="headerlink" title="以太网交换机特点、优点"></a>以太网交换机特点、优点</h3><p><strong>以太网交换机具有怎样的特点呢</strong></p><ul><li>以太网交换机的接口有<strong>存储器</strong>，能在输出端口繁忙时把到来的帧进行<strong>缓存</strong>。</li><li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的<strong>帧交换表</strong>（又称为地址表）是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li><li>以太网交换机使用了专用的<strong>交换结构</strong>芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li><li>以太网交换机的<strong>性能</strong>远远超过普通的集线器，而且价格并不贵。</li></ul><p>通过上面的介绍，让我们来看看以太网交换机具有怎样的优点</p><ol><li><p>用户独享带宽，增加了总容量。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170307329.png" alt="image-20210413170307329"></p></li><li><p>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。</p></li><li><p>以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。</p></li></ol><h3 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h3><ol><li><p><strong>存储转发方式</strong><br>把整个数据帧<strong>先缓存后再进行处理</strong>。</p></li><li><p><strong>直通 (cut-through) 方法</strong><br>接收数据帧的同时就立即按<strong>数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</p><p><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些<strong>无效帧</strong>转发给其他的站。</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170618836.png" alt="image-20210413170618836"></p><p>在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。</p><h3 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h3><p>多图预警，通过多个图来描述以太网交换机自学习过程</p><p>开始时，交换表是空的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170859854.png" alt="image-20210413170859854"></p><p>然后A 先向 B 发送一帧。该帧从接口 1 进入到交换机。</p><p>交换机收到帧后，先查找交换表。没有查到应从哪个接口转发这个帧给 B。</p><p>交换机把这个帧的源地址 A 和接口 1 <strong>写入交换表</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170932553.png" alt="image-20210413170932553"></p><p>交换机向除接口 1 以外的所有的接口广播这个帧。</p><p>由于与该帧的目的地址不相符，C 和 D 将丢弃该帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171303606.png" alt="image-20210413171303606"></p><p>B 向 A 发送一帧。该帧从接口 3 进入到交换机。</p><p>交换机收到帧后，先查找交换表。发现交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p><p>交换机把这个帧的源地址 B 和接口 3 写入交换表中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171342002.png" alt="image-20210413171342002"></p><p>最后，考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目<strong>都设有一定的有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><blockquote><p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p></blockquote><p>最后，通过一张图来归纳交换机自学习和转发帧的步骤归纳</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171701153.png" alt="image-20210413171701153"></p><h3 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h3><p>来啦，小测验</p><p>假设：A 向 B 发送了一帧，C 向 E 发送了一帧，E 向 A 发送了一帧。<br>请分析：此时，S1 和 S2 的交换表内容分别是什么？</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413172314284.png" alt="image-20210413172314284"></p><p>答案如下</p><p>S1表</p><table><thead><tr><th align="center">MAC地址</th><th align="center">接口</th><th align="center">有效时间</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">B</td><td align="center">3</td><td align="center"></td></tr><tr><td align="center">E</td><td align="center">5</td><td align="center"></td></tr></tbody></table><p>s2表</p><table><thead><tr><th align="center">MAC地址</th><th align="center">接口</th><th align="center">有效时间</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">5</td><td align="center"></td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center"></td></tr><tr><td align="center">E</td><td align="center">1</td><td align="center"></td></tr></tbody></table><h3 id="回路"><a href="#回路" class="headerlink" title="回路"></a>回路</h3><p>现在来看看交换机存在的一个问题</p><p>假定开始时，交换机 S1 和 S2 的交换表都是空的。<br>主机 A 向主机 E 发送一帧。交换机在没有交换表的情况下会对其进行广播，让我们看看其中一个数据的流动线路情况，从交换机S1接口5出发，到另一个交换机S2，再次广播，其中一条路跑到接口6，然后又跑回交换机S1，再进行广播，其中一条跑到接口5，如此循环下去，便形成了回路</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%9E%E8%B7%AF.gif" alt="交换机回路"></p><p>怎么解决：<strong>生成树协议 STP</strong></p><p>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP  (Spanning Tree Protocol)</strong>。<br>其要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173446655.png" alt="image-20210413173446655"></p><h2 id="从总线以太网到星形以太网"><a href="#从总线以太网到星形以太网" class="headerlink" title="从总线以太网到星形以太网"></a>从总线以太网到星形以太网</h2><p>现在对以太网的发展历程进行总结</p><p>早期，以太网采用无源的总线结构。现在，采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA/CD 协议，以全双工方式工作。但仍然采用以太网的帧结构。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165441193.png" alt="image-20210413165441193"></p><p> CSMA/CD 协议下的局域网存在的以下几个方面的问题：</p><ol><li>扩展性</li><li>安全性</li><li>可管理性 等</li></ol><p>所有计算机都处于同一个<strong>碰撞域（或冲突域）</strong>中和同一个<strong>广播域</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173722363.png" alt="image-20210413173722363"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173806387.png" alt="image-20210413173806387"></p><blockquote><p><strong>广播域（broadcast domain）</strong>：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p></blockquote><p>若采用以太网交换机的星形以太网</p><p>每个接口都处于一个独立的<strong>碰撞域（或冲突域）</strong>中，但所有计算机都处于同一个<strong>广播域</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174031621.png" alt="image-20210413174031621"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173947505.png" alt="image-20210413173947505"></p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</p><p>IEEE 802.1Q 对虚拟局域网 VLAN 的定义：</p><blockquote><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p></blockquote><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></p><p>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174232906.png" alt="image-20210413174232906"></p><p>这张图中，每个虚拟局域网是一个广播域。VLAN1, VLAN2 和 VLAN3 是三个不同的广播域。</p><p>当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到其广播的信息。而VLAN1 和 VLAN3 中的工作站 A1，A2 和 C1 等都不会收到 B1 发出的广播信息。 </p><p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即“<strong>广播风暴</strong>”) 而引起性能恶化。 </p><h3 id="VLAN优点"><a href="#VLAN优点" class="headerlink" title="VLAN优点"></a>VLAN优点</h3><p><strong>虚拟局域网（VLAN）技术具有以下主要优点：</strong></p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h3 id="划分虚拟局域网的方法"><a href="#划分虚拟局域网的方法" class="headerlink" title="划分虚拟局域网的方法"></a>划分虚拟局域网的方法</h3><ul><li>基于交换机端口</li><li>基于计算机网卡的MAC地址</li><li>基于协议类型</li><li>基于IP子网地址</li><li>基于高层应用或服务</li></ul><h4 id="基于交换机端口"><a href="#基于交换机端口" class="headerlink" title="基于交换机端口"></a>基于交换机端口</h4><p>先讲讲基于交换机端口的方法：</p><p>最简单、也是最常用的方法。<br>属于在第一层划分虚拟局域网的方法。<br>缺点：不允许用户移动。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174534860.png" alt="image-20210413174534860"></p><h4 id="基于计算机网卡的MAC地址的方法"><a href="#基于计算机网卡的MAC地址的方法" class="headerlink" title="基于计算机网卡的MAC地址的方法"></a>基于计算机网卡的MAC地址的方法</h4><p>根据用户计算机的MAC地址划分虚拟局域网。属于在第二层划分虚拟局域网的方法。允许用户移动。</p><p>缺点：需要输入和管理大量的MAC地址。如果用户的MAC地址改变了，则需要管理员重新配置VLAN。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174643551.png" alt="image-20210413174643551"></p><table><thead><tr><th>MAC  地址</th><th>VLAN</th></tr></thead><tbody><tr><td>00-15-F5-CC-C8-14</td><td>10</td></tr><tr><td>C0-AB-D5-00-18-F4</td><td>10</td></tr><tr><td>C0-C5-18-DE-BC-E6</td><td>30</td></tr></tbody></table><h4 id="基于协议类型的方法"><a href="#基于协议类型的方法" class="headerlink" title="基于协议类型的方法"></a>基于协议类型的方法</h4><p>根据<strong>以太网帧的第三个字段“类型”字段</strong>确定该类型的协议属于哪一个虚拟局域网。<br>属于在第二层划分虚拟局域网的方法。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175313847.png" alt="image-20210413175313847"></p><table><thead><tr><th>“类型”</th><th>VLAN</th></tr></thead><tbody><tr><td>IP</td><td>10</td></tr><tr><td>IPX</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h4 id="基于IP子网地址的方法"><a href="#基于IP子网地址的方法" class="headerlink" title="基于IP子网地址的方法"></a>基于IP子网地址的方法</h4><p>根据<strong>以太网帧的第三个字段“类型”字段</strong>和<strong>IP分组首部中的源 IP 地址字段</strong>确定该 IP 分组属于哪一个虚拟局域网。<br>属于在第三层（网络层）划分虚拟局域网的方法。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175434466.png" alt="image-20210413175434466"></p><table><thead><tr><th>IP  子网</th><th>VLAN</th></tr></thead><tbody><tr><td>192.168.1.0/24</td><td>10</td></tr><tr><td>192.168.2.0/24</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h4 id="基于高层应用或服务的方法"><a href="#基于高层应用或服务的方法" class="headerlink" title="基于高层应用或服务的方法"></a>基于高层应用或服务的方法</h4><p>根据高层应用或服务、或者它们的组合划分虚拟局域网。<br>更加灵活，但更加复杂。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175556212.png" alt="image-20210413175556212"></p><table><thead><tr><th>应用</th><th>VLAN</th></tr></thead><tbody><tr><td>FTP</td><td>10</td></tr><tr><td>TELNET</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h3 id="虚拟局域网使用的以太网帧格式"><a href="#虚拟局域网使用的以太网帧格式" class="headerlink" title="虚拟局域网使用的以太网帧格式"></a>虚拟局域网使用的以太网帧格式</h3><p>IEEE 批准了 802.3ac 标准，该标准定义了以太网的帧格式的扩展，以支持虚拟局域网。</p><p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记 (tag)，用来指明该帧属于哪一个虚拟局域网。插入VLAN标记得出的帧称为 802.1Q 帧或带标记的以太网帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175642834.png" alt="image-20210413175642834"></p><p>传送过程图示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175721413.png" alt="image-20210413175721413"></p><h1 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h1><h2 id="100BASE-T-以太网"><a href="#100BASE-T-以太网" class="headerlink" title="100BASE-T 以太网"></a>100BASE-T 以太网</h2><p><strong>速率达到或超过 100 Mbit/s 的以太网称为高速以太网。</strong></p><p>100BASE-T 在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802.3 的 CSMA/CD 协议。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。1995 年IEEE已把 100BASE-T 的快速以太网定为正式标准，其代号为 IEEE 802.3u。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>可在全双工方式下工作而无冲突发生。<strong>在全双工方式下工作时，不使用 CSMA/CD 协议</strong>。</li><li><strong>MAC 帧格式仍然是 802.3 标准规定的。</strong></li><li><strong>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 米。</strong></li><li>帧间时间间隔从原来的 9.6μs 改为现在的 0.96μs 。 </li></ul><h3 id="100-Mbit-s-以太网的三种不同的物理层标准"><a href="#100-Mbit-s-以太网的三种不同的物理层标准" class="headerlink" title="100 Mbit/s 以太网的三种不同的物理层标准"></a>100 Mbit/s 以太网的三种不同的物理层标准</h3><ul><li>100BASE-TX<ol><li>使用 2 对 UTP 5 类线 或 屏蔽双绞线 STP。</li><li>网段最大程度：100 米。</li></ol></li><li>100BASE-T4<ol><li>使用 4 对 UTP 3 类线 或 5 类线。 </li><li>网段最大程度：100 米。</li></ol></li><li>100BASE-FX <ol><li>使用 2 对光纤。 </li><li>网段最大程度：2000 米。</li></ol></li></ul><h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><p>允许在 1 Gbit/s 下以全双工和半双工两种方式工作。使用 IEEE 802.3 协议规定的帧格式。<strong>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</strong>与 10BASE-T 和 100BASE-T 技术向后兼容。</p><blockquote><p>吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中。</p></blockquote><p><strong>使用两种成熟的技术：</strong>一种来自现有的以太网，另一种则是美国国家标准协会 ANSI 制定的光纤通道 FC  (Fiber Channel)。</p><table><thead><tr><th>名称</th><th>媒体</th><th>网段最大长度</th><th>特点</th></tr></thead><tbody><tr><td>1000BASE-SX</td><td>光缆</td><td>550  m</td><td>多模光纤（50 和 62.5  mm）</td></tr><tr><td>1000BASE-LX</td><td>光缆</td><td>5000  m</td><td>单模光纤（10 mm）多模光纤（50 和 62.5  mm）</td></tr><tr><td>1000BASE-CX</td><td>铜缆</td><td>25  m</td><td>使用 2  对屏蔽双绞线电缆  STP</td></tr><tr><td>1000BASE-T</td><td>铜缆</td><td>100  m</td><td>使用 4  对  UTP 5 类线</td></tr></tbody></table><h3 id="半双工方式工作的吉比特以太网"><a href="#半双工方式工作的吉比特以太网" class="headerlink" title="半双工方式工作的吉比特以太网"></a>半双工方式工作的吉比特以太网</h3><p>吉比特以太网工作在半双工方式时，就必须进行碰撞检测。为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：</p><ol><li><strong>载波延伸 (carrier extension)</strong></li><li><strong>分组突发 (packet bursting)</strong></li></ol><h3 id="载波延伸"><a href="#载波延伸" class="headerlink" title="载波延伸"></a>载波延伸</h3><p>使最短帧长仍为 64 字节（这样可以保持兼容性），<strong>同时将争用时间增大为 512 字节</strong>。</p><p>凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到 512 字节。接收端在收到以太网的 MAC 帧后，要将所填充的特殊字符删除后才向高层交付。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413195200135.png" alt="image-20210413195200135"></p><h3 id="分组突发"><a href="#分组突发" class="headerlink" title="分组突发"></a>分组突发</h3><p>当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到 1500 字节或稍多一些为止。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413195224917.png" alt="image-20210413195224917"></p><h3 id="全双工方式工作的吉比特以太网"><a href="#全双工方式工作的吉比特以太网" class="headerlink" title="全双工方式工作的吉比特以太网"></a>全双工方式工作的吉比特以太网</h3><p>当吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），<strong>不使用载波延伸和分组突发。</strong></p><h2 id="10-吉比特以太网-10GE-和更快的以太网"><a href="#10-吉比特以太网-10GE-和更快的以太网" class="headerlink" title="10 吉比特以太网 (10GE) 和更快的以太网"></a>10 吉比特以太网 (10GE) 和更快的以太网</h2><p>10 吉比特以太网（10GE）并非把吉比特以太网的速率简单地提高到 10 倍，其主要特点有：</p><ol><li>与 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 以太网的帧格式完全相同。</li><li>保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。<br>不再使用铜线而只使用光纤作为传输媒体。</li><li><strong>只工作在全双工方式，因此没有争用问题，也不使用 CSMA/CD 协议。</strong> </li></ol><p><strong>10GE 的物理层标准</strong></p><table><thead><tr><th align="center">名称</th><th align="center">媒体</th><th align="center">网段最大长度</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">10GBASE-SR</td><td align="center">光缆</td><td align="center">300  m</td><td align="center">多模光纤（0.85 mm）</td></tr><tr><td align="center">10GBASE-LR</td><td align="center">光缆</td><td align="center">10  km</td><td align="center">单模光纤（1.3 mm）</td></tr><tr><td align="center">10GBASE-ER</td><td align="center">光缆</td><td align="center">40  km</td><td align="center">单模光纤（1.5 mm）</td></tr><tr><td align="center">10GBASE-CX4</td><td align="center">铜缆</td><td align="center">15  m</td><td align="center">使用 4  对双芯同轴电缆  (twinax)</td></tr><tr><td align="center">10GBASE-T</td><td align="center">铜缆</td><td align="center">100  m</td><td align="center">使用 4  对  6A 类 UTP  双绞线</td></tr></tbody></table><h2 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h2><p>以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了<strong>端到端的以太网传输</strong>。</p><p>这种工作方式的好处有： </p><ol><li>技术成熟；</li><li>互操作性很好；</li><li>在广域网中使用以太网时价格便宜；</li><li>采用统一的以太网帧格式，简化了操作和管理。 </li></ol><h2 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h2><p>IEEE 在 2001 年初成立了 802.3 EFM 工作组，专门研究高速以太网的宽带接入技术问题。</p><p>以太网宽带接入具有以下<strong>特点</strong>：</p><ol><li>可以提供<strong>双向</strong>的宽带通信。</li><li>可以根据用户对带宽的需求灵活地进行带宽升级。</li><li>可以实现端到端的以太网传输，中间<strong>不需要再进行帧格式的转换</strong>。这就提高了数据的传输效率且降低了传输的成本。</li><li><strong>但是不支持用户身份鉴别</strong>。</li></ol><h2 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h2><blockquote><p><strong>PPPoE (PPP over Ethernet)</strong> 的意思是<strong>“在以太网上运行 PPP</strong>”，它把 PPP 协议与以太网协议结合起来 —— 将 PPP 帧再封装到以太网中来传输。</p></blockquote><p>现在的光纤宽带接入 FTTx 都要使用 PPPoE 的方式进行接入。在 PPPoE 弹出的窗口中键入在网络运营商购买的用户名和密码，就可以进行宽带上网了。</p><p>利用 ADSL 进行宽带上网时，从用户个人电脑到家中的 ADSL 调制解调器之间，也是使用 RJ-45 和 5 类线（即以太网使用的网线）进行连接的，并且也是使用 PPPoE 弹出的窗口进行拨号连接的。</p>]]></content>
    
    <summary type="html">
    
      来呀客官，来看看数据链路层
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://dong-666.github.io/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://dong-666.github.io/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:31:14.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图</p></blockquote><p>主要讲了计算机网络五大层结构，后面有时间会补上<strong>网络安全</strong>、<strong>互联网上的音频/视频服务</strong>以及<strong>无线网络和移动网络</strong>，以下先讲讲计算机网络的概述，通过对计算机网络各个名词的学习和体系结构的初步认识，从而增加对后面学习的理解，之后会通过思维导图导入各层学习</p><h1 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h1><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>先放出一张图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102236857.png" alt="image-20210418102236857"></p><h2 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h2><blockquote><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)。</p></blockquote><p>端系统在功能上可能有很大的差别：</p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102356227.png" alt="image-20210418102356227"></p><p>然后，端之间通信（比如主机A和主机B进行通信）实际上是指：<strong>“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。</strong>这个相关内容可以通过运输层和应用层了解</p><p>端系统之间的通信方式通常可划分为两大类：</p><blockquote><p>客户-服务器方式（C/S方式）<br>即 Client/Server 方式，简称为 C/S 方式。 </p></blockquote><blockquote><p>对等方式（P2P方式）<br>即 Peer-to-Peer 方式 ，简称为 P2P 方式。</p></blockquote><h3 id="客户-服务器方式"><a href="#客户-服务器方式" class="headerlink" title="客户-服务器方式"></a>客户-服务器方式</h3><p><strong>客户</strong> (client) 和<strong>服务器</strong> (server) 都是指通信中所涉及的两个应用进程。</p><p>客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户是<strong>服务的请求方</strong>，服务器是<strong>服务的提供方</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102656794.png" alt="image-20210418102656794"></p><blockquote><p>客户软件：被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，<strong>客户程序必须知道服务器程序的地址</strong>。</p><p>不需要特殊的硬件和很复杂的操作系统。 </p></blockquote><blockquote><p>服务器软件：一种专门用来提供某种服务的程序，可<strong>同时处理多个远地或本地客户的请求</strong>。</p><p><strong>系统启动后即自动调用并一直不断地运行着</strong>，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</p><p>一般需要强大的硬件和高级的操作系统支持。</p></blockquote><p>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</p><p>相关详细内容可以通过运输层和应用层阅读到，当然前三层涉及到的知识也很重要</p><h3 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h3><p><strong>对等连接 (peer-to-peer，简写为 P2P )</strong> 是指两个主机<strong>在通信时并不区分哪一个是服务请求方还是服务提供方</strong>。</p><p>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</p><p>双方都可以下载对方已经存储在硬盘中的共享文档。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418103029567.png" alt="image-20210418103029567"></p><p>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p><h2 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h2><p>网络核心部分是互联网中最复杂的部分。网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p><strong>在网络核心部分起特殊作用的是路由器 (router)。</strong>路由器是实现<strong>分组交换 (packet switching)</strong> 的关键构件，其任务是转发收到的分组，这是网络核心部分<strong>最重要的功能</strong>。（所以网络层那一章的知识很重要）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418103325964.png" alt="image-20210418103325964"></p><p><strong>典型交换技术包括：</strong></p><ol><li>电路交换</li><li>分组交换</li><li>报文交换等</li></ol><p><strong>互联网的核心部分采用了分组交换技术。</strong></p><p>下面简述各交换技术的特点</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>首先，如果我们需要两个电话能进行通信，比较简单，在两者之间连接一条电话线即可实现。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104110956.png" alt="image-20210418104110956"></p><p>现在，问题复杂了，如果五个电话都想要可以互相通信（两两连接）呢</p><p>那么它们之间就需要十对电话线</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104252231.png" alt="image-20210418104252231"></p><p>由此我们可以得出：N 部电话机两两直接相连，需 N(N –1)/2 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（N 2）成正比。这个数量随着电话的增加会出现疯狂的增长，所需要的电话线会非常多，这时，如果通过<strong>交换机</strong>我们就可以实现全网的交换任务了，同时减少了彼此之间的电话线，转由交换机统一管理</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104547321.png" alt="image-20210418104547321"></p><p>每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。 <strong>所采用的交换方式就是电路交换 (circuit switching)。</strong></p><p>什么是交换：<strong>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源</strong></p><p>电路交换必定是面向连接的。 </p><p>电路交换分为三个阶段：</p><ol><li><strong>建立连接：</strong>建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；</li><li><strong>通信：</strong>主叫和被叫双方就能互相通电话；</li><li><strong>释放连接：</strong>释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。</li></ol><p>面向连接的电路交换会有什么样的问题：<strong>电路交换的用户始终占用端到端的通信资源</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104805420.png" alt="image-20210418104805420"></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换则采用<strong>存储转发</strong>技术。</p><p>在发送端，先把较长的报文<strong>划分成较短的、固定长度的数据段。</strong> </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104932663.png" alt="image-20210418104932663"></p><p>首先在每一个数据段前面添加上首部构成分组 (packet)。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.gif" alt="分组交换"></p><p>分组交换网以“分组”作为数据传输单元。依次把各分组发送到接收端（假定接收端在左边）。</p><p>然后，接收端收到分组后剥去首部还原成报文。</p><p>最后，在接收端把收到的数据恢复成为原来的报文。</p><p>这一交换的过程需要有一个前提：这里我们假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。</p><p><strong>分组交换的传输单元</strong></p><p>每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418134245270.png" alt="image-20210418134245270"></p><p>数据传输过程中，负责转发分组的便是<strong>路由器</strong></p><p>在路由器中的输入和输出端口之间没有直接连线。<br>路由器处理分组的过程是：</p><ol><li>把收到的分组先放入缓存（暂时存储）；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口转发出去。</li></ol><p>注意：主机和路由器并不相同，主机是<strong>为用户进行信息处理</strong>的，并向网络发送分组，从网络接收分组。路由器<strong>对分组进行存储转发</strong>，最后把分组交付目的主机。学到后面，你会发现它们之间更多的区别</p><p>那么，分组转发有什么优点呢</p><table><thead><tr><th>优点</th><th>所采用的手段</th></tr></thead><tbody><tr><td><strong>高效</strong></td><td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</td></tr><tr><td><strong>灵活</strong></td><td>为每一个分组独立地选择最合适的转发路由。</td></tr><tr><td><strong>迅速</strong></td><td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。</td></tr><tr><td><strong>可靠</strong></td><td>保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</td></tr></tbody></table><p>当然他也存在一定缺点</p><p>分组在各结点存储转发时需要排队，这就会造成一定的<strong>时延</strong>。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 </p><p>最后，用一张图表示它们的区别</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418134753955.png" alt="image-20210418134753955"></p><p>三种交换的比较</p><ul><li>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</li><li>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率</li><li>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ul><h1 id="不同类别的网络"><a href="#不同类别的网络" class="headerlink" title="不同类别的网络"></a>不同类别的网络</h1><h2 id="按照网络的作用范围进行分类"><a href="#按照网络的作用范围进行分类" class="headerlink" title="按照网络的作用范围进行分类"></a>按照网络的作用范围进行分类</h2><ul><li><strong>广域网 WAN (Wide Area Network)</strong>：作用范围通常为几十到几千公里。</li><li><strong>城域网 MAN (Metropolitan Area Network)</strong>：作用距离约为 5~50 公里。</li><li><strong>局域网 LAN (Local Area Network)</strong> ：局限在较小的范围（如 1 公里左右）。</li><li><strong>个人区域网 PAN (Personal Area Network)</strong> ：范围很小，大约在 10 米左右。</li></ul><blockquote><p>若中央处理机之间的距离非常近（如仅 1 米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络。 </p></blockquote><h2 id="按照网络的使用者进行分类"><a href="#按照网络的使用者进行分类" class="headerlink" title="按照网络的使用者进行分类"></a>按照网络的使用者进行分类</h2><ul><li>公用网 (public network)<br>按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</li><li>专用网 (private network)<br>为特殊业务工作的需要而建造的网络。</li></ul><p>公用网和专用网都可以提供多种服务。如传送的是计算机数据，则分别是公用计算机网络和专用计算机网络。</p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><p>计算机网络的性能一般是指它的几个重要的性能指标，主要包括：</p><ul><li>速率</li><li>带宽</li><li>吞吐率</li><li>时延</li><li>时延带宽积</li><li>往返时间 RTT</li><li>利用率</li></ul><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>在了解速率之前，首先了解数据的单位——比特</p><blockquote><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p></blockquote><p><strong>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。</strong></p><p>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s等。</p><p>例如4 * 10¹⁰  bit/s 的数据率就记为 40 Gbit/s。</p><p><strong>速率往往是指额定速率或标称速率，非实际运行速率（受带宽影响）。</strong>  </p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>两种不同意义：</p><ul><li><strong>“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。</strong></li><li>在计算机网络中，带宽用来表示网络中<strong>某通道传送数据的能力</strong>。表示在单位时间内网络中的<strong>某信道所能通过的“最高数据率”</strong>。单位是 bit/s，即 “比特每秒”。    </li></ul><p>自己的理解：类似于高速公路和普通公路吧，车道（高速公路至少为六车道）越多，也就是公路越宽，单位时间内通过的容量越大，而普通公路，一般为二车道，宽度容量相较于高速公路就会小些</p><p>在“带宽”的上述两种表述中，前者为<strong>频域称谓</strong>，而后者为<strong>时域称谓</strong>，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><p>速率和带宽的区别便是：速率有关于物理媒介，也就是物理层，而带宽会收到五层协议栈的影响，比如你买的100M电信宽带，然后接入了10M的以太网网线，那么宽带就是指你的带宽，而以太网网线则是指速率。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><strong>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</strong></p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p><strong>吞吐量受网络的带宽或网络的额定速率的限制。</strong>  </p><p>又来自己的理解了，拿前面的例子，六车道高速公路代表着，每单位时间最多只能同时通过六辆车，这相当于是带宽等于6，但不可能每时每刻都那么巧同时有六辆车通过的，可能是一辆、两辆、或者三辆等，那么，这个时候通过的车辆数就是吞吐量</p><p>简单来说，吞吐量便是实际速率，而带宽就是额定速率</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的<strong>一端传送到另一端所需的时间</strong>。</p><p>有时也称为<strong>延迟</strong>或迟延。</p><p>网络中的时延由以下4个不同的部分组成：</p><ol><li><p>发送时延</p><p>发送时延也称为传输时延。发送数据时，数据帧从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142506439.png" alt="image-20210418142506439"></p></li><li><p>传播时延</p><p>电磁波在信道中需要传播一定的距离而花费的时间。 发送时延与传播时延有本质上的不同。信号发送速率和信号在信道上的传播速率是完全不同的概念。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142558278.png" alt="image-20210418142558278"></p></li><li><p>处理时延</p><p>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 </p></li><li><p>排队时延</p><p>分组在路由器输入输出队列中排队等待处理所经历的时延。<strong>排队时延的长短往往取决于网络中当时的通信量。</strong></p></li></ol><p>最后，数据在网络中经历的<strong>总时延</strong>就是发送时延、传播时延、处理时延和排队时延之和。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142718090.png" alt="image-20210418142718090"></p><p>需要重点注意到饿是：对于高速网络链路，我们<strong>提高的仅仅是数据的发送速率</strong>而不是比特在链路上的传播速率。 提高链路带宽减小了数据的发送时延。 </p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>链路的时延带宽积又称为以比特为单位的链路长度。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142919756.png" alt="image-20210418142919756"></p><p>只有在代表链路的管道都充满比特时，链路才得到了充分利用。</p><blockquote><p>时延带宽积 = 传播时延 × 带宽</p></blockquote><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。</p><p>往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。(运输层会详细聊到这个)</p><p>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</p><p><strong>当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。</strong></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>分为信道利用率和网络利用率。</p><ol><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ol><p><strong>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</strong></p><p>我们知道，时延和信道上数据传播速率有关，假设速率不变的情况下，时延又分为四种，当你利用率提高的同时，其中的一种——排队时延就会相应的变长，那么总的时延就会增加</p><p>若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0 之间的关系： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418143620011.png" alt="image-20210418143620011"></p><p>其中：U 是网络的利用率，数值在 0 到 1 之间。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418143637381.png" alt="image-20210418143637381"></p><h1 id="非性能特征"><a href="#非性能特征" class="headerlink" title="非性能特征"></a>非性能特征</h1><p>当然，一些非性能特征也很重要。它们与前面介绍的性能指标有很大的关系。主要包括：</p><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性 </li><li>易于管理和维护 </li></ul><h1 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>计算机网络中的数据交换<strong>必须遵守事先约定好的规则</strong>。 </p><p>这些<strong>规则</strong>明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。</p><p><strong>网络协议</strong> (network protocol)，简称为<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准或约定。</p><h3 id="网络协议的三个组成要素"><a href="#网络协议的三个组成要素" class="headerlink" title="网络协议的三个组成要素*"></a>网络协议的三个组成要素*</h3><p><strong>语法</strong>：数据与控制信息的结构或格式 。 </p><p><strong>语义：</strong>需要发出何种控制信息，完成何种动作以及做出何种响应。 </p><p><strong>同步</strong>：事件实现顺序的详细说明。 </p><h3 id="协议具有两种形式"><a href="#协议具有两种形式" class="headerlink" title="协议具有两种形式"></a>协议具有两种形式</h3><p>一种是使用便于人来阅读和理解的文字描述。</p><p>另一种是使用让计算机能够理解的程序代码。</p><p>这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。</p><h2 id="划分层次"><a href="#划分层次" class="headerlink" title="划分层次"></a>划分层次</h2><p>划分层次的优点，以及它的缺点</p><p>优点</p><ul><li>各层之间是独立的。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现和维护。</li><li>能促进标准化工作。  </li></ul><p>缺点</p><ul><li>降低效率。</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销。</li></ul><p>而层数也要适合，如果层数太少，就会使每一层的协议太复杂。层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难。 </p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><p>计算机网络的体系结构 (architecture) 是计算机网络的各层及其协议的集合。 </p><p>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。<br>实现 (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。</p><p><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</strong></p><p><strong>OSI</strong> 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p><p><strong>TCP/IP</strong> 是四层体系结构：应用层、运输层、网际层和网络接口层。<br>但最下面的网络接口层并没有具体内容。</p><p>因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418145642533.png" alt="image-20210418145642533"></p><p>在五层协议下，数据是这样传递的</p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/数据传递.jpg" alt="数据传递"><p>图里省略了到达通信接收方数据的处理方法，具体做法便是在每一层将数据对等层的首部和尾部<strong>剥去</strong>后再传递给上一层</p><p><strong>OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。</strong>这个名词现已被许多非 OSI 标准采用。</p><p>任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。</p><p>各层协议实际上就是在各个对等层之间传递数据时的各项规定。</p><h2 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h2><p><strong>实体 (entity)</strong> 表示任何可发送或接收信息的硬件或软件进程。 </p><p><strong>协议</strong>是控制<strong>两个对等实体</strong>进行通信的规则的集合。 </p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层<strong>提供服务</strong>。</p><p>要实现本层协议，还需要使用下层所提供的服务。 </p><p>协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。 协议是“水平的”，即协议是控制对等实体之间通信的规则。服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。上层使用服务原语获得下层所提供的服务。</p><p>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点 SAP</strong> (Service Access Point)。 服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口。OSI把层与层之间交换的数据的单位称为<strong>服务数据单元 SDU</strong> (Service Data Unit)。SDU 可以与 PDU 不一样，例如，可以是多个 SDU 合成为一个 PDU，也可以是一个 SDU 划分为几个 PDU。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418150946900.png" alt="image-20210418150946900"></p><p>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，还必须非常仔细地检查这个协议能否应付各种异常情况。 </p><h1 id="TCP-IP-的体系结构"><a href="#TCP-IP-的体系结构" class="headerlink" title="TCP/IP 的体系结构"></a>TCP/IP 的体系结构</h1><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151028155.png" alt="image-20210418151028155"></p><p>实际上，现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151050239.png" alt="image-20210418151050239"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151123598.png" alt="image-20210418151123598"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151137382.png" alt="image-20210418151137382"></p><p>客户进程和服务器进程使用 TCP/IP 协议栈进行通信</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151152180.png" alt="image-20210418151152180"></p><p>功能较强的计算机可同时运行多个服务器进程 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151236957.png" alt="image-20210418151236957"></p>]]></content>
    
    <summary type="html">
    
      内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:31:54.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层主要是面向通信部分的最高层，同时也是用户功能中的最低层。主要有以下两点</p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有</strong>位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406162023935.png" alt="image-20210406162023935"></p><h2 id="逻辑通信"><a href="#逻辑通信" class="headerlink" title="逻辑通信"></a>逻辑通信</h2><p>运输层为相互通信的应用进程提供<strong>逻辑通信</strong></p><ul><li>逻辑通信：好像是这样通信，但事实上并非真的这样通信</li></ul><p>通过以下图结合来理解，在平行上，应用进程之间是通过运输层进行通信的（逻辑通信），但实际上数据的传递依旧还是要通过下一层网络层及下下层再通过路由器进行传递的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406162844136.png" alt="image-20210406162844136"></p><p>这里举个形象的栗子：你要写信给你的盆友，你只要记得门口邮箱在哪个位置，然后投进你的信件，而不需要考虑它是怎样进行运输从而到达盆友门口邮箱里的，盆友也只用直接从他家门口邮箱里取即可，这里的邮箱好比就是运输层，你们的交流就好像是通过邮箱（逻辑通信）进行的，但实际上邮件还是依然要通过多个运输环节（五层协议）才能到达盆友家。</p><h2 id="屏蔽作用"><a href="#屏蔽作用" class="headerlink" title="屏蔽作用"></a>屏蔽作用</h2><blockquote><p>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p></blockquote><p>正因为前面的逻辑通信，所以我们可以专注于运输层的两个进程通信问题，而不必去关心底层的实现</p><p>从IP层来说，通信的两端是两台主机。</p><p>从运输层的角度看，通信的真正端点并不是主机而是主机中的<strong>进程</strong>。也就是说，端到端的通信是<strong>应用进程之间的通信</strong>。</p><p><strong>端系统之间通信的含义</strong>：运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。端到端的通信是进程之间的通信</p><h2 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h2><p>复用：多个应用层进程汇聚成一个传输层进程</p><p>分用：传输层的单个进程通向多个应用层进程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406163750181.png" alt="image-20210406163750181"></p><p>形象来说：复用就是多车道变成单车道运输层，分用就是单车道分多车道通向多个应用进程（UDP会涉及到）</p><h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><ul><li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406164635108.png" alt="image-20210406164635108"></p><h3 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h3><ul><li><strong>无连接</strong>的协议，提供无连接服务;</li><li>其传送的运输协议数据单元TPDU是UDP报文或用户数据报;</li><li>支持单播、多播、厂播;</li><li><strong>不提供可靠交付</strong>;</li><li>简单。适用于很多应用，如: 多媒体应用等。</li></ul><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul><li>面向连接的协议，提供面向连接服务;</li><li>其传送的运输协议数据单元TPDU是TCP报文;</li><li>支持点对点单播，<strong>不支持多播、广播</strong>;</li><li>提供可靠服务;</li><li>复杂，用于大多数应用，如:万维网、电子邮件、文件传送等。</li></ul><h3 id="各自的应用范围"><a href="#各自的应用范围" class="headerlink" title="各自的应用范围"></a>各自的应用范围</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406165018430.png" alt="image-20210406165018430"></p><p>其中动态主机配置DHCP是在应用层ip地址动态分配时的相关应用，HTTP协议是客户端与服务器端交互的相关规则与约定</p><h2 id="IP数据报、TCP和UDP的关系"><a href="#IP数据报、TCP和UDP的关系" class="headerlink" title="IP数据报、TCP和UDP的关系"></a>IP数据报、TCP和UDP的关系</h2><ul><li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。<ul><li>IP 数据报要经过互连网中许多路由器的存储转发。</li><li>UDP 用户数据报是在运输层的端到端抽象的<strong>逻辑信道</strong>中传送的。</li></ul></li><li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却<strong>不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接</strong>。 </li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote><p>运行在计算机中的进程是用进程标识符来标志的。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406165416517.png" alt="image-20210406165416517"></p><h3 id="为什么会有端口"><a href="#为什么会有端口" class="headerlink" title="为什么会有端口"></a>为什么会有端口</h3><ol><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li><li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li><li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li></ol><p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p><p>形象地说：ip地址更像是标识你家在哪栋楼，端口更像是标识你是哪间房</p><h3 id="硬件端口和软件端口"><a href="#硬件端口和软件端口" class="headerlink" title="硬件端口和软件端口"></a>硬件端口和软件端口</h3><ul><li>在协议栈层间的抽象的协议端口是软件端口。</li><li>路由器或交换机上的端口是硬件端口。</li></ul><p>也就是说：硬件端口是 用来连接各个硬件设备的，而软件端口则是应用层的<strong>各种协议进程与运输实体进行层间交互</strong>的一种地址</p><h3 id="端口位数"><a href="#端口位数" class="headerlink" title="端口位数"></a>端口位数</h3><p>端口用一个 16 位端口号进行标志，允许有65,535（2¹⁶）个不同的端口号</p><p>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p><p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）。</p><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><ul><li>服务器端使用的端口号<ul><li>熟知端口，数值一般为 0 ~ 1023。</li><li>登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li></ul></li><li>客户端使用的端口号<ul><li>又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406170331878.png" alt="image-20210406170331878"></p><h1 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h1><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能</p><ol><li><strong>复用和分用</strong>的功能</li><li><strong>差错检测</strong>的功能</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406194530087.png" alt="复用和分用"></p><p>前面已经简单的介绍了UDP的特点了，这里补充其它的特点以及这些特点的优点</p><ul><li><strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。</li><li><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li><strong>UDP 是面向报文的。</strong>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 </li><li><strong>UDP 没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 </li><li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li><strong>UDP 的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ul><p>再来看看UDP的这两个特点</p><ul><li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li><li>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</li></ul><p>这意味着什么，接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p><p>所以如果你的报文太长，UDP把它交给IP层后，IP层再传送时就可能要分片，这会降低IP层的效率，而如果报文太短，则IP数据报的首部相对于报文会太长，同样也会降低IP层效率，所以应用程序必须选择合适的报文长度</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406200653561.png" alt="image-20210406200653561"></p><h2 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h2><p>用户数据报 UDP 有两个字段：数据字段和首部字段。<br>首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节</p><p>在计算检验和时，临时把 12 字节的“伪首部”和 UDP 用户数据报连接在一起。<strong>伪首部仅仅是为了计算检验和</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406200825674.png" alt="image-20210406200825674"></p><p>计算检验和这里不展开说（因为没去算），感兴趣可以通过书本理解</p><h1 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h1><blockquote><p>TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。</p></blockquote><p>同样以复用和分用进行通信</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201305393.png" alt="image-20210406201305393"></p><h2 id="TCP-最主要的特点"><a href="#TCP-最主要的特点" class="headerlink" title="TCP 最主要的特点"></a>TCP 最主要的特点</h2><ul><li>TCP 是面向连接的运输层协议。</li><li>每一条 TCP 连接<strong>只能有两个端点</strong> (endpoint)，每一条 TCP 连接<strong>只能是点对点</strong>的（一对一）。 </li><li>TCP 提供<strong>可靠交付</strong>的服务。</li><li>TCP 提供<strong>全双工</strong>通信。</li><li><strong>面向字节流</strong><ol><li>TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。</li><li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是<strong>一连串无结构的字节流</strong>。</li></ol></li></ul><p>TCP面向流的具体说明</p><blockquote><p>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。</p><p>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201834256.png" alt="image-20210406201834256"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406201944463.png" alt="image-20210406201944463"></p><p>注意：</p><ol><li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的<strong>窗口值</strong>（<a href="#TCP的流量控制">流量控制</a>）和<strong>当前网络拥塞</strong>（<a href="#TCP的拥塞控制">拥塞控制</a>）的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块<strong>划分</strong>短一些再传送。</li><li>TCP 也可<strong>等待积累</strong>有足够多的字节后再构成报文段发送出去。</li></ol><p>后面几节会具体展示其是如何工作的（可靠传输），以及这些关键点的实现</p><h2 id="TCP的连接（套接字）"><a href="#TCP的连接（套接字）" class="headerlink" title="TCP的连接（套接字）"></a>TCP的连接（套接字）</h2><ul><li>TCP 把连接作为<strong>最基本的抽象</strong>。</li><li>每一条 TCP 连接有两个<strong>端点</strong>。</li><li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字 (socket) 或插口</strong>。</li><li><strong>端口号拼接到 (contatenated with) IP 地址即构成了套接字。</strong> </li></ul><p>下面通过图理解套接字</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406202414660.png" alt="image-20210406202414660"></p><p>套接字的格式：<strong>套接字 socket = (IP地址 : 端口号)</strong></p><p>例子：<strong>套接字 socket = (192.169.1.20 : 2028)</strong></p><p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406202530840.png" alt="image-20210406202530840"></p><p>根据以上可以得出</p><ul><li>TCP 连接就是由协议软件所提供的一种抽象。</li><li>TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。</li><li>同一个 IP 地址可以有多个<strong>不同的 TCP 连接</strong>。</li><li>同一个端口号也可以出现在多个不同的 TCP 连接中。</li></ul><p>Socket其实有多种含义，在不同的场景其含义不同，比如</p><ul><li>应用编程接口  API  称为 socket API, 简称为 socket。</li><li>socket API 中使用的一个函数名也叫作 socket。</li><li>调用 socket 函数的端点称为 socket。</li><li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现</li></ul><h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>直接上图——TCP也就是建立在IP协议不可靠传输上的可靠传输（前面有讲过）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406203105228.png" alt="image-20210406203105228"></p><p>让我们试想一下：我们希望的传输是不会出差错的，也就是不论发送何种文件，你都希望它能稳定可靠的传输到目的地去，以及接收方能准时无误的接收到你传送的文件，不希望它在某个过程中出现差错，以致于你要重新去传输该文件，所以理想传输总结起来有两点：</p><ol><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ol><p>然而实际上网络并非如此，它都不具备以上两个理想条件，所以我们必须使用一些可靠传输协议（TCP），在不可靠的传输信道（IP）实现可靠传输</p><h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><blockquote><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p></blockquote><p>我们知道：TCP是提供全双工工作方式的，也就是通信双方即是发送方也可以是接收方，但是这里为了方便，只考虑单方向（双方向工作原理一致）。定为A→发送方，B→接收方</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406204405025.png" alt="image-20210406204405025"></p><p>A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。如此循环反复下去。</p><p>那么问题来了，出错了咋办，让我们先来看看接收方B在传输过程可能会出现的错误</p><p>在接收方 B 会出现两种情况：</p><ol><li>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。</li><li>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li></ol><p>在这两种情况下，B 都不会发送任何信息。但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。那么问题又来了，A怎么知道自己是否该重传分组了呢，没错，超时重传</p><h3 id="超时重传（自动重传请求-ARQ）"><a href="#超时重传（自动重传请求-ARQ）" class="headerlink" title="超时重传（自动重传请求 ARQ）"></a>超时重传（自动重传请求 ARQ）</h3><ol><li>A 为每一个已发送的分组都设置了一个超时计时器。</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li><li>若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406205258419.png" alt="image-20210406205258419"></p><h3 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h3><p>接下来，看看超时重传会遇到的问题</p><blockquote><p>若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？</p></blockquote><p>解决方法便是“编号”</p><ul><li>A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。</li><li>B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。</li><li>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</li></ul><h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p>好滴，又有问题了（你这问题怎么这么多！！！）</p><ol><li><p>如果接收方Bd的确认在路上直接丢失了呢（确认丢失）</p><p>又或者</p></li><li><p>传输过程中没有出现差错，但 B 对分组 M1 的确认迷路了，走了点弯路，然后迟到了呢（确认迟到）</p></li></ol><p>让我们先来解决第一个问题</p><blockquote><p>首先，A会<strong>超时重发</strong>，然后收到确认，这没啥可说的，重点是B，接收方B会收到两次分组，那么它会怎么做，是的，<strong>丢掉当前这一个分组并重传确认分组</strong>。为什么要重传确认，B说它之前不是发过一次了吗，当然要发，它不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</p></blockquote><p>第二个问题的解决</p><blockquote><p>首先，A收到了B延迟的M1确认，这时，它已经将缓冲的备份分组发出去了，那么当他收到第二次重复的确认时，<strong>它会丢弃重复的确认</strong></p><p>而B也仍然会收到重复的 M1，它同样会<strong>丢弃重复的 M1</strong>，并重传确认分组。</p></blockquote><p>最后，用一个图来理解这两个概念</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406211258525.png" alt="image-20210406211258525"></p><p><strong>注意</strong></p><ul><li>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</li><li>分组和确认分组都必须进行编号。（区分不同的分组以及确认）</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 （以防迷了点小路而导致重传浪费性能）</li></ul><p>总结下停止等待协议的要点</p><ol><li><strong>停止等待</strong>。发送方每次只发送一个分组。在收到确认后再发送下一个分组。</li><li><strong>编号</strong>。对发送的每个分组和确认都进行编号。</li><li><strong>自动重传请求</strong>。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。</li><li><strong>简单，但信道利用率太低</strong>。（信道利用率那一节会讲到该特点以及解决方法）</li></ol><h2 id="自动重传请求-ARQ"><a href="#自动重传请求-ARQ" class="headerlink" title="自动重传请求 ARQ"></a>自动重传请求 ARQ</h2><p>通过上面的学习：我们可以了解到B不论何时都不需要跟A说分组丢失，要它重传了，因为这些分组该来总会来的（超时重传），A不会欠B的。像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p><ul><li>通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</li><li>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</li></ul><h2 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h2><p>不知道你们有没有发现：每次A发送分组后，需要等待B的确认分组到达后才会发送下次分组，这样的信道利用率是不是会有点低</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212057270.png" alt="image-20210406212057270"></p><p>信道利用率公式</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212330913.png" alt="image-20210406212330913"></p><p>可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。<br>若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。</p><h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。<br>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。<br>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212431804.png" alt="image-20210406212431804"></p><h3 id="连续-ARQ协议"><a href="#连续-ARQ协议" class="headerlink" title="连续 ARQ协议"></a>连续 ARQ协议</h3><p>基本思想：</p><ol><li>发送方一次可以发出<strong>多个分组</strong>。</li><li>使用<strong>滑动窗口协议</strong>控制发送方和接收方所能发送和接收的分组的数量和编号。</li><li>协议规定：每收到一个确认，发送方就把发送窗口<strong>向前滑动</strong>。</li><li>接收方一般采用<strong>累积确认</strong>的方式。</li><li>采用<strong>回退N</strong>（Go-Back-N）方法进行重传（后面有解释）。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406212801263.png" alt="image-20210406212801263"></p><h4 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h4><blockquote><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p></blockquote><ol><li>优点：容易实现，即使确认丢失也不必重传。</li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213216445.png" alt="image-20210406213216445"></p><p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。<br>这就叫做 <strong>Go-back-N（回退 N）</strong>，表示需要再退回来重传已发送过的 N 个分组。<br>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213809411.png" alt="image-20210406213809411"></p><p>TCP 连接的每一端都必须设有两个窗口——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。<br>TCP 的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP 所有的确认都是基于序号而不是基于报文段。<br>TCP 两端的四个窗口经常处于<strong>动态变化</strong>之中。<br>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法<strong>估算较为合理的重传时间</strong>。 </p><p>滑动窗口协议比较复杂，是 TCP 协议的精髓所在。<br>发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p><strong>通过图片理解</strong></p><p>首先：定义一个发送窗口以及接收窗口</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213310884.png" alt="image-20210406213310884"></p><p>开始发送</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213550163.png" alt="image-20210406213550163"></p><p>接收到正确分组</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213611980.png" alt="image-20210406213611980"></p><p>继续下个窗口</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406213625768.png" alt="image-20210406213625768"></p><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><blockquote><ol><li>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。</li><li>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。</li><li>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</li></ol></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406215738080.png" alt="image-20210406215738080"></p><p>接下来，对每个部分进行说明</p><p><strong>源端口和目的端口字段</strong>——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 </p><p><strong>序号字段seq</strong>——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 为当前端成功发送的数据位数</p><p><strong>确认号字段ack</strong>——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 </p><p>若确认号 = N，则表明：到序号N-1为止所有的数据都已正确收到</p><p><strong>数据偏移（即首部长度）</strong>——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 </p><p><strong>保留字段</strong>——占 6 位，保留为今后使用，但目前应置为 0。 </p><p><strong>紧急 URG</strong> —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </p><p><strong>确认 ACK</strong> —— 只有当 ACK =1 时确认号字段才有效。当 ACK =0 时，确认号无效。 </p><p><strong>推送 PSH (PuSH)</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p><p><strong>复位 RST (ReSeT)</strong> —— 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </p><p><strong>同步 SYN</strong> —— 同步 SYN = 1 表示这是一个连接请求（ACK = 0）或连接接受报文（ACK = 1）。 </p><p><strong>终止 FIN (FINish)</strong> —— 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </p><p><strong>窗口字段</strong> —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p><p><strong>检验和</strong> —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><p>在计算检验和时，临时把 12 字节的“伪首部”和 TCP 报文段连接在一起。伪首部仅仅是为了计算检验和。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210406220316580.png" alt="image-20210406220316580"></p><p><strong>紧急指针字段</strong> —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 </p><p><strong>选项字段</strong> —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的<strong>缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</strong>。” </p><ul><li><p>MSS (Maximum Segment Size)<br>是 TCP 报文段中的数据字段的最大长度。<br>数据字段加上 TCP 首部才等于整个的 TCP 报文段。<br>所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。</p></li><li><p>为什么规定MSS</p><blockquote><p>MSS 与接收窗口值没有关系。</p><p>若选择较小的 MSS 长度，网络的利用率就降低。</p><p>若 TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。</p><p>因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。</p><p>但最佳的 MSS 是很难确定的。</p></blockquote></li></ul><p><strong>其他选项</strong></p><ul><li><strong>窗口扩大选项</strong> ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li><li><strong>时间戳选项</strong>——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</li><li><strong>选择确认选项</strong>——在后面的”TCP可靠传输的实现”介绍。 </li></ul><p><strong>填充字段</strong> —— 这是为了使整个首部长度是 4 字节的整数倍。 </p><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><h2 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h2><p>前面讲了可靠传输原理中的流水线传输以及连续 ARQ协议以及后面实现的图示，这里通过回顾来补充和引入新知识点</p><ul><li>TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。</li><li>TCP 的滑动窗口是以字节为单位的。</li><li>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</li><li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li><li>接收窗口表示：只允许接收落入窗口内的数据。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407150007573.png" alt="image-20210407150007573"></p><p>通过图，可以知道：</p><ul><li>首先，根据 B 给出的接收窗口值，A 构造出自己的发送窗口。但是不能大于B的窗口，否则可能超出B的接收范围</li><li>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 </li><li>发送窗口里面的序号表示允许发送的序号。</li><li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但其实它还是会收到一些其它因素的影响，比如网络堵塞，后面会讲到</li></ul><p>图里讲到TCP标准强烈不建议发送窗口前沿向后收缩，这是为啥嘞，因为在你收缩的时候这些数据可能已经发送出去了，到时候等窗口移过去你又发送一遍，就会发生错误</p><p>现在假设A发送了11个字节的数据，但B这边出了点状况，有部分字节没有按序收到，可能是31出错了，导致32、33没有按序收到</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407150227334.png" alt="image-20210407150227334"></p><p>这时候B会怎么做，它会等待缺少的数据到来（这里要注意：如同前面讲的，发送方会未确认序号开始一次性把后面的数据发送来，尽管接收方已经接收到了后面的数据。且等新数据到来后接收方依旧会丢弃掉这些重复的数据）</p><p>而等到数据正确到来，接收方也准确无误把它们交付给上一层后，窗口就会丢掉这些值，并向前移动<img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152428236.png" alt="image-20210407152428236"></p><p>而如果当A 的发送窗口内的序号都已用完，但还没有再收到确认，那么A就必须停止发送。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407151335623.png" alt="image-20210407151335623"></p><h3 id="发送缓存与接收缓存"><a href="#发送缓存与接收缓存" class="headerlink" title="发送缓存与接收缓存"></a>发送缓存与接收缓存</h3><p>发送方以及接收方的窗口都会包含缓存，用于存储临时数据</p><p>发送方的应用进程会把字节流写入 TCP 的发送缓存。直到接收方正确接收了，它就会把缓存删除。发送缓存存放的数据主要为两种</p><ol><li>暂存TCP准备发送的数据；</li><li>暂时存放TCP 已发送出但尚未收到确认的数据。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152605336.png" alt="image-20210407152605336"></p><p>接收方的应用进程也会从 TCP 的接收缓存中读取字节流。</p><p>所以其会暂时存取两种数据</p><ol><li>按序到达的、但尚未被接收应用程序读取的数据；</li><li>不按序到达的数据</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407152743085.png" alt="image-20210407152743085"></p><p>根据以上，我们需要强调以及知道以下三点</p><p>第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</p><p>第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</p><p>第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 </p><p>对于接收方：它可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点：</p><ol><li><p>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。</p></li><li><p>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</p></li></ol><h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>重传时间的选择是 TCP 最复杂的问题之一。</p><p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。</p><p>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p><p>因此TCP 采用了一种<strong>自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</p><h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3><ul><li>TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）。</li><li>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154611456.png" alt="image-20210407154611456"></p><p>式中，0 ＜= α ＜ 1。若 α 很接近于零，表示 RTT 值更新较慢。若选择 α 接近于 1，则表示 RTT 值更新较快。<br>RFC 6298 推荐的 α 值为 1/8，即 0.125。 </p><h3 id="超时重传时间-RTO"><a href="#超时重传时间-RTO" class="headerlink" title="超时重传时间 RTO"></a>超时重传时间 RTO</h3><p>RTO (Retransmission Time-Out) 应<strong>略大于</strong>上面得出的加权平均往返时间 RTTS。</p><p>RFC 6298 建议使用下式计算 RTO：</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154857678.png" alt="image-20210407154857678"></p><p>RTTD 是 RTT 的偏差的加权平均值。<br>RFC 6298 建议这样计算RTTD 。第一次测量时， RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD ：</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407154926977.png" alt="image-20210407154926977"></p><p>β是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p><h3 id="往返时间-RTT-的测量相当复杂"><a href="#往返时间-RTT-的测量相当复杂" class="headerlink" title="往返时间 (RTT) 的测量相当复杂"></a>往返时间 (RTT) 的测量相当复杂</h3><p>现在假设这样一种情况，TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。<br>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155147444.png" alt="image-20210407155147444"></p><p>在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。<br>这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。<br>但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p><h3 id="修正的-Karn-算法"><a href="#修正的-Karn-算法" class="headerlink" title="修正的 Karn 算法"></a>修正的 Karn 算法</h3><p>报文段每重传一次，就把 RTO 增大一些：</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155238710.png" alt="image-20210407155238710"></p><p>系数 λ的典型值是 2 。<br>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。<br>实践证明，这种策略较为合理。 </p><h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>前面我们知道，当接收方收到没有正确按序的数据时，发送方会将包括这部分数据也一起发送来，这看起来是不是极其耗费性能，那么我们能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？</p><p>选择确认 SACK  (Selective ACK) 就是一种可行的处理方法</p><p>接收方可以将正确接收到的数据序号发送回发送方，使发送方不要再发送这些数据，这里要注意序号的问题。如图，你接受到了1—1000的数据那么确认号就要在右边界上再加1</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407155722884.png" alt="image-20210407155722884"></p><p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</p><p>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</p><p>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p><p>最后，也是重要的一点</p><p><strong>因为SACK文档没有指明发送方应当怎样响应SACK，因此大多数的实现还是重传所有未被确认的数据块</strong></p><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h2><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。<br>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。<br>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p><p>用一个图来表示这个过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407162855529.png" alt="image-20210407162855529"></p><p>这便是通过滑动窗口机制来来同台控制数据流量</p><p>但是，有这么一个情况，当B不允许A发送过后一段时间内，需要重新进行数据传输，但是巧了，这时候B的请求在路上丢失了，咋办，这个互不搭理（停止传输数据）的状态不就会这样一直保持下去吗</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407163156764.png" alt="image-20210407163156764"></p><p>这种互相等待的状态也成为<strong>死锁</strong>局面，如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>而为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。</p><p>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</p><p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p><p>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</p><p>若窗口不是零，则死锁的僵局就可以打破了。 皆大欢喜</p><h2 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h2><p>前面有提到：当应用程序把数据传送到TCP的发送缓冲后，剩下的发送任务就由TCP控制了，可以用不同的机制来控制 TCP 报文段的发送时机</p><ol><li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。</li><li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li></ol><p>如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。</p><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>在了解怎么合理控制发送时机前，我们首先来了解一个概念：糊涂窗口综合症</p><blockquote><p>糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164102037.png" alt="image-20210407164102037"></p><h3 id="发送方糊涂窗口综合症"><a href="#发送方糊涂窗口综合症" class="headerlink" title="发送方糊涂窗口综合症"></a>发送方糊涂窗口综合症</h3><p><strong>现象：</strong>发送方 TCP 每次接收到一字节的数据后就发送。<br>这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。</p><p><strong>解决方法：</strong>使用 Nagle 算法。</p><p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。<br>只有在收到对前一个报文段的确认后才继续发送下一个报文段。<br>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164246900.png" alt="image-20210407164246900"></p><h3 id="接收方糊涂窗口综合症"><a href="#接收方糊涂窗口综合症" class="headerlink" title="接收方糊涂窗口综合症"></a>接收方糊涂窗口综合症</h3><p>这个的现象主要如下</p><p>当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。<br>若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407164353139.png" alt="image-20210407164353139"></p><p><strong>原因：</strong>接收方应用进程消耗数据太慢，例如：每次只读取一个字节。</p><p><strong>解决方法：</strong>让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h2><p>首先：看看拥塞的现象</p><p>在某段时间，若对网络中<strong>某资源的需求超过了该资源所能提供的可用部分</strong>(信道不够用)，网络的性能就要变坏。这种现象称为拥塞 (congestion)。<br>最坏结果：系统崩溃。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407165856238.png" alt="image-20210407165856238"></p><p>出现<strong>拥塞</strong>的原因，可能如下</p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p>总的来说便是 </p><p><strong>∑ 对资源需求  &gt; 可用资源</strong></p><p>那么，通过增加资源能解决拥塞吗？</p><p>不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。</p><p>网络拥塞往往是由许多因素引起的。例如：<br>增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；<br>提高处理机处理的速率会会将瓶颈转移到其他地方；</p><p>这时候我们就要用到拥塞控制去降低网络拥塞带来的影响</p><h3 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h3><p>首先，我们来区别拥塞控制和流量控制</p><p>拥塞控制与流量控制的关系密切，它们之间也存在一些差别</p><blockquote><p>拥塞控制：</p><p>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载；</p><p>是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素。</p></blockquote><blockquote><p>流量控制：</p><p>抑制发送端发送数据的速率，以使接收端来得及接收；</p><p>是点对点通信量的控制，是端到端的问题；</p></blockquote><h3 id="拥塞控制的一般原理-1"><a href="#拥塞控制的一般原理-1" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>拥塞控制的前提：网络能够承受现有的网络负荷。<br>实践证明，拥塞控制是很难设计的，因为它是一个动态问题。<br>分组的丢失是网络发生拥塞的征兆而不是原因。<br>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407170728128.png" alt="image-20210407170728128"></p><h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>在面对设计网络时，我们通常采用开环控制方法和闭环控制方法，通俗来讲就是，前者就是尽量不让问题发生，后者是在问题发生时及时控制</p><blockquote><p><strong>开环控制</strong></p><p>在设计网络时，事先考虑周全，力求工作时不发生拥塞；</p><p><strong>思路：</strong>力争避免发生拥塞。</p></blockquote><blockquote><p><strong>闭环控制</strong></p><p>基于反馈环路的概念；</p><p>根据网络当前的运行状态采取相应控制措施；</p><p><strong>思路：</strong>在发生拥塞后，采取措施进行控制，消除拥塞。</p></blockquote><p>属于闭环控制的有以下几种措施：<br>(1) 监测网络系统，以便检测到拥塞在何时、何处发生。<br>(2) 将拥塞发生的信息传送到可采取行动的地方。<br>(3) 调整网络系统的运行以解决出现的问题。</p><p><strong>那么如何检测网络拥塞嘞</strong>，主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><p><strong>那么怎么去知道拥塞发生了呢</strong></p><ol><li>发送通知拥塞发生的分组；</li><li>在分组中保留表示拥塞状态的字段；</li><li>周期性地发出探测分组等。</li></ol><p><strong>那么这个时机该如何把握嘞</strong></p><p>过于频繁，会使系统产生不稳定的振荡；<br>过于迟缓地采取行动又不具有任何实用价值。</p><p><strong>解决拥塞的两条思路</strong></p><p>增加网络可用资源；<br>减少用户对资源的需求。</p><h2 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h2><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p><p>TCP发送方维持一个拥塞窗口 cwnd (Congestion Window)<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p><p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：</p><blockquote><p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</p><p>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><h3 id="判断拥塞"><a href="#判断拥塞" class="headerlink" title="判断拥塞"></a>判断拥塞</h3><p>重传定时器超时：网络已经发生了拥塞。</p><p>收到三个重复的 ACK：预示网络可能会出现拥塞（实际可能还未发生拥塞）。</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><h4 id="慢开始-slow-start"><a href="#慢开始-slow-start" class="headerlink" title="慢开始 (slow-start)"></a>慢开始 (slow-start)</h4><p><strong>目的：</strong>用来确定网络的负载能力或拥塞程度。</p><p><strong>算法的思路：</strong>由小到大逐渐增大拥塞窗口数值。</p><p><strong>两个变量：</strong></p><blockquote><p>拥塞窗口：</p><p>初始拥塞窗口值：2 种设置方法。<br>    1 至 2 个最大报文段 （旧标准）<br>    2 至 4 个最大报文段 （RFC 5681）</p><p>窗口值逐渐增大。</p></blockquote><blockquote><p>慢开始门限：</p><p>防止拥塞窗口增长过大引起网络拥塞。</p></blockquote><p>拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。</p><blockquote><p>拥塞窗口 cwnd 每次的增加量 = min (N, SMSS)     </p></blockquote><p>其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。<br>不难看出，当 N &lt; SMSS 时，拥塞窗口每次的增加量要小于 SMSS。<br>用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172825021.png" alt="image-20210407172825021"></p><p>发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172914039.png" alt="image-20210407172914039"></p><p>每经过一个传输轮次，拥塞窗口就加倍。</p><p>使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。 </p><p>一个传输轮次所经历的时间其实就是往返时间 RTT。</p><p>“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 </p><p><strong>慢开始门限 ssthresh 的用法如下：</strong></p><p>当 cwnd &lt; ssthresh 时，使用慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</p><h4 id="拥塞避免-congestion-avoidance"><a href="#拥塞避免-congestion-avoidance" class="headerlink" title="拥塞避免 (congestion avoidance)"></a>拥塞避免 (congestion avoidance)</h4><p><strong>思路：</strong>让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。</p><p>每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。</p><p>使拥塞窗口 cwnd 按线性规律缓慢增长。</p><p>在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407172914039.png" alt="image-20210407172914039"></p><p>在超时之前，每经过一个传输轮次就使 cwnd 加 1。 </p><p><strong>当网络出现拥塞时</strong></p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：<br>ssthresh = max (cwnd/2，2)<br>cwnd = 1<br>执行慢开始算法<br>目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173243947.png" alt="image-20210407173243947"></p><p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。</p><p>慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p><p>慢开始和拥塞避免算法的实现GIF图举例</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.gif" alt="拥塞控制"></p><p><strong>必须强调指出</strong></p><p>“拥塞避免”<strong>并非指完全能够避免了拥塞</strong>。利用以上的措施要完全避免网络拥塞还是不可能的。</p><p>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173752095.png" alt="image-20210407173752095"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173815321.png" alt="image-20210407173815321"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173824284.png" alt="image-20210407173824284"></p><h4 id="快重传-fast-retransmit"><a href="#快重传-fast-retransmit" class="headerlink" title="快重传 (fast retransmit)"></a>快重传 (fast retransmit)</h4><p>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p><p>使用快重传可以使整个网络的吞吐量提高约20%。 </p><blockquote><p>不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 </p></blockquote><p>采用快重传 FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。</p><p>快重传 算法<strong>首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407173936005.png" alt="image-20210407173936005"></p><h4 id="快恢复-fast-recovery"><a href="#快恢复-fast-recovery" class="headerlink" title="快恢复 (fast recovery)"></a>快恢复 (fast recovery)</h4><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：</p><ol><li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li><li>新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 </li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174035629.png" alt="image-20210407174035629"></p><p>因此，在图的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh = cwnd / 2 = 8，同时设置拥塞窗口 cwnd = ssthresh = 8（见图中的点5），并开始执行拥塞避免算法。</p><h3 id="加法增大，乘法减小-AIMD"><a href="#加法增大，乘法减小-AIMD" class="headerlink" title="加法增大，乘法减小 (AIMD)"></a>加法增大，乘法减小 (AIMD)</h3><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI (Additive Increase)。</p><p>当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD (Multiplicative Decrease)。</p><p>二者合在一起就是所谓的 AIMD 算法。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174136186.png" alt="image-20210407174136186"></p><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p><blockquote><p>发送窗口的上限值 = Min [rwnd, cwnd]</p></blockquote><p>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。</p><p>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。 </p><p>也就是说，rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</p><h2 id="主动队列管理-AQM"><a href="#主动队列管理-AQM" class="headerlink" title="主动队列管理 AQM"></a>主动队列管理 AQM</h2><p>TCP 拥塞控制和网络层采取的策略有密切联系。</p><p>若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。</p><p>重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。</p><p>对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。</p><h3 id="“先进先出”FIFO-处理规则"><a href="#“先进先出”FIFO-处理规则" class="headerlink" title="“先进先出”FIFO 处理规则"></a>“先进先出”FIFO 处理规则</h3><p>路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。</p><p>当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。</p><p>路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/AQM%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA.gif" alt="AQM先进先出"></p><p>分组丢弃使发送方出现超时重传，使 TCP 连接进入拥塞控制的慢开始状态。如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174557236.png" alt="image-20210407174557236"></p><h3 id="全局同步"><a href="#全局同步" class="headerlink" title="全局同步"></a>全局同步</h3><p>更为严重的是，在网络中通常有很多的 TCP 连接，这些连接中的报文段通常是复用在网络层的 IP 数据报中传送的。</p><p>在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为全局同步 (global syncronization)。</p><p>全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/AQM%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E5%85%A8%E5%B1%80.gif" alt="AQM先进先出全局"></p><p>分组丢弃使发送方出现超时重传，使多个 TCP 连接同时进入拥塞控制的慢开始状态，发生全局同步。如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407174833876.png" alt="image-20210407174833876"></p><h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>1998 年提出了主动队列管理 AQM (Active Queue Management)。</p><p>所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组，而是在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。</p><p>AQM 可以有不同实现方法，其中曾流行多年的就是随机早期检测 RED (Random Early Detection)。</p><p>使路由器的队列维持两个参数：队列长度最小门限 THmin 和最大门限 Thmax 。</p><p>RED 对每一个到达的分组都先计算平均队列长度 LAV 。</p><ol><li>若平均队列长度小于最小门限 THmin，则将新到达的分组放入队列进行排队。</li><li>若平均队列长度超过最大门限 Thmax ，则将新到达的分组丢弃。</li><li>若平均队列长度在最小门限 THmin 和最大门限 Thmax 之间，则按照某一概率 p 将新到达的分组丢弃。</li></ol><p>RED 将路由器的到达队列划分成为三个区域： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407175008385.png" alt="image-20210407175008385"></p><p>当 LAV  &gt;  Thmin 时，丢弃概率 p = 0。<br>当 LAV  &gt;  Thmax 时，丢弃概率 p = 1。<br>当 Thmin &lt; LAV &lt; Thmax时，  0 &lt; p  &lt; 1 。</p><p>在 RED 的操作中，最难处理的就是丢弃概率 p 的选择，因为 p 并不是个常数。例如，按线性规律变化，从 0 变到 pmax。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210407175116102.png" alt="image-20210407175116102"></p><p>多年的实践证明，RED 的使用效果并不太理想。</p><p>2015 年公布的 RFC 7567 已经把 RFC 2309 列为“陈旧的”，并且不再推荐使用 RED。</p><p>对路由器进行主动队列管理 AQM 仍是必要的。</p><p>AQM 实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。</p><p>现在已经有几种不同的算法来代替旧的 RED，但都还在实验阶段。</p><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><p>TCP 是面向连接的协议。<br>TCP 连接有三个阶段：</p><ol><li>连接建立</li><li>数据传送</li><li>连接释放</li></ol><p>TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行</p><p><strong>TCP 连接建立过程中要解决的三个问题</strong></p><ol><li><p>要使每一方能够确知对方的存在。</p></li><li><p>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</p></li><li><p>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</p></li></ol><p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户 (client)。被动等待连接建立的应用进程叫做服务器 (server)。</p><h2 id="TCP-的连接建立（三报文握手）"><a href="#TCP-的连接建立（三报文握手）" class="headerlink" title="TCP 的连接建立（三报文握手）"></a>TCP 的连接建立（三报文握手）</h2><p>TCP 建立连接的过程叫做握手。<br>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>通过连续的动画来理解这个过程</p><p>存在这样两台机子——客户A，服务器B，它们都处于关机状态</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073223940.png" alt="image-20210408073223940"></p><p>现在B的 TCP 服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073248750.png" alt="image-20210408073248750"></p><p>这时候A想要和B进行通信，它开机了，然后A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073345058.png" alt="image-20210408073345058"></p><p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。<br>B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073403752.png" alt="image-20210408073403752"></p><p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。<br>A 的 TCP 通知上层应用进程，连接已经建立。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073424503.png" alt="image-20210408073424503"></p><p>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。他们之间可以进行数据通信了</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073447876.png" alt="image-20210408073447876"></p><p>完整的TCP三报文握手示意图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408073500365.png" alt="image-20210408073500365"></p><h3 id="为什么要采取三报文握手"><a href="#为什么要采取三报文握手" class="headerlink" title="为什么要采取三报文握手"></a>为什么要采取三报文握手</h3><p>这里初学会有一个疑问，为什么要采取三报文握手呢，客户为什么还要再发一次确认收到呢，除了网上大家通俗的理解：为了让服务器知道我知道了外，主要还有以下原因——<strong>为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</strong></p><p>形象理解一下这句话，假设现在不需要第三个报文，然后发生这么一个故事</p><p>客户端在发送请求的过程中，第一个请求因为某些原因，在路上迷路了，客户端会再发送一次请求，以建立连接，等到连接释放，他想要的数据服务器已经给回它了的时候，巧了，迷路的请求来到服务器这边了，服务器就误以为客户端又要发起一次连接，于是响应过去，连接建立，但客户端此时不需要交互了啊，所以它也觉得莫名其妙，你服务器和我连接干啥，又没叫你，自作多情，然后客户端就没搭理服务器端，就这样，服务器端白白浪费了资源，一直处于连接过程</p><p>所以，为了解决客户端是真心想要和服务器建立连接的，它必须发送确认报文，用以确认连接正式建立</p><h3 id="TCO三次握手翻译得并不准确"><a href="#TCO三次握手翻译得并不准确" class="headerlink" title="TCO三次握手翻译得并不准确"></a>TCO三次握手翻译得并不准确</h3><p>还有一点需要注意：网上广而流传的TCP三次握手这个说法并不准确，书中提到，three way handshake，直译过来成三报文握手更合适，因为handshake是单数，而不是复数，这意味着，它们更像是通过握手上下摇晃三次，而不是握了三次手，RFC 793 文档中也有另外的表述，three way （three message）handshake，更加印证了这个译名。</p><h3 id="TCP四报文握手"><a href="#TCP四报文握手" class="headerlink" title="TCP四报文握手"></a>TCP四报文握手</h3><p>B发送给A的报文段可以分成两个，也就是先发送一个确认报文段（ACK = 1, ack = x + 1），然后再发送一个同步报文段（SYN = 1， seq = y），这样就变成了四报文握手，但效果一样</p><h2 id="TCP-的连接释放（四报文握手）"><a href="#TCP-的连接释放（四报文握手）" class="headerlink" title="TCP 的连接释放（四报文握手）"></a>TCP 的连接释放（四报文握手）</h2><p>TCP 连接释放过程比较复杂。</p><p>数据传输结束后，通信的双方都可释放连接。</p><p>TCP 连接释放过程是四报文握手。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>数据传输结束后，通信的双方都可释放连接。<br>现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。<br>A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080755867.png" alt="image-20210408080755867"></p><p>B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。<br>TCP 服务器进程通知高层应用进程。<br>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。<strong>B 若发送数据，A 仍要接收</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080834500.png" alt="image-20210408080834500"></p><p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080857738.png" alt="image-20210408080857738"></p><p> A 收到连接释放报文段后，必须发出确认。 </p><p> 在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408080923219.png" alt="image-20210408080923219"></p><p>完整图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408081005627.png" alt="image-20210408081005627"></p><h3 id="A-必须等待-2MSL-的时间"><a href="#A-必须等待-2MSL-的时间" class="headerlink" title="A 必须等待 2MSL 的时间"></a>A 必须等待 2MSL 的时间</h3><p>在这个图中你会发现：A 必须等待 2MSL 的时间，为什么呢，原因有两个</p><ol><li><p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</p><p>假设A最后一个确认连接释放报文没有被B正常收到时，B会超时重传连接释放报文，而如果这时候A急着关闭，就不知道B发过来了，所以需要等一会时间保证自己的报文成功被B收到</p></li><li><p>防止 “已失效的连接请求报文段”出现在本连接中。</p><p>同前面讲的一样，在经过2MSL时间后，A会将本连接的所有产生的报文从网络上消失掉，不管你是否丢失，都把你逮住，然后让你消失，防止下一次新连接中会出现旧连接的请求报文</p></li></ol><h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p><strong>干啥的</strong>：用来防止在TCP连接出现长时期的空闲。</p><p><strong>工作方式</strong>是啥：保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 </p><h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p>不行了不行了，整理不下去了，写不下去了，直接丢图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%BF%90%E8%BE%93%E5%B1%82/image-20210408082211484.png" alt="image-20210408082211484"></p><p>解释下图内标注含义⬇</p><p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p><p>图中有三种不同的箭头。</p><ol><li>粗实线箭头表示对客户进程的正常变迁。</li><li>粗虚线箭头表示对服务器进程的正常变迁。</li><li>细线箭头表示异常变迁。 </li></ol>]]></content>
    
    <summary type="html">
    
      面向通信部分的最高层，用户功能中的最低层，让我们来看看运输层吧
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-应用层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:30:10.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。</p><p>应用层的许多协议都是基于客户服务器方式。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 </p></blockquote><h1 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h1><h2 id="域名系统概述"><a href="#域名系统概述" class="headerlink" title="域名系统概述"></a>域名系统概述</h2><p>许多应用层软件经常直接使用域名系统 DNS (Domain Name System)，但计算机的用户只是<strong>间接</strong>而不是直接使用域名系统。 </p><p>互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。</p><p>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。 </p><h2 id="互联网的域名结构"><a href="#互联网的域名结构" class="headerlink" title="互联网的域名结构"></a>互联网的域名结构</h2><p>互联网采用了层次树状结构的命名方法。</p><p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</p><p>域名的结构由标号序列组成，各标号之间用点隔开：</p><blockquote><p>… . 三级域名 . 二级域名 . 顶级域名</p></blockquote><p>各标号分别代表不同级别的域名。 </p><p>在这里，域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><p>变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。</p><p>域名中的“点”和点分十进制 IP 地址中的“点”并无一一对应的关系。点分十进制 IP 地址中一定是包含三个“点”，但每一个域名中“点”的数目则不一定正好是三个。 </p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>国家顶级域名 nTLD，例如：</p><ol><li>.cn 表示中国，</li><li>.us 表示美国，</li><li>.uk 表示英国，等。</li></ol><p>通用顶级域名 gTLD，最早的顶级域名是：</p><ol><li>.com（公司和企业）</li><li>.net（网络服务机构</li><li>.org（非赢利性组织）</li><li>.edu（美国专用的教育机构）</li><li>.gov（美国专用的政府部门）</li><li>.mil（美国专用的军事部门）</li><li>.int（国际组织）</li></ol><p>基础结构域名 </p><ol><li>这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名。 </li></ol><p>直接上图表示这些域名关系</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408200642243.png" alt="image-20210408200642243"></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。</p><p>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</p><p>每一个区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到 IP 地址的映射。</p><p>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408200752803.png" alt="image-20210408200752803"></p><p>树状结构的 DNS 域名服务器</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408201212011.png" alt="image-20210408201212011"></p><p>域名服务器分为四种：</p><ol><li>根域名服务器 </li><li>顶级域名服务器 </li><li>权限域名服务器 </li><li>本地域名服务器 </li></ol><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</p><p>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</p><p>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a  一直到 m（前 13 个字母）。</p><p>这里注意：13个不同IP地址的根域名服务器并不意味着只有13个机器，而是共有13套装置</p><pre><code>a.rootservers.netb.rootservers.net… m.rootservers.net</code></pre><p>到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408202756097.png" alt="image-20210408202756097"></p><blockquote><p> 根域名服务器并不直接把域名直接转换成 IP 地址。<br> 在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器。</p></blockquote><h3 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h3><p>顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。</p><p>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </p><h3 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h3><p>负责一个区的域名服务器。</p><p>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p><h3 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h3><p>本地域名服务器对域名系统非常重要。</p><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。</p><h3 id="提高域名服务器的可靠性"><a href="#提高域名服务器的可靠性" class="headerlink" title="提高域名服务器的可靠性"></a>提高域名服务器的可靠性</h3><p>DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。</p><p>当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。</p><p>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</p><h2 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h2><p><strong>主机向本地域名服务器的查询一般都是采用递归查询。</strong>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份（替前一个主机继续查询），向其他根域名服务器继续发出查询请求报文。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408204141405.png" alt="image-20210408204141405"></p><blockquote><p>本地域名服务器向根域名服务器进行递归查询的比较少采用，主要使用下面的迭代查询进行</p></blockquote><p><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</strong>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408203800415.png" alt="image-20210408203800415"></p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。</p><p>可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 </p><p>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时<br>器，并处理超过合理时间的项（例如，每个项目只存放两天）。</p><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。 </p><h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h1><h2 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h2><p>文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。</p><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p><p>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>RFC 959 很早就成为了互联网的正式标准。 </p><h3 id="要知道，文件传送可不是一件简单的事情"><a href="#要知道，文件传送可不是一件简单的事情" class="headerlink" title="要知道，文件传送可不是一件简单的事情"></a>要知道，文件传送可不是一件简单的事情</h3><p>网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的计算机中。</p><p>初看起来，在两个主机之间传送文件是很简单的事情。</p><p>其实这往往非常困难。原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。 </p><h2 id="FTP-的基本工作原理"><a href="#FTP-的基本工作原理" class="headerlink" title="FTP 的基本工作原理"></a>FTP 的基本工作原理</h2><p>网络环境下复制文件的复杂性：</p><ol><li>计算机存储数据的格式不同。</li><li>文件的目录结构和文件命名的规定不同。</li><li>对于相同的文件存取功能，操作系统使用的命令不同。</li><li>访问控制方法不同。 </li></ol><h2 id="FTP工作特点"><a href="#FTP工作特点" class="headerlink" title="FTP工作特点"></a>FTP工作特点</h2><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</p><p>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p><p>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p><h3 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h3><ol><li><p>打开熟知端口（端口号为 21），使客户进程能够连接上。</p></li><li><p>等待客户进程发出连接请求。</p></li><li><p>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</p></li><li><p>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。 </p></li></ol><h3 id="FTP-使用的两个-TCP-连接"><a href="#FTP-使用的两个-TCP-连接" class="headerlink" title="FTP 使用的两个 TCP 连接"></a>FTP 使用的两个 TCP 连接</h3><p><strong>控制连接</strong>在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</p><p>实际用于传输文件的是<strong>“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</p><p><strong>数据传送进程实际完成文件的传送</strong>，在传送完毕后关闭“数据传送连接”并结束运行。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408214816503.png" alt="image-20210408214816503"></p><p>那么这个过程是否就需要占用两个端口号来建立两个不同的连接嘞，答案是肯定的</p><ol><li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。</li><li>接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。</li><li>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</li></ol><p>这样的好处是啥</p><ol><li>使协议更加简单和更容易实现。</li><li>在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</li></ol><h2 id="简单文件传送协议-TFTP"><a href="#简单文件传送协议-TFTP" class="headerlink" title="简单文件传送协议 TFTP"></a>简单文件传送协议 TFTP</h2><p>TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。</p><p>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</p><p>TFTP 只支持文件传输而不支持交互。</p><p>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 </p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据 PDU 也称为文件块 (block)，每个块按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。 </li></ul><h3 id="如同停止等待协议"><a href="#如同停止等待协议" class="headerlink" title="如同停止等待协议"></a>如同停止等待协议</h3><ul><li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</li><li>发完数据后<strong>在规定时间内收不到确认就要重发数据 PDU</strong>。</li><li>发送确认 PDU 的一方<strong>若在规定时间内收不到下一个文件块，也要重发确认 PDU</strong>。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。 </li><li>开始工作时，TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为  69。</li><li>TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。</li><li>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。</li><li>若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满 512 字节，这正好可作为文件结束的标志。</li></ul><h1 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，也是互联网的正式标准。</p><p>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</p><p>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 </p><p>现在由于 PC 的功能越来越强，用户已较少使用 TELNET 了。</p><p>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。</p><p>和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409070642758.png" alt="image-20210409070642758"></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>客户软件把用户的击键和命令转换成 <strong>NVT 格式</strong>，并送交服务器。</p><p>服务器软件把收到的数据和命令，从 <strong>NVT 格式转换成远地系统所需的格式</strong>。</p><p>向用户返回数据时，服务器把<strong>远地系统的格式转换为 NVT 格式</strong>，本地客户再从 <strong>NVT 格式转换到本地系统所需的格式</strong>。 </p><h1 id="万维网-WWW🔺"><a href="#万维网-WWW🔺" class="headerlink" title="万维网 WWW🔺"></a>万维网 WWW🔺</h1><h2 id="万维网概述"><a href="#万维网概述" class="headerlink" title="万维网概述"></a>万维网概述</h2><blockquote><p>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。<br>万维网是一个大规模的、联机式的信息储藏所。<br>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。<br>这种访问方式称为“链接”。</p></blockquote><p>万维网提供分布式服务</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409070913440.png" alt="image-20210409070913440"></p><p>万维网是<strong>分布式超媒体 (hypermedia) 系统</strong>，它是<strong>超文本 (hypertext) 系统</strong>的扩充。</p><p><strong>一个超文本由多个信息源链接成。</strong>利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。</p><p><strong>超媒体与超文本的区别是文档内容不同。</strong>超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>万维网以<strong>客户 - 服务器</strong>方式工作。</p><p>浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。</p><p>客户程序向服务器程序<strong>发出请求</strong>，服务器程序向客户程序<strong>送回</strong>客户所要的<strong>万维网文档</strong>。</p><p>在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。</p><p>好的，问题来了，通过以下问题，我们将直接引出后几节的内容</p><p>(1) 怎样标志分布在整个互联网上的万维网文档？<br>使用<strong>统一资源定位符 URL</strong> (Uniform Resource Locator) 来标志万维网上的各种文档。使每一个文档在整个互联网的范围内具有唯一的标识符 URL。 </p><p>(2) 用何协议实现万维网上各种超链的链接？<br>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP (HyperText Transfer Protocol)</strong>。<br>HTTP 是一个应用层协议，它<strong>使用 TCP 连接进行可靠的传送</strong>。 </p><p>(3) 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？<br><strong>超文本标记语言 HTML (HyperText Markup Language)</strong> 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 </p><p>(4) 怎样使用户能够很方便地找到所需的信息？<br>为了在万维网上方便地查找信息，用户可使用各种<strong>的搜索工具（即搜索引擎）</strong>。 </p><h2 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h2><p>资源定位符 URL 是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示。<br>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。<br>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。<br>URL 相当于一个文件名在网络范围的扩展。因此 <strong>URL 是与互联网相连的机器上的任何可访问对象的一个指针</strong>。 </p><h3 id="URL-的一般形式"><a href="#URL-的一般形式" class="headerlink" title="URL 的一般形式"></a>URL 的一般形式</h3><p>由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。</p><p>注意：对大小写没有要求，也就是说不管你输入home还是HOME，它的意思都是一样的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409072803806.png" alt="image-20210409072803806"></p><p>&lt;主机&gt; 是存放资源的主机在互联网中的域名</p><p>现在有些浏览器为了方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字符添上。<br>例如，用户只要键入 ypigy.gitee.io，浏览器就自动把未键入的字符补齐，变成<a href="https://ypigy.gitee.io/。" target="_blank" rel="noopener">https://ypigy.gitee.io/。</a></p><p><a href="https://ypigy.gitee.io/2021/03/01/%E5%85%AD%E3%80%81Vue%20Router%E5%85%A5%E9%97%A8/#URL" target="_blank" rel="noopener">HTTP格式的URL</a>，点击了解完整url的含义</p><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><p>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。<br>从层次的角度看，HTTP 是面向事务的 (transaction-oriented) 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 </p><h3 id="万维网的工作过程"><a href="#万维网的工作过程" class="headerlink" title="万维网的工作过程"></a>万维网的工作过程</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409073310895.png" alt="image-20210409073310895"></p><p>每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。<br>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接就被释放了。</p><blockquote><p>在浏览器和服务器之间的<strong>请求</strong>和<strong>响应</strong>的交互，必须按照规定的格式和遵循一定的规则。<strong>这些格式和规则就是超文本传送协议 HTTP</strong>。</p></blockquote><p>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME (MIME-like)”的响应组成。</p><p><strong>最后再强调一遍：HTTP 报文通常都使用 TCP 连接传送。</strong></p><h3 id="HTTP-的主要特点"><a href="#HTTP-的主要特点" class="headerlink" title="HTTP 的主要特点"></a>HTTP 的主要特点</h3><ol><li>HTTP 使用了<strong>面向连接的 TCP</strong> 作为运输层协议，保证了数据的可靠传输。</li><li>HTTP 协议本身也是<strong>无连接的</strong>，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>HTTP 是<strong>面向事务</strong>的客户服务器协议。</li><li>HTTP 1.0 协议是<strong>无状态</strong>的 (stateless)。</li></ol><p>下面我们通过三报文握手来了解http协议的工作</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409082643731.png" alt="image-20210409082643731"></p><p>通过图可以看到：http请求报文是作为第三次报文发送的，这时连接也建立好了，服务器就会将请求所需要的资源发送给客户端</p><p>这个过程过后，客户端接收到了资源后，便会断开tcp连接，然后下一次需要的时候继续建立连接，然后传递数据，而如果说现在你要请求一个包含很多资源（比如很多图片）的网页，那么客户端首先建立第一次tcp连接用于请求html页面，之后资源收到断开连接后又继续发起一次tcp连接，记住：http连接是无状态，也就意味着你每次建立连接都是全新的，耗时是一样的，且如果需要登录的话，会重复登陆，这次请求是一张图片，接下来还有其它资源，就要重复发起一次又一次的tcp连接，这样会很没有效率，如何解决这个问题呢 </p><h3 id="持续连接"><a href="#持续连接" class="headerlink" title="持续连接"></a>持续连接</h3><p><strong>HTTP/1.1 协议使用持续连接 (persistent connection)。</strong></p><p>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</p><p>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p><p>大部分主流浏览器默认用的就是持久连接</p><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p><strong>非流水线方式：</strong>客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</p><p>这和之前的应用层tcp停止等待协议类似，好比你妈叫你帮忙拿酱油，你屁颠屁颠跑去拿，然后递给妈妈，这时候妈妈又叫你帮忙拿盐，你又屁颠屁颠跑去拿盐，再回来递给妈妈，再然后，你妈又叫你……，就不能一次性说完吗，你愤怒的吼着，这不，你也会流水线方式嘛。</p><p><strong>流水线方式：</strong>客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。 </p><p>老妈一听，哦对吼，拿起一张小纸条，写下要拿的东西，笑眯眯（毫无内疚）的递给你：宝贝你辛苦了，然后你就又屁颠屁颠跑去把几样东西一起拿过来递给妈妈</p><p>好的，让我们再看一种情况，如果服务器那边的资源没有更新，而浏览器已经请求过一次服务器的资源了，这时候浏览器这边每次打开该网址都要发起一次tcp连接去重复请求资源，是不是同样浪费资源呢，可不可以把这些没有更改过的资源存起来呢</p><h3 id="代理服务器（高速缓存）"><a href="#代理服务器（高速缓存）" class="headerlink" title="代理服务器（高速缓存）"></a>代理服务器（高速缓存）</h3><p>当当当当，便是代理服务器啦</p><p>代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。</p><p>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</p><p>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。 </p><p>让我们来看一张图，在没有高速缓存的情况下，多台主机对资源发起请求</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409084722171.png" alt="image-20210409084722171"></p><p>那么这条链路上的时延会很大，因为所有万维网通信量都经过这条链路</p><p>那么，使用高速缓存呢</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085015793.png" alt="image-20210409085015793"></p><p>具体步骤为</p><p>(1) 浏览器访问互联网的服务器时，要先与校园网的高速缓存建立 TCP 连接，并向高速缓存发出 HTTP 请求报文。</p><p>(2) 若高速缓存已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。</p><p>(3) 否则，高速缓存就代表发出请求的用户浏览器，与互联网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085130673.png" alt="image-20210409085130673"></p><p>(4) 源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的高速缓存。</p><p>(5) 高速缓存收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085015793.png" alt="image-20210409085015793"></p><h3 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h3><p>既然客户端要发起请求，是不是要写个什么东西告诉服务器呢，当然要，你要东西你不得先说出来你要啥让被请求方知道嘛，服务器响应也同样要给予客户端响应的，那这个东西是什么</p><p>HTTP 有两类报文：<br><strong>请求报文</strong>——从客户向服务器发送请求报文。<br><strong>响应报文</strong>——从服务器到客户的回答。</p><p>由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p><p>先来看看请求报文的结构</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085755836.png" alt="image-20210409085755836"></p><p>报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。</p><ol><li><p>“方法”是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的操作，因此这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。 </p><p>点击<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE/#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">这里</a>查看请求方法</p></li><li><p>“URL”是所请求的资源的 URL。</p></li><li><p>“版本”是 HTTP 的版本。</p></li></ol><p>再来看看响应报文</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409090024473.png" alt="image-20210409090024473"></p><p>响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</p><ol><li>状态码都是三位数字，具体查看<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE/#%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">这里</a><ul><li>1xx 表示通知信息的，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ul></li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>万维网站点可以使用 Cookie 来跟踪用户。具体可以点击<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">这里</a></p><p>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 </p><h2 id="万维网的文档"><a href="#万维网的文档" class="headerlink" title="万维网的文档"></a>万维网的文档</h2><h3 id="超文本标记语言-HTML"><a href="#超文本标记语言-HTML" class="headerlink" title="超文本标记语言 HTML"></a>超文本标记语言 HTML</h3><blockquote><p>超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。</p><p>HTML 定义了许多用于排版的命令（即标签）。</p><p>HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。 </p></blockquote><p>仅当 HTML 文档是以 .html 或 .htm 为后缀时，浏览器才对此文档的各种标签进行解释。</p><p>如 HTML 文档改换以 .txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文本文件。</p><p>当浏览器从服务器读取 HTML 文档后，就按照 HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。详细了解html点击<a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML (Extensible Markup Language) 是可扩展标记语言，它和 HTML 很相似。</p><p>但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。</p><p>XML 不是要替换 HTML，而是对 HTML 的补充。</p><h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。</p><p>但 XHTML 是更严格的 HTML 版本，也是一个 W3C 标准（2000年1月），是作为一种 XML 应用被重新定义的 HTML，并将逐渐取代 HTML。</p><p>新的浏览器都支持 XHTML。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS (Cascading Style Sheets) 是层叠样式表，它是一种样式表语言，用于<a href="https://www.processon.com/view/link/60434587e401fd4f9cba7ccd" target="_blank" rel="noopener">为 HTML 文档定义布局</a>。</p><p>CSS 与 HTML 的区别就是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。</p><p>通俗的讲便是，html用于定义页面架构，而css则是决定这些</p><h3 id="动态万维网文档"><a href="#动态万维网文档" class="headerlink" title="动态万维网文档"></a>动态万维网文档</h3><p>当你在自己电脑上写了一个页面，不包括任何从服务器上请求过来的数据（比如使用AJAX），然后用浏览器打开看的时候，这个时候它便是一个静态页面，如果你把它放到服务器上，那么它也依然是静态页面，因为里面的数据不能也不会发生改变，它是一个死页面</p><p><strong>静态文档</strong>是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 </p><p><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。</p><p>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。 </p><p>那么，我们如何动态改变页面的显示数据呢，毕竟，一个新闻网站每天的新闻都是新的把，购物网站的商品每天也会推荐给你不同的吧，总不能一天写一个新页面放到服务器上吧</p><h3 id="万维网服务器功能的扩充"><a href="#万维网服务器功能的扩充" class="headerlink" title="万维网服务器功能的扩充"></a>万维网服务器功能的扩充</h3><ol><li><p>增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。</p></li><li><p>增加一个机制，用来使万维网服务器把浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409092216962.png" alt="image-20210409092216962"></p><p>就是如图所示：使用CGI来创建动态文档，那么CGI是啥</p><h3 id="CGI-程序"><a href="#CGI-程序" class="headerlink" title="CGI 程序"></a>CGI 程序</h3><p>CGI 程序的正式名字是 CGI 脚本 (script)。</p><p>“脚本”指的是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。</p><p>脚本运行起来要比一般的编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令），而不是直接被指令处理器来处理。 </p><h3 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h3><p>活动文档 (active document) 技术把所有的工作都转移给浏览器端。</p><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。</p><p>活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。<br>由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409093246471.png" alt="image-20210409093246471"></p><p>JAVA是活动文档技术的一部分，这里不展开，可自行百度</p><h2 id="万维网的信息检索系统"><a href="#万维网的信息检索系统" class="headerlink" title="万维网的信息检索系统"></a>万维网的信息检索系统</h2><p>在万维网中用来进行搜索的程序叫做搜索引擎。</p><h3 id="全文检索搜索"><a href="#全文检索搜索" class="headerlink" title="全文检索搜索"></a>全文检索搜索</h3><p>全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。</p><p>用户在查询时只要输入关键词，就从已经建立的索引数据库上进行查询（并不是实时地在互联网上检索到的信息）。</p><p>著名的有google、baidu 以及bing</p><h3 id="分类目录搜索"><a href="#分类目录搜索" class="headerlink" title="分类目录搜索"></a>分类目录搜索</h3><p><strong>分类目录搜索引擎</strong>并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。</p><p>分类目录搜索也叫做<strong>分类网站搜索</strong>。 </p><p>著名的有雅虎、新浪以及网易</p><h3 id="垂直搜索引擎"><a href="#垂直搜索引擎" class="headerlink" title="垂直搜索引擎"></a>垂直搜索引擎</h3><p><strong>垂直搜索引擎 (Vertical Search Engine)</strong> 针对某一特定领域、特定人群或某一特定需求提供搜索服务。<br>垂直搜索也是提供关键字来进行搜索的，但被放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。 </p><h2 id="博客和微博"><a href="#博客和微博" class="headerlink" title="博客和微博"></a>博客和微博</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>博客是万维网日志 (weblog) 的简称。也有人把 blog 进行音译，译为“部落格”，或“部落阁”。还有人用“博文”来表示“博客文章”。</p><p>Weblog 这个新词是 Jorn Barger 于 1997 年创造的。</p><p>简写的 blog（这是今天最常用的术语）则是 Peter Merholz 于 1999 年创造的。</p><p>有人把 blog 既当作名词，也当作动词，表示编辑博客或写博客。 </p><p>博客已经极大地扩充了互联网的应用和影响 。</p><p>在博客出现以前，网民是互联网上内容的消费者。</p><p>但博客改变了这种情况，网民不仅是互联网上内容的消费者，而且还是互联网上内容的生产者 。  </p><h3 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h3><p>没啥好说的，大部分人都在用，它和博客最大的区别就是，博客更像是一个个人网站，用来写一些比较大型的文章或技术内容，而微博更多则是分享自己的片段、碎语，三言两语</p><h2 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h2><p>社交网站 SNS (Social Networking Site) 是近年来发展非常迅速的一种网站，其作用是为一群拥有相同兴趣与活动的人创建在线社区</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h2><p>电子邮件 (e-mail)：指使用电子设备交换的邮件及其方法。电子邮件是互联网上使用得最多的和最受用户欢迎的一种应用。</p><p><strong>优点：</strong>使用方便，传递迅速，费用低廉，可以传送多种类型的信息（包括：文字信息，声音和图像等）。</p><p>电子邮件的重要标准包括以下部分</p><ol><li>简单邮件发送协议：SMTP</li><li>互联网文本报文格式</li><li>通用互联网邮件扩充 MIME</li><li>邮件读取协议：POP3 和 IMAP</li></ol><p>通过以下图片理解邮件通信的各个组成部分</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409100723015.png" alt="image-20210409100723015"></p><h3 id="用户代理-UA-User-Agent"><a href="#用户代理-UA-User-Agent" class="headerlink" title="用户代理 UA (User Agent)"></a>用户代理 UA (User Agent)</h3><p>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件。<br>用户代理的功能：撰写、显示、处理和通信。</p><p>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</p><p>邮件服务器按照客户 - 服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。</p><p>用户与电子邮件系统的接口。又被称为电子邮件客户端软件。</p><p>基本功能：撰写、显示、处理和通信。</p><h3 id="邮件服务器-Mail-Server"><a href="#邮件服务器-Mail-Server" class="headerlink" title="邮件服务器 (Mail Server)"></a>邮件服务器 (Mail Server)</h3><p>又被称为邮件传输代理。</p><p>功能：发送和接收邮件，同时还要向发信人报告邮件传送的情况。<br>按照客户 – 服务器方式工作。</p><p>在发送和读取邮件时使用两个不同的协议：SMTP，POP3。</p><h3 id="邮件发送和读取协议"><a href="#邮件发送和读取协议" class="headerlink" title="邮件发送和读取协议"></a>邮件发送和读取协议</h3><p>邮件发送和读取使用不同的协议协议。</p><ol><li><p>简单邮件发送协议 SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。</p></li><li><p>邮局协议 POP3：用于用户代理从邮件服务器读取邮件。</p></li></ol><p>通信双发既可以是客户也可以是服务器，当你是写信方时，你便是客户，收信方是服务器，放过来便是相反，对方是客户，你是服务器</p><p>还要注意的是：<strong>SMTP和POP3（或IMAP）都是使用TCP连接来传送邮件的，目的是为了可靠地传送邮件。</strong></p><p>仔细观察下面的图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409101409058.png" alt="image-20210409101409058"></p><p>发送方发送邮件是通过一条跨越互联网的线过去到达服务器端端，所以请注意：<strong>邮件不会在互联网中的某个中间邮件服务器落地</strong></p><p>发送方是通过“推（push）”的方式讲邮件发送出去，而接收方则是通过“拉（pull）”的方式接收邮件的</p><h3 id="发送和接收电子邮件的几个重要步骤"><a href="#发送和接收电子邮件的几个重要步骤" class="headerlink" title="发送和接收电子邮件的几个重要步骤"></a>发送和接收电子邮件的几个重要步骤</h3><ol><li>发件人调用 PC 中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器。</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。 </li><li>运行在接收方邮件服务器中的SMTP服务器进 程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 </li><li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3（或 IMAP）协议读取发送给自己的邮件。 </li></ol><h3 id="电子邮件的组成"><a href="#电子邮件的组成" class="headerlink" title="电子邮件的组成"></a>电子邮件的组成</h3><p>电子邮件由信封 (envelope) 和内容 (content) 两部分组成。</p><p>电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容。</p><p>在邮件的信封上，最重要的就是收件人的地址。 </p><h4 id="电子邮件地址的格式"><a href="#电子邮件地址的格式" class="headerlink" title="电子邮件地址的格式"></a>电子邮件地址的格式</h4><blockquote><p>收件人邮箱名@邮箱所在主机的域名      </p></blockquote><p>这便是TCP/IP 体系的电子邮件系统规定电子邮件地址的格式</p><p>符号“@”读作“at”，表示“在”的意思。<br>例如电子邮件地址 <a href="mailto:xiexiren@tsinghua.org.cn">xiexiren@tsinghua.org.cn</a></p><p>这里要注意两点</p><ol><li><p>这个用户名（ xiexiren）在该域名的范围内是唯一的。 </p></li><li><p>邮箱所在的主机的域名（tsinghua.org.cn）在全世界必须是唯一的 </p></li></ol><h2 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h2><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409100723015.png" alt="image-20210409100723015"></p><p>SMTP 规定了在两个相互通信的 SMTP 进程交换信息的方法。</p><p>SMTP 使用客户–服务器方式。</p><p>SMTP 基于 TCP 实现客户与服务器的通信。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102248512.png" alt="image-20210409102248512"></p><p>SMTP 是一个基于文本的 （即 ASCII 码） 的协议。 </p><p>SMTP 客户与服务器之间采用命令-响应方式进行交互。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102308510.png" alt="image-20210409102308510"></p><p>SMTP 基于 TCP 实现客户与服务器之间的通信。</p><h3 id="SMTP-通信的三个阶段"><a href="#SMTP-通信的三个阶段" class="headerlink" title="SMTP 通信的三个阶段"></a>SMTP 通信的三个阶段</h3><p><strong>连接建立：</strong>连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。   </p><p><strong>邮件传送</strong></p><p><strong>连接释放：</strong>邮件发送完毕后，SMTP 应释放 TCP 连接。 </p><p>通过图来理解这个过程（这个过程其实和http协议进行通信有点类似）</p><ol><li><p>首先是建立连接用于传送邮件</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102449163.png" alt="image-20210409102449163"></p></li><li><p>接着就是传送邮件了</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102751440.png" alt="image-20210409102751440"></p></li><li><p>然后就是邮件传送完，连接释放</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102825471.png" alt="image-20210409102825471"></p></li></ol><h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p>一个电子邮件分为信封和内容两大部分。</p><p>RFC 5322 只规定了邮件内容中的首部 (header) 格式，而对邮件的主体 (body) 部分则让用户自由撰写。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103109432.png" alt="image-20210409103109432"></p><p>对图中各个名词进行解释</p><ol><li>“To:” 后面填入一个或多个收件人的电子邮件地址。用户只需打开地址簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。</li><li>“Subject:” 是邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。</li><li>“Cc:”  表示应给某某人发送一个邮件副本。</li><li>“From” 和 “Date” 表示发信人的电子邮件地址和发信日期。</li><li>“Reply-To” 是对方回信所用的地址。 </li></ol><h2 id="邮件读取协议-POP3-和-IMAP"><a href="#邮件读取协议-POP3-和-IMAP" class="headerlink" title="邮件读取协议 POP3 和 IMAP"></a>邮件读取协议 POP3 和 IMAP</h2><p>正如标题：现在有两个常用的邮件读取协议：</p><ol><li>POP3：邮局协议 (Post Office Protocol) 第3个版本 </li><li>IMAP：网际报文存取协议 (Internet Message Access Protocol)</li></ol><p>首先了解下POP3协议</p><h3 id="POP3-协议"><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h3><p>POP3 使用客户–服务器方式。</p><p>POP3 基于TCP实现客户与服务器的通信。</p><p>POP3 支持用户鉴别。</p><p><strong>POP3 服务器会删除被用户读取了的邮件。</strong>（也就是阅完即焚）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103251660.png" alt="image-20210409103251660"></p><h3 id="IMAP-协议"><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h3><p>IMAP 使用客户–服务器方式。</p><p>IMAP 基于TCP实现客户与服务器的通信。</p><p>IMAP是一个联机协议。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103428001.png" alt="image-20210409103428001"></p><p>IMAP的特点如下</p><ol><li>连接后只下载<strong>邮件首部</strong>（部分下载）。</li><li>用户直接在IMAP服务器上创建和管理文件夹。</li><li>用户可以<strong>搜索</strong>邮件内容。</li><li>用户可以在不同的地方使用不同的计算机<strong>随时</strong>上网阅读和处理自己的邮件。</li><li>允许收信人只读取邮件中的<strong>某一个部分</strong>。</li><li><strong>缺点：</strong>要想查阅邮件，必须先联网。</li></ol><h3 id="IMAP-与-POP3-比较"><a href="#IMAP-与-POP3-比较" class="headerlink" title="IMAP 与 POP3 比较"></a>IMAP 与 POP3 比较</h3><table><thead><tr><th>操作位置</th><th>操作内容</th><th>IMAP</th><th>POP3</th></tr></thead><tbody><tr><td>收件箱</td><td>阅读、标记、移动、删除邮件等</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>发件箱</td><td>保存到已发送</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>创建文件夹</td><td>新建自定义的文件夹</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>草稿</td><td>保存草稿</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>垃圾文件夹</td><td>接收并移入垃圾文件夹的邮件</td><td>支持</td><td>不支持</td></tr><tr><td>广告邮件</td><td>接收并移入广告邮件夹的邮</td><td>支持</td><td>不支持</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104202426.png" alt="image-20210409104202426"></p><p>这里要好好区别，邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 完全不同。</p><p>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。<br>而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 </p><p>简单来说：发邮件是用<strong>SMTP</strong>协议，而收文件是在<strong>pop3</strong>和<strong>imap</strong>协议中挑一个去收</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104425895.png" alt="image-20210409104425895"></p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p>用户代理 (UA) 的缺点：必须在计算机中安装用户代理软件可能不能安装或不允许安装。所以会导致不方便收邮件，而且，很重要的是，你要收发文件，两个人都要开着电脑，啊这……</p><p>而这时候通过之前学的万维网以及http协议，我们是否可以把这个平台搬到互联网上呢，答案是可以的，你现在的用的邮箱不就是吗，所以，万维网电子邮件的优点是啥</p><ul><li>不需要在计算机中再安装用户代理软件。</li><li>计算机能联网，就能非常方便地收发电子邮件。</li><li>电子邮件界面非常友好。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104824166.png" alt="image-20210409104824166"></p><p>通过图可以了解到其有两个特点</p><ol><li>发送、接收电子邮件时使用 HTTP 协议。</li><li>两个邮件服务器之间传送邮件时使用 SMTP。</li></ol><p>好的，互联网解决了我们之间的电子邮件交流，现在另一个问题来了，我们使用的SMTP协议好像没法发图片或者其他多媒体文件（SMTP 不能传送可执行文件或其他的二进制对象。），这咋整，我想发鸭，而且还有一个问题：SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。甚至还存在这个问题：SMTP 服务器会拒绝超过一定长度的邮件。那怎么解决呢</p><h2 id="通用互联网邮件扩充-MIME"><a href="#通用互联网邮件扩充-MIME" class="headerlink" title="通用互联网邮件扩充 MIME"></a>通用互联网邮件扩充 MIME</h2><p>对的，就是它，它可以帮我们解决上面遇到的问题，那是不是意味着就可以直接用他来取代SMTP呢，并不是这样的</p><p>MIME 的意图<strong>是继续使用目前的 [RFC 822] 格式</strong>，但<strong>增加了邮件主体的结构</strong>，并<strong>定义了传送非 ASCII 码的编码规则</strong>。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409105253804.png" alt="image-20210409105253804"></p><p>它主要包括三个部分</p><ol><li><p><strong>5 个新的邮件首部字段</strong>，它们可包含在原有首部中。这些字段提供了有关邮件主体的信息。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409105407947.png" alt="MIME首部"></p></li><li><p>定义了许多<strong>邮件内容的格式</strong>，对多媒体电子邮件的表示方法进行了标准化。</p></li><li><p>定义了<strong>传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变。</p><table><thead><tr><th>编码方法</th><th>说明</th></tr></thead><tbody><tr><td>7bit</td><td>7  位  ASCII  编码，每行不能超过  1000  个字符（包括回车和换行）。缺省编码方法。</td></tr><tr><td>8bit</td><td>8  位非  ASCII  编码，每行不能超过  1000  个字节（包括回车和换行）。</td></tr><tr><td>Binary</td><td>8  位非  ASCII  编码，任意长度的字节串。</td></tr><tr><td>Base64</td><td>将任意长度的字节串转换为用 7 位  ASCII 编码表示的字符串。可用于二进制和非文本数据的编码。</td></tr><tr><td>Quoted-printable</td><td>将任意长度的字节串转换为  ASCII  编码表示的字符串。可用于二进制和非文本数据的编码。</td></tr></tbody></table></li></ol><p>这里对各个编码方法就不继续展开了，详细可以通过书本理解</p><h3 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h3><p>MIME 着标准规定 Content-Type 说明必须含有两个标识符，即内容类型(type)和子类型(subtype)，中间用“/”分开。 </p><p>MIME 标准原先定义了 7 个基本内容类型和 15 种子类型。</p><p>MIME允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X-开始。</p><table><thead><tr><th>内容类型</th><th>子类型举例</th><th>说明</th></tr></thead><tbody><tr><td>text（文本）</td><td>plain, html, xml, css</td><td>不同格式的文本</td></tr><tr><td>image（图像）</td><td>gif, jpeg, tiff</td><td>不同格式的静止图像</td></tr><tr><td>audio（音频）</td><td>basic, mpeg, mp4</td><td>可听见的声音</td></tr><tr><td>video（视频）</td><td>mpeg, mp4, quicktime</td><td>不同格式的影片</td></tr><tr><td>model（模型）</td><td>vrml</td><td>3D模型</td></tr><tr><td>application（应用）</td><td>octet-stream, pdf,  javascript, zip</td><td>不同应用程序产生的数据</td></tr><tr><td>message（报文）</td><td>http, rfc822</td><td>封装的报文</td></tr><tr><td>multipart（多部分）</td><td>mixed, alternative, parallel, digest</td><td>多种类型的组合</td></tr></tbody></table><p>举个例子</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409110200263.png" alt="image-20210409110200263"></p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。</p><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><p>DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</p><p>步骤大致如下</p><ol><li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。</p><p>为什么要广播，因为这时候A并不知道DHCP服务器是哪一台，所以全都发，而此时它并没有IP地址，所以这个报文的源地址也都会是0</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111807042.png" alt="image-20210409111807042"></p></li><li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p></li><li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。</p><ul><li>若找到，则返回找到的信息。</li><li>若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111829348.png" alt="image-20210409111829348"></p></li></ol><p>并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。</p><p>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111903379.png" alt="image-20210409111903379"></p><h2 id="租用期-lease-period"><a href="#租用期-lease-period" class="headerlink" title="租用期 (lease period)"></a>租用期 (lease period)</h2><p>DHCP 服务器分配给 DHCP 客户的 IP 地址的<strong>临时的</strong>，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>。<br>租用期的数值应由 DHCP 服务器自己决定。<br>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。 </p><p>不是很理解为啥要租用，不能分配好了就一直用吗，可能是因为怕使用了该ip地址的主机很久不用导致ip地址浪费吧</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409112048314.png" alt="image-20210409112048314"></p><p>梳理图中的过程</p><ol><li><p>DHCP 服务器被动打开 UDP 端口 67， 等待客户端发来的报文。</p></li><li><p>DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文 DHCPDISCOVER。</p></li><li><p>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文 DHCPOFFER，因此，DHCP 客户可能收到多个 DHCP 提供报文 。</p></li><li><p>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文 DHCPREQUEST。</p></li><li><p>被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。</p><p>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</p></li><li><p>租用期过了一半（T1 时间到），DHCP 客户发送请求报文 DHCPREQUEST，要求更新租用期。 </p></li><li><p>DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。</p></li><li><p>DHCP 服务器若不同意，则发回否认报 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤  ❷）。</p><p>若 DHCP 服务器不响应步骤  ❻ 的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤  ❻），然后又继续后面的步骤。 </p></li><li><p>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</p></li></ol><h1 id="简单网络管理协议-SNMP"><a href="#简单网络管理协议-SNMP" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。</p></blockquote><p>网络管理并不是指对网络进行行政上的管理。网络管理分为五大功能</p><ol><li>故障管理：故障检测、隔离和纠正。</li><li>配置管理：初始化网络、并配置网络。</li><li>计费管理：记录网络资源的使用。</li><li>性能管理：估价系统资源的运行状况及通信效率等。</li><li>网络安全管理：对授权机制、访问控制、加密和加密关键字的管理。</li></ol><p>网络管理长这样的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409113609272.png" alt="image-20210409113609272"></p><ul><li>管理站也常称为网络运行中心 NOC (Network Operations Center)，是网络管理系统的核心。</li><li>管理程序在运行时就成为管理进程。</li><li>管理站（硬件）或管理程序（软件）都可称为管理者(manager)。Manager 不是指人，而是指机器或软件。</li><li>网络管理员 (administrator) 指的是负责网络管理的人员。</li><li>大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li><li>被管对象<ul><li>网络的每一个被管设备中可能有多个被管对象。</li><li>被管设备有时可称为网络元素或网元。</li><li>在被管设备中也会有一些不能被管的对象。 </li></ul></li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运行着的程序叫做网络管理代理程序，或简称为代理。</p><p>代理程序在管理程序的命令和控制下在被管设备上采取本地的行动。</p><h3 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h3><p>网络管理协议简称为网管协议。</p><p>网络管理协议是管理程序和代理程序之间进行通信的规则。</p><p>网络管理员利用网络管理协议，通过管理站对网络中的被管设备进行管理。 </p><p>需要注意的是，网管协议本身不管理网络。</p><h3 id="简单网络管理协议-SNMP-1"><a href="#简单网络管理协议-SNMP-1" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h3><p>简单网络管理协议SNMP (Simple Network Management Protocol) 中的管理程序和代理程序按客户–服务器方式工作。</p><p>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。</p><p>在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。</p><h4 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h4><ul><li>SNMP 最重要的指导思想就是要尽可能简单。</li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。</li><li>在网络正常工作时，SNMP 可实现统计、配置、和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>虽然 SNMP 是在 TCP/IP 基础上的网络管理协议，但也可扩展到其他类型的网络设备上。 </li></ul><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol><li>监视网络性能</li><li>检测分析网络差错</li><li>配置网络设备等。</li></ol><h3 id="委托代理"><a href="#委托代理" class="headerlink" title="委托代理"></a>委托代理</h3><p>整个系统必须有一个管理站。</p><p>若网络元素使用的不是 SNMP 而是另一种网络管理协议，SNMP 协议就无法控制该网络元素。这时可使用委托代理 (proxy agent)。</p><p>委托代理能提供协议转换和过滤操作等功能，对被管对象进行管理。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409114208398.png" alt="image-20210409114208398"></p><h3 id="SNMP-的网络管理组成"><a href="#SNMP-的网络管理组成" class="headerlink" title="SNMP 的网络管理组成"></a>SNMP 的网络管理组成</h3><ol><li>SNMP 本身</li><li>管理信息结构 SMI (Structure of Management Information)</li><li>管理信息库 MIB (Management Information Base)。</li></ol><h2 id="管理信息结构-SMI"><a href="#管理信息结构-SMI" class="headerlink" title="管理信息结构 SMI"></a>管理信息结构 SMI</h2><blockquote><p>功能：</p><ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。 </li></ol></blockquote><p>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义的无二义性。但从 SMI 的名称并不能看出它的功能。SMI 并不定义一个实体应管理的对象数目，也不定义被管对象名以及对象名及其值之间的关联。 </p><p>首先从第一个功能，被管对象的命名上来讲</p><h3 id="被管对象命名"><a href="#被管对象命名" class="headerlink" title="被管对象命名"></a>被管对象命名</h3><p><strong>SMI 规定所有被管对象必须在命名树上</strong>，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411101957301.png" alt="image-20210411101957301"></p><p>SMI 标准指明：所有的 MIB 变量必须使用抽象语法记法 1（ASN.1）来定义。<br>SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。<br>ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102208973.png" alt="image-20210411102208973"></p><p>SMI 把数据类型分为两大类（如下图）：</p><ol><li>简单类型</li><li>结构化类型。 </li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102306749.png" alt="image-20210411102306749"></p><h3 id="基本编码规则-BER"><a href="#基本编码规则-BER" class="headerlink" title="基本编码规则 BER"></a>基本编码规则 BER</h3><p>ISO 在制订 ASN.1 语言的同时也为它定义了一种标准的编码方案，即基本编码规则 BER (Basic Encoding Rule)。<br>BER 指明了每种数据类型中每个数据的值的表示。<br>发送端用 BER 编码，可将用 ASN.1 所表述的报文转换成唯一的比特序列。<br>接收端用 BER 进行解码，得到该比特序列所表示的 ASN.1 报文。 </p><p> ASN.1把所有的数据元素都表示为T-L-V三个字段的组成的序列，T字段定义数据的类型，L字段定义V字段的长度，V字段定义数据值</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102353190.png" alt="image-20210411102353190"></p><p><strong>TLV 中的 T 字段定义数据的类型</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102504033.png" alt="image-20210411102504033"></p><p><strong>L 字段定义 V 字段的长度</strong></p><p>单字节的L字段第一位为0，后续七位定义V字段的长度</p><p>当L字段为多字节时，其最高为时1，后面七位定义后续字节的字节数（二进制整数表示），这时，所有后续字节并置起来的二进制整数定义V字段的长度</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102742467.png" alt="image-20210411102742467"></p><p><strong>V 字段定义数据的值</strong></p><table><thead><tr><th>类   型</th><th>大   小</th><th>说      明</th></tr></thead><tbody><tr><td>INTEGER</td><td>4 字节</td><td>在 –231 到  231  – 1  之间的整数</td></tr><tr><td>Interger32</td><td>4 字节</td><td>和 INTEGER  相同</td></tr><tr><td>Unsigned32</td><td>4 字节</td><td>在 0  到  232  – 1  之间的无符号数</td></tr><tr><td>OCTET  STRING</td><td>可变</td><td>不超过  65535 字节长的字节串</td></tr><tr><td>OBJECT  IDENTIFIER</td><td>可变</td><td>对象标识符</td></tr><tr><td>IPAddress</td><td>4 字节</td><td>由 4  个整数组成的IP地址</td></tr><tr><td>Counter32</td><td>4 字节</td><td>可从  0 增加到 232 的整数；当它到达最大值时就返回到  0</td></tr><tr><td>TimeTicks</td><td>4 字节</td><td>记录时间的计数值，以  1/100 秒为单位</td></tr><tr><td>BITS</td><td>—</td><td>比特串</td></tr><tr><td>Opaque</td><td>可变</td><td>不解释的串</td></tr></tbody></table><p>例如，INTEGER 15，其 T 字段是02， INTEGER 类型要用 4 字节编码。最后得出 TLV 编码为 02 04 00 00 00 0F。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104028469.png" alt="image-20210411104028469"></p><p> V 字段<strong>可嵌套</strong>其他数据元素的 TLV 字段</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411103814658.png" alt="image-20210411103814658"></p><h2 id="管理信息库-MIB"><a href="#管理信息库-MIB" class="headerlink" title="管理信息库 MIB"></a>管理信息库 MIB</h2><p>被管对象必须维持可供管理程序读写的若干控制和状态信息。这些信息总称为管理信息库  MIB (Management Information Base) 。<br>管理程序使用 MIB 中这些信息的值对网络进行管理（如读取或重新设置这些值）。<br>只有在 MIB 中的对象才是 SNMP 所能够管理的。</p><p><strong>节点 mib-2 所包含的信息类别举例</strong></p><table><thead><tr><th>类  别</th><th>标 号</th><th>所包含的信息</th></tr></thead><tbody><tr><td>system</td><td>(1)</td><td>主机或路由器的操作系统</td></tr><tr><td>interfaces</td><td>(2)</td><td>各种网络接口</td></tr><tr><td>address  translation</td><td>(3)</td><td>地址转换（例如，ARP 映射）</td></tr><tr><td>ip</td><td>(4)</td><td>IP 软件</td></tr><tr><td>icmp</td><td>(5)</td><td>ICMP  软件</td></tr><tr><td>tcp</td><td>(6)</td><td>TCP  软件</td></tr><tr><td>udp</td><td>(7)</td><td>UDP  软件</td></tr><tr><td>egp</td><td>(8)</td><td>EGP  软件</td></tr></tbody></table><p>MIB <strong>变量的例子</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104236265.png" alt="image-20210411104236265"></p><h2 id="SNMP-的协议数据单元和报文"><a href="#SNMP-的协议数据单元和报文" class="headerlink" title="SNMP 的协议数据单元和报文"></a>SNMP 的协议数据单元和报文</h2><p>SNMP 的操作只有两种基本的管理功能：</p><ol><li>“读”操作，用 get 报文来检测各被管对象的状况；</li><li>“写”操作，用 set 报文来改变各被管对象的状况。</li></ol><p>SNMP 的这些功能通过探询操作来实现。</p><h3 id="探寻操作"><a href="#探寻操作" class="headerlink" title="探寻操作"></a>探寻操作</h3><blockquote><p>探询操作 —— SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p></blockquote><p>探询的好处：</p><ol><li>可使系统相对简单。</li><li>能限制通过网络所产生的管理信息的通信量。</li></ol><p>探询的缺点：</p><ol><li>不够灵活，而且所能管理的设备数目不能太多。</li><li>开销也较大。</li></ol><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p><strong>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。</strong></p><p>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件（即过滤）。</p><p>过滤的好处是：</p><ol><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。 </li></ol><p>使用探询（至少是周期性地）以维持对网络资源的实时监视。<br>同时也采用陷阱机制报告特殊事件，使得 SNMP 成为一种有效的网络管理协议。 </p><h3 id="SNMP-使用无连接的-UDP"><a href="#SNMP-使用无连接的-UDP" class="headerlink" title="SNMP 使用无连接的 UDP"></a>SNMP 使用无连接的 UDP</h3><p>SNMP 使用无连接的 UDP。但 UDP 不保证可靠交付。</p><p>在运行代理程序的服务器端用熟知端口 161 来接收 get 或 set 报文和发送响应报文（与熟知端口通信的客户端使用临时端口）。<br>运行管理程序的客户端则使用熟知端口 162 来接收来自各代理的 trap 报文。 </p><h3 id="SNMPv1-定义的协议数据单元-PDU-类型"><a href="#SNMPv1-定义的协议数据单元-PDU-类型" class="headerlink" title="SNMPv1 定义的协议数据单元 (PDU) 类型"></a>SNMPv1 定义的协议数据单元 (PDU) 类型</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104738807.png" alt="image-20210411104738807"></p><h3 id="SNMP-的报文格式"><a href="#SNMP-的报文格式" class="headerlink" title="SNMP 的报文格式"></a>SNMP 的报文格式</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104820927.png" alt="image-20210411104820927"></p><h3 id="Get-request-报文-ASN-1-编码"><a href="#Get-request-报文-ASN-1-编码" class="headerlink" title="Get-request 报文 ASN.1 编码"></a>Get-request 报文 ASN.1 编码</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104856701.png" alt="image-20210411104856701"></p><p>ASN.1 定义</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104933471.png" alt="image-20210411104933471"></p><h3 id="Get-request-报文的-BER-编码"><a href="#Get-request-报文的-BER-编码" class="headerlink" title="Get-request 报文的 BER 编码"></a>Get-request 报文的 BER 编码</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104957973.png" alt="image-20210411104957973"></p><p>BER 编码</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411105021274.png" alt="image-20210411105021274"></p><h1 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h1><h2 id="系统调用和应用编程接口"><a href="#系统调用和应用编程接口" class="headerlink" title="系统调用和应用编程接口"></a>系统调用和应用编程接口</h2><p>大多数操作系统使用系统调用 (system call ) 的机制在应用程序和操作系统之间传递控制权。</p><p>对程序员来说，每一个系统调用和一般程序设计中的函数调用非常相似，只是系统调用是<strong>将控制权传递给了操作系统</strong>。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409144949026.png" alt="image-20210409144949026"></p><h3 id="应用编程接口-API"><a href="#应用编程接口-API" class="headerlink" title="应用编程接口 API"></a>应用编程接口 API</h3><p>系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。</p><p>使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API (Application Programming Interface) 。</p><h2 id="几种常用的系统调用"><a href="#几种常用的系统调用" class="headerlink" title="几种常用的系统调用"></a>几种常用的系统调用</h2><p>Berkeley UNIX 操作系统定义了一种 API，它又称为<strong>套接字接口 (socket interface)</strong>。</p><p>微软公司在其操作系统中采用了套接字接口  API，形成了一个稍有不同的 API，并称之为  Windows Socket。</p><p>AT&amp;T 为其 UNIX 系统 V 定义了一种 API，简写为 TLI (Transport Layer Interface)。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409145218013.png" alt="image-20210409145218013"></p><h3 id="套接字特点及使用"><a href="#套接字特点及使用" class="headerlink" title="套接字特点及使用"></a>套接字特点及使用</h3><p>当应用进程需要使用网络进行通信时就发出系统调用，请求操作系统为其创建“套接字”，以便把网络通信所需要的系统资源分配给该应用进程。</p><p>操作系统为这些资源的总和用一个叫做套接字描述符的号码来表示。</p><p>应用进程所进行的网络操作都必须使用这个套接字描述符。<br>通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该套接字描述符相关的所有资源。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409145449361.png" alt="image-20210409145449361"></p><p>下面来讲一下如何通过套接字来调用TCP 提供面向连接的服务</p><p>总共分为三个阶段，和运输层的tcp三报文握手类似，结合图理解该过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409151143953.png" alt="image-20210409151143953"></p><ol><li><p><strong>连接建立阶段</strong></p><p>当套接字被创建后，它的端口号和 IP 地址都是空的，因此应用进程要<strong>调用 bind</strong>（绑定）来指明套接字的本地地址。在服务器端调用 bind 时就是把熟知端口号和本地 IP 地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接字。</p><p>服务器在调用 bind 后，还必须<strong>调用 listen</strong>（收听）把套接字设置为被动方式，以便随时接受客户的服务请求。<strong>UDP 服务器由于只提供无连接服务，不使用 listen 系统调用。</strong></p><p>服务器紧接着就<strong>调用 accept（接受）</strong>，以便把远地客户进程发来的连接请求提取出来。系统调用 accept 的一个变量就是要指明从哪一个套接字发起的连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409151632523.png" alt="image-20210409151632523"></p></li><li><p><strong>数据传送阶段</strong></p><p>客户和服务器都在 TCP 连接上使用 <strong>send 系统调用传送数据</strong>，使用 <strong>recv 系统调用接收数据</strong>。</p><p>通常客户使用 send 发送请求，而服务器使用 send 发送回答。<br>服务器使用 recv 接收客户用 send 调用发送的请求。客户在发完请求后用 recv 接收回答。</p></li><li><p><strong>连接释放阶段</strong></p><p>一旦客户或服务器结束使用套接字，就把套接字撤消。这时就调用 <strong>close 释放连接</strong>和<strong>撤销套接字</strong>。</p></li></ol><h1 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h1><h2 id="具有集中目录服务器的-P2P-工作方式"><a href="#具有集中目录服务器的-P2P-工作方式" class="headerlink" title="具有集中目录服务器的 P2P 工作方式"></a>具有集中目录服务器的 P2P 工作方式</h2><p>在 P2P 工作方式下，所有的音频/视频文件都是在普通的互联网用户之间传输。</p><p>这种工作方式解决了集中式媒体服务器可能出现的瓶颈问题。</p><p>在互联网流量中，P2P 工作方式下的文件分发已占据了最大的份额，比万维网应用所占的比例大得多</p><p>世界上最早使用P2P方式的是<strong>Napster</strong>，Napster 将所有音乐文件的索引信息都集中存放在 Napster 目录服务器中。使用者只要查找目录服务器，就可知道应从何处下载所要的MP3文件。用户要及时向 Napster 的目录服务器报告自己存有的音乐文件。Napster 的文件传输是分散的，文件的定位则是集中的。</p><p>让我们通过一张图理解该过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409155704154.png" alt="image-20210409155704154"></p><ol><li>用户 X 向 Napster 目录服务器查询（客户–服务器方式）谁有音乐文件 MP3#。</li><li>Napster 目录服务器回答 X：有三个地点有文件 MP3#，即 A, B 和 C（给出了这三个地点的IP地址）。于是用户 X 得知所需的文件 MP3# 的三个下载地点。</li><li>用户 X 可以随机地选择三个地点中的任一个。假定 X 向 A 发送下载文件 MP3#的请求报文。双方都使用 P2P 方式通信。</li><li>对等方A（现在作为服务器）把文件MP3#发送给X。</li></ol><p><strong>集中式目录服务器同样也存在问题：可靠性差。会成为性能的瓶颈。</strong></p><h2 id="具有全分布式结构的-P2P-文件共享程序"><a href="#具有全分布式结构的-P2P-文件共享程序" class="headerlink" title="具有全分布式结构的 P2P 文件共享程序"></a>具有全分布式结构的 P2P 文件共享程序</h2><h3 id="Gnutella"><a href="#Gnutella" class="headerlink" title="Gnutella"></a>Gnutella</h3><p>Gnutella 是第二代 P2P 文件共享程序，采用<strong>全分布方法</strong>定位内容的 P2P 文件共享应用程序。 </p><p>Gnutella 与 Napster 最大的区别是：不使用集中式的目录服务器，而是使用<strong>洪泛法</strong>在大量 Gnutella <strong>用户之间进行查询</strong>。</p><p>为了不使查询的通信量过大，Gnutella 设计了一种<strong>有限范围的洪泛查询</strong>，以减少<strong>倾注到互联网的查询流量</strong>，但也<strong>影响到查询定位的准确性</strong>。 </p><h3 id="eMule"><a href="#eMule" class="headerlink" title="eMule"></a>eMule</h3><p>eMule 使用了一些服务器。这些服务器并不是保存音频/视频文件，而是保存用户的有关信息，因而可以告诉用户从哪些地方可以下载到所需的文件。</p><p>eMule 使用了专门定义的文件夹，让用户存放可以和其他用户共享的文件。</p><p>eMule 的下载文件规则是鼓励用户向其他用户上传文件。用户上传文件越多，其下载文件的优先级就越高（因而下载就越快）。</p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 所有对等方集合称为一个洪流 (torrent)，下载文件的数据单元为长度固定的文件块 (chunk)。基础设施结点，叫做追踪器 (tracker)。</p><p>A 就和这些对等方建立了 TCP 连接。所有与 A 建立了 TCP 连接的对等方为“相邻对等方”(neighboring peers)。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161511009.png" alt="image-20210409161511009"></p><p>在请求的过程中，A 使用最稀有的优先 (rarest first) 的技术，首先向其相邻对等方请求对应的文件块。<br>所谓稀有是指：如果A所缺少的文件块在相邻对等方中的副本很少，那就是“很稀有的”。</p><p>而当很多对等方需要请求文件块时，A如何决定先向谁提供呢？<br>凡当前以最高数据率向 A 传送文件块的某相邻对等方，A 就优先把所请求的文件块传送给该相邻对等方（原来计算机也这么现实）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161524959.png" alt="image-20210409161524959"></p><p>从互联网传送数据到主机，叫做<strong>下载 (download)</strong>，从主机向互联网传送，则称为<strong>上传 (upload) 或上载</strong>。</p><h2 id="P2P-文件分发的分析"><a href="#P2P-文件分发的分析" class="headerlink" title="P2P 文件分发的分析"></a>P2P 文件分发的分析</h2><p>让我们来分析下传统的客户-服务器方式下进行数据请求的过程（结合图中的变量名）</p><p>有 N 台主机从服务器下载一个大文件，其长度为 F bit。假定主机与互联网连接的链路的上传速率和下载速率分别为 ui 和 di ，单位都是 bit/s。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161917270.png" alt="image-20210409161917270"></p><p>从服务器端考虑，所有主机分发完毕的最短时间 Tcs 不可能小于 NF/us （每次都要建立连接）；<br>下载速率最慢的主机的下载速率为 dmin，则 Tcs 不可能小于 F/dmin  。<br>由此可得出所有主机都下载完文件 F 的最少时间是：</p><blockquote><p>Tcs = max（ NF/us，F/dmin ）</p></blockquote><p>而在P2P下的最短时间呢</p><p>初始服务器文件分发的最少时间不可能小于 F/us （只需要上传一次）；<br>下载文件分发的最少时间不可能小于 F/dmin ；<br>上载文件分发的最少时间不可能小于 NF/uT ，其中是 uT  是上传速率之和。<br>所有主机都下载完文件 F 的最少时间的下限是：<br>Tp2p &gt;= max（ F/us ， F/dmin， NF/uT  ）</p><p><strong>举个栗子比较一下</strong>（好吧其实书里这个例子我没法理解，0.75怎么得出来的搞不懂）</p><p>设所有的对等方的上传速率都是 u，并且 F/u = 1 小时。<br>设服务器的上传速率 us = 10u。<br>当 N = 30 时，<br>P2P方式：最少时间的下限是 0.75 小时 &lt; 1 小时（不管 N 多大）。<br>客户−服务器方式：最少时间是 3 小时。</p><p>看不懂？那就对了，我也看不懂（大佬给我走开），反正我就这样理解，如果采用传统的客户-服务器模式传输文件，那么你有几个主机需要文件，你就要和服务器建立几次连接，然后服务器上传文件，接着将服务器资源平均分给多台主机，然后传文件，而P2P则是服务器可以先传给一台（当然也可以多台），这时候服务器所有资源都可以给这一台主机（效率提高）单独传文件，然后服务器记录一下这台主机有这个资源，接着这台得到文件的主机可以通过服务器介绍和另外一台主机进行点对点连接传输文件，同时，服务器也可以继续和另一台传文件，如此下去，1变2，2变4，4变8，指数传递，效率提高，速度变快，服务器压力变小，一举多得啊。</p><h2 id="在-P2P-对等方中搜索对象"><a href="#在-P2P-对等方中搜索对象" class="headerlink" title="在 P2P 对等方中搜索对象"></a>在 P2P 对等方中搜索对象</h2><p>在前面我们知道：Napster在一个集中式目录服务器中构建的查找数据库虽然很简单，但性能上却有瓶颈。</p><p>Gnutella是一种采用全分布方法定位内容的P2P文件共享应用程序，它解决了集中式目录服务器所造成的瓶颈问题。然而Gnutella是在非结构化的覆盖网络中采用查询洪泛的方法来进行查找的，因此查找的效率较低。</p><p>现在广泛使用的索引和查找技术叫做分布式散列表 DHT (Distributed Hash Table)。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。广泛使用的 Chord 算法是美国麻省理工大学于2001 年提出的。</p><p>分布式散列表 DHT 利用散列函数，把资源名 K 及其存放的结点 IP 地址 N 都分别映射为资源名标识符 KID 和结点标识符 NID。<br>Chord 把结点按标识符数值从小到大沿顺时针排列成一个环形覆盖网络。</p><p>如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409162434921.png" alt="image-20210409162434921"></p><p>每个资源由 Chord 环上与其标识符值最接近的下一个结点提供服务。</p><p>当N13加进来到节点后，N10的下一个节点就会从N20变成N13，从而资源点标识符K12也会移至该N13上</p><p>但是这个速度还不够，为了加速查找，在 Chord 环上可以增加一些指针表(finger table)，它又称为路由表或查找器表。对于结点 N4， 第 1 列第 i  行计算（N4 + 2i – 1），得出后继结点。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409162724943.png" alt="image-20210409162724943"></p>]]></content>
    
    <summary type="html">
    
      离我们最近的应用层
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-网络层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:29:32.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层提供何种服务"><a href="#网络层提供何种服务" class="headerlink" title="网络层提供何种服务"></a>网络层提供何种服务</h1><p>首先，从以下问题进入网络层的学习（书里就是这样）</p><p>在计算机网络领域，网络层应该向运输层提供怎样的服务<strong>（“面向连接”还是“无连接”</strong>）曾引起了长期的争论。<br>争论焦点的实质就是：在计算机通信中，<strong>可靠交付</strong>应当由谁来负责？是<strong>网络</strong>还是<strong>端系统</strong>？ </p><h2 id="让网络负责可靠交付"><a href="#让网络负责可靠交付" class="headerlink" title="让网络负责可靠交付"></a>让网络负责可靠交付</h2><p>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。通信之前先建立<strong>虚电路 (Virtual Circuit)</strong>，以保证双方通信所需的一切网络资源。 如果再使用<strong>可靠传输</strong>的网络协议，就可使所发送的分组<strong>无差错按序</strong>到达终点，不丢失、不重复。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415181401821.png" alt="H1 发送给 H2 的所有分组都沿着同一条虚电路传送"></p><p>H1 发送给 H2 的所有分组都沿着同一条虚电路传送</p><p>虚电路表示这只是一条<strong>逻辑上的连接</strong>，分组都沿着这条逻辑连接按照<strong>存储转发方式</strong>传送，而并不是真正建立了一条物理连接。<strong>请注意，电路交换的电话通信是先建立了一条真正的连接。</strong>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。 </p><blockquote><p>这样的情况已经遇到很多次了且很重要，在上一章数据链路层也讲了这种逻辑链接，为了屏蔽掉复杂的数据传递过程，我们会频繁的使用逻辑连接这一方法来帮助我们理解对等层之间的通信问题，放心，在接下来的运输层（TCP、UDP）和应用层（HTTP）也同样会使用该方法</p></blockquote><h2 id="网络提供数据报服务"><a href="#网络提供数据报服务" class="headerlink" title="网络提供数据报服务"></a>网络提供数据报服务</h2><p>互联网的先驱者提出了一种崭新的网络设计思路。网络层向上只提供简单灵活的、<strong>无连接的、尽最大努力交付的数据报服务</strong>。</p><p>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，<strong>与其前后的分组无关</strong>（不进行编号）。</p><p>网络层<strong>不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </p><p>由于传输网络<strong>不提供端到端的可靠传输服务</strong>，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的<strong>运输层负责可靠交付</strong>（包括差错处理、流量控制等） 。</p><p>采用这种设计思路的好处是：<strong>网络的造价大大降低，运行方式灵活</strong>，能够适应多种应用。</p><p>这也证明了互连网能够发展到今日的规模，缘于当初采用这种设计思路的正确性。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415182142417.png" alt="image-20210415182142417"></p><p>最后的答案就是<strong>端系统负责可靠交付</strong>啦，然后网络负责提供<strong>无连接的、尽最大努力交付的数据报服务</strong></p><p>丢出一张表对比下虚电路服务和数据报服务</p><table><thead><tr><th align="left">对比的方面</th><th align="left">虚电路服务</th><th align="left">数据报服务</th></tr></thead><tbody><tr><td align="left">思路</td><td align="left">可靠通信应当由网络来保证</td><td align="left">可靠通信应当由用户主机来保证</td></tr><tr><td align="left">连接的建立</td><td align="left">必须有</td><td align="left">不需要</td></tr><tr><td align="left">终点地址</td><td align="left">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td align="left">每个分组都有终点的完整地址</td></tr><tr><td align="left">分组的转发</td><td align="left">属于同一条虚电路的分组均按照同一路由进行转发</td><td align="left">每个分组独立选择路由进行转发</td></tr><tr><td align="left">当结点出故障时</td><td align="left">所有通过出故障的结点的虚电路均不能工作</td><td align="left">出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td align="left">分组的顺序</td><td align="left">总是按发送顺序到达终点</td><td align="left">到达终点时不一定按发送顺序</td></tr><tr><td align="left">端到端的差错处理和流量控制</td><td align="left">可以由网络负责，也可以由用户主机负责</td><td align="left">由用户主机负责</td></tr></tbody></table><h1 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h1><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。</p><p>与 IP 协议配套使用的还有三个协议：</p><ol><li><strong>地址解析协议 ARP (Address Resolution Protocol)</strong></li><li><strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong></li><li><strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong></li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415183411541.png" alt="image-20210415183411541"></p><h2 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h2><p>将网络互连并能够互相通信，会遇到许多问题需要解决，如：</p><ol><li>不同的寻址方案</li><li>不同的最大分组长度</li><li>不同的网络接入机制</li><li>不同的超时控制</li><li>不同的差错恢复方法</li><li>不同的状态报告方法</li><li>不同的路由选择技术</li><li>不同的用户接入控制</li><li>不同的服务（面向连接服务和无连接服务）</li><li>不同的管理与控制方式等</li></ol><p>妈耶这也太多了，所以这一章的内容是最多的，同时理论上也是五层协议里面最复杂最重要的一章，也会包含了一些计算题</p><p>将网络互相连接起来要使用一些中间设备。 中间设备又称为<strong>中间系统或中继 (relay)系统</strong>。有以下五种不同的中间设备：</p><ol><li>物理层中继系统：<strong>转发器 (repeater)</strong>。</li><li>数据链路层中继系统：<strong>网桥</strong> 或 <strong>桥接器 (bridge)</strong>。</li><li>网络层中继系统：<strong>路由器 (router)</strong>。</li><li>网桥和路由器的混合物：<strong>桥路器 (brouter)</strong>。</li><li>网络层以上的中继系统：<strong>网关 (gateway)</strong>。 </li></ol><p>当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。（回想下数据链路层的集线器以及交换机的工作） 网关由于比较复杂，目前使用得较少。<br><strong>网络互连都是指用路由器进行网络互连和路由选择。</strong>由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。   </p><h3 id="虚拟互连网络的意义"><a href="#虚拟互连网络的意义" class="headerlink" title="虚拟互连网络的意义"></a>虚拟互连网络的意义</h3><p><strong>所谓虚拟互连网络也就是逻辑互连网络</strong>，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。使用 IP 协议的虚拟互连网络可简称为 IP 网。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415192112095.png" alt="image-20210415192112095"></p><p><strong>使用虚拟互连网络的好处是</strong>：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。如果在这种覆盖全球的 IP 网的上层使用 <strong>TCP 协议</strong>（运输层），那么就是现在的互联网 (Internet)。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415192705638.png" alt="image-20210415192705638"></p><p>最后，从网络层去考虑问题（联想下数据链路层考虑问题的方法），那么 IP 数据报就可以想象是在网络层中传送。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415194411960.png" alt="image-20210415194411960"></p><h2 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h2><h3 id="IP-地址及其表示方法"><a href="#IP-地址及其表示方法" class="headerlink" title="IP 地址及其表示方法"></a>IP 地址及其表示方法</h3><p>我们把整个互联网看成为一个单一的、抽象的网络。IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 32 位的标识符</strong>。</p><p>IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)进行分配。 </p><p><strong>IP 地址的编址方法</strong></p><p><strong>分类的 IP 地址。</strong>这是最<strong>基本的编址方法</strong>，在1981年就通过了相应的标准协议。</p><p><strong><a href="#划分子网和构造超网">子网的划分</a>。</strong>这是对最基本的编址方法的改进，其标准[RFC 950]在1985年通过。</p><p><strong><a href="#划分子网和构造超网">构成超网</a>。</strong>这是比较新的<strong>无分类编址方法</strong>。1993年提出后很快就得到推广应用。</p><p>先来讲讲第一个IP地址的分类，后面两个会在第三节提到</p><p>将IP地址划分为若干个固定类。</p><p>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</p><p>主机号在它前面的网络号所指明的网络范围内必须是唯一的。<br>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415195656915.png" alt="image-20210415195656915"></p><p>也可以这样（::=  代表“定义为”)</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415195727663.png" alt="image-20210415195727663"></p><p>一开始，网络被分为五类地址，后来因为<strong>无分类IP地址</strong>的广泛使用，这种区分变成了历史</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415195926200.png" alt="image-20210415195926200"></p><h4 id="点分十进制记法"><a href="#点分十进制记法" class="headerlink" title="点分十进制记法"></a>点分十进制记法</h4><p>机器中存放的 IP 地址是 32 位二进制代码，长这样，好记不，不好记</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415200148882.png" alt="image-20210415200148882"></p><p>所以，聪明的人们就想到了点分十进制法来方便我们记住ip地址</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415200242102.png" alt="image-20210415200242102"></p><p>下面是一堆点分十进制的具体例子</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415200310917.png" alt="image-20210415200310917"></p><h3 id="常用的三种类别的-IP-地址"><a href="#常用的三种类别的-IP-地址" class="headerlink" title="常用的三种类别的 IP 地址"></a>常用的三种类别的 IP 地址</h3><table><thead><tr><th align="left">网络  类别</th><th align="left">最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th align="left">每个网络中最大主机数</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">126 (27  – 2)</td><td>1</td><td>126</td><td align="left">16777214</td></tr><tr><td align="left">B</td><td align="left">16383 (214  – 1)</td><td>128.1</td><td>191.255</td><td align="left">65534</td></tr><tr><td align="left">C</td><td align="left">2097151 (221 – 1)</td><td>192.0.1</td><td>223.255.255</td><td align="left">254</td></tr></tbody></table><p>一些一般情况下不使用的特殊IP地址</p><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机（见 6.6  节 DHCP  协议）</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机 host-id</td></tr><tr><td>全 1</td><td>全 1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播（各路由器均不转发）</td></tr><tr><td>net-id</td><td>全 1</td><td>不可</td><td>可以</td><td>对 net-id  上的所有主机进行广播</td></tr><tr><td>127</td><td>非全 0 或全 1 的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><p>注意：A类地址→127.0.0.1一般作为本主机进程之间的通信所用</p><h3 id="IP-地址的一些重要特点"><a href="#IP-地址的一些重要特点" class="headerlink" title="IP 地址的一些重要特点"></a>IP 地址的一些重要特点</h3><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ol><li>第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 </li></ol><p>(2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机 (multihomed host)</strong>。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。 </li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id</strong>。</p><p>(4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是<strong>平等的</strong>。</p><p>通过下面的图加深对以上特点的理解</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415201912374.png" alt="image-20210415201912374"></p><p>在同一个局域网上的主机或路由器的IP 地址中的网络号必须是一样的。图中的网络号就是 IP 地址中的 net-id。（各个粉色区域即各自的局域网）</p><p>路由器总是具有两个或两个以上的IP地址。路由器的每一个接口都有一个不同网络号的IP地址。（R1、R2、R3）</p><p>两个路由器直接相连的接口处，可指明也可不指明IP地址。如指明IP地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。现在常不指明IP地址。（中间粉紫色的N1、N2、N3）</p><h2 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h2><p>IP 地址与硬件地址是不同的地址。从层次的角度看，<strong>硬件地址（或物理地址）是数据链路层和物理层使用的地址。IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</strong>（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202457509.png" alt="image-20210415202457509"></p><p>IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。</p><p>我们先来看看在网络层上看，数据的具体流动方式</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202558809.png" alt="image-20210415202558809"></p><p>再来看看在实际的协议栈上，数据的流动</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202646057.png" alt="image-20210415202646057"></p><p>从虚拟的 IP 层上看 IP 数据报的流动（和上面的网络层的图性质类似，只不过简化了点）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202714172.png" alt="image-20210415202714172"></p><p>而从链路上看呢，在具体的物理网络的链路层，只能看见 MAC 帧而看不见 IP 数据报 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202851371.png" alt="image-20210415202851371"></p><p>现在回头再来看看IP协议层的数据流动，图中的  IP1 → IP2  表示从源地址 IP1 到目的地址 IP2 。两个路由器的 IP 地址并不出现在 IP 数据报的首部中。 路由器只根据目的站的 IP 地址的网络号进行路由选择。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415202714172.png" alt="image-20210415202714172"></p><p>IP 层抽象的互联网屏蔽了下层很复杂的细节。在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信 。（会不会又啰嗦了）</p><p>主机 H1 与 H2 通信中使用的IP地址与硬件地址举例(根据上图理解)</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415203207464.png" alt="image-20210415203207464"></p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a><strong>地址解析协议 ARP</strong></h2><p>通过上面的了解，我们知道了硬件地址和IP地址的区别，现在就来考虑在实际协议栈中硬件地址和IP地址是如何进行转换的</p><blockquote><p>通信时使用了两个地址：</p><ol><li>IP 地址（网络层地址）</li><li>MAC 地址（数据链路层地址）</li></ol></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415203642454.png" alt="image-20210415203642454"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>地址解析协议 ARP 就是用来通过IP地址来查找对应的硬件地址</p><blockquote><p>ARP 作用：<br>从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415203805823.png" alt="image-20210415203805823"></p><p>通过前面我们也知道，不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 </p><p>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415203906033.png" alt="image-20210415203906033"></p><p>注：TTL (Time To Live)：地址映射有效时间 </p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。（和那啥是不是有点类似，数据链路层中交换机的工作方式）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415204254478.png" alt="image-20210415204254478"></p><p>解剖整段话中的要点</p><blockquote><p><strong>ARP请求分组：</strong>包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。</p><p><strong>本地广播 ARP 请求</strong>（路由器不转发ARP请求）。</p><p><strong>ARP 响应分组</strong>：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。</p><p><strong>ARP 分组封装在物理网络的帧中传输。</strong></p></blockquote><h3 id="ARP-高速缓存"><a href="#ARP-高速缓存" class="headerlink" title="ARP 高速缓存"></a>ARP 高速缓存</h3><p>ARP 具有高速缓存，用来存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量。</p><p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 </p><p>如果目的主机不在本局域网呢</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415204653510.png" alt="image-20210415204653510"></p><p>ARP 用于解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，<strong>那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址</strong>，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p>从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 </p><p>最后，总结下使用ARP会遇到的四种典型情况</p><h3 id="不同应用场景"><a href="#不同应用场景" class="headerlink" title="不同应用场景"></a>不同应用场景</h3><ol><li><strong>发送方是主机</strong>，要把 IP 数据报发送到<strong>本网络上的另一个主机</strong>。这时用 ARP 找到目的主机的硬件地址。 </li><li>发送方是主机，要把 IP 数据报发送到<strong>另一个网络上的一个主机</strong>。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 </li><li><strong>发送方是路由器</strong>，要把 IP 数据报转发到<strong>本网络上的一个主机</strong>。这时用 ARP 找到目的主机的硬件地址。 </li><li><strong>发送方是路由器</strong>，要把 IP 数据报转发到<strong>另一个网络上的一个主机</strong>。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。 </li></ol><h3 id="为什么不直接使用硬件地址？"><a href="#为什么不直接使用硬件地址？" class="headerlink" title="为什么不直接使用硬件地址？"></a>为什么不直接使用硬件地址？</h3><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。想想看，若一台主机要跨交换机进行通信，那么他的数据是被无数个交换机所接收的，只有目的主机的交换机才会收下这部分数据，对比路由器，可以针对性对目标主机所在的局域网进行传递，至少不用像交换机一样进行广播，节省了多少资源，详细可以看看数据链路层的交换机工作方式，对比下路由器。</p><p>还有，调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。</p><h2 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a><strong>IP 数据报的格式</strong></h2><p>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 </p><p>纵向来看</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415205509911.png" alt="image-20210415205509911"></p><p>横向简化版</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415205526556.png" alt="image-20210415205526556"></p><p>首部的前一部分是固定长度，共 <strong>20 字节</strong>，是所有 IP 数据报必须具有的。可选字段，其长度是可变的。</p><h3 id="IP-数据报首部的固定部分中的各字段"><a href="#IP-数据报首部的固定部分中的各字段" class="headerlink" title="IP 数据报首部的固定部分中的各字段"></a>IP 数据报首部的固定部分中的各字段</h3><ol><li><p>版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)。</p></li><li><p>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。</p></li><li><p>区分服务——占 8 位，用来获得更好的服务。在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段 </p></li><li><p>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元MTU。 </p></li><li><p>标识(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。 </p></li><li><p><strong>标志(flag)</strong> ——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF=0 时才允许分片。 </p></li><li><p><strong>片偏移</strong>——占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</p></li><li><p><strong>生存时间</strong>——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数（也称跳数，最大值为255）的最大值。防止无法交付的数据报在互联网中无限制的兜圈子。</p></li><li><p>协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程（在之后的运输层以及网络层会涉及到更多协议）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415212725311.png" alt="image-20210415212725311"></p></li><li><p>首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415212818822.png" alt="image-20210415212818822"></p></li><li><p>源地址和目的地址都各占 4 字节</p></li></ol><p>其中，对于<strong>标志</strong>以及<strong>片偏移</strong>，这里通过一个例子加深理解</p><p>一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。<br>因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。<strong>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415212526446.png" alt="image-20210415212526446"></p><p>IP 数据报首部中与分片有关的字段中的数值</p><table><thead><tr><th></th><th>总长度</th><th>标识</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody><tr><td>原始数据报</td><td>3820</td><td>12345</td><td>0</td><td>0</td><td>0</td></tr><tr><td>数据报片1</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>0</td></tr><tr><td>数据报片2</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>175</td></tr><tr><td>数据报片3</td><td>1020</td><td>12345</td><td>0</td><td>0</td><td>350</td></tr></tbody></table><h3 id="IP-数据报首部的可变部分"><a href="#IP-数据报首部的可变部分" class="headerlink" title="IP 数据报首部的可变部分"></a>IP 数据报首部的可变部分</h3><p>IP 首部的可变部分就是一个选项字段，用来支持<strong>排错、测量以及安全等</strong>措施，内容很丰富。选项字段的长度可变，<strong>从 1 个字节到 40 个字节不等</strong>，取决于所选择的项目。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。<strong>实际上这些选项很少被使用。</strong></p><h2 id="IP-层转发分组的流程"><a href="#IP-层转发分组的流程" class="headerlink" title="IP 层转发分组的流程"></a><strong>IP 层转发分组的流程</strong></h2><p>假设：有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于庞大。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目（每一行对应于一个网络），这样就可使路由表大大简化。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415213715296.png" alt="image-20210415213715296"></p><p>在路由表中，对每一条路由，最主要的是（目的网络地址，下一跳地址） </p><h3 id="查找路由表"><a href="#查找路由表" class="headerlink" title="查找路由表"></a>查找路由表</h3><p>根据目的网络地址就能确定下一跳路由器，这样做的结果是：IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。只有到达最后一个路由器时，才试图向目的主机进行直接交付。 </p><h3 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h3><p>虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，<strong>即为特定的目的主机指明一个路由</strong>。<br>采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。 </p><h3 id="默认路由-default-route"><a href="#默认路由-default-route" class="headerlink" title="默认路由 (default route)"></a>默认路由 (default route)</h3><p>路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。默认路由在主机发送 IP 数据报时往往更能显示出它的好处。如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415213953578.png" alt="image-20210415213953578"></p><p>只要目的网络不是 N1 和 N2，就一律选择默认路由，把数据报先间接交付路由器 R1，让 R1 再转发给下一个路由器。 </p><p>必须指出</p><p>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件<strong>使用 ARP</strong> 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 </p><h3 id="路由器分组转发算法"><a href="#路由器分组转发算法" class="headerlink" title="路由器分组转发算法"></a>路由器分组转发算法</h3><ol><li>从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</li><li>若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。</li><li>报告转发分组出错。 </li></ol><p>最后，总结一下路由表：路由表没有给分组指明到某个网络的完整路径。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p><h1 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a><strong>划分子网和构造超网</strong></h1><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>两级IP地址到三级IP地址（了解）</p><p>一开始是只有网络号和主机号的，为了方便管理，就出现了下面的地址形式</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415215744413.png" alt="image-20210415215744413"></p><blockquote><p>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}</p></blockquote><p>划分子网思路如下</p><p>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p><p>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。<br>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。</p><p> 一个未划分子网的 B 类网络145.13.0.0（下图）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415220031670.png" alt="image-20210415220031670"></p><p>划分为三个子网，它对外仍是一个网络</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415220105427.png" alt="image-20210415220105427"></p><p>当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址就变成了三级结构。划分子网只是把 IP 地址的<strong>主机号 host-id 这部分进行再划分</strong>，而不改变 IP 地址原来的网络号 net-id。 </p><p>划分后的三级结构子网有什么优点呢</p><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol><p>划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。  </p><p>规则：子网掩码长度 ＝ 32 位；子网掩码左边部分的一连串 1，对应于网络号和子网号；子网掩码右边部分的一连串 0，对应于主机号</p><p>也就是说，把设定的子网号包括网络号全部置为1，后面的全为0，代表分配给主机号 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415220909881.png" alt="image-20210415220909881"></p><p>很恨很重要的一条公式</p><blockquote><p><strong>(IP 地址) AND (子网掩码) =网络地址</strong></p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415221001845.png" alt="image-20210415221001845"></p><p>默认的子网掩码（下图）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415221114137.png" alt="image-20210415221114137"></p><p>子网掩码是一个网络或一个子网的重要属性。路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p><h3 id="子网划分方法"><a href="#子网划分方法" class="headerlink" title="子网划分方法"></a>子网划分方法</h3><p>有<strong>固定长度子网</strong>和<strong>变长子网</strong>两种子网划分方法。</p><p>在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。<br>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着[<strong>无分类域间路由选择 CIDR</strong>](#无分类编址 CIDR（构造超网）) 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><p>B 类地址的子网划分选择（使用固定长度子网），如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415221507099.png" alt="image-20210415221507099"></p><p>表中的“子网号的位数”中没有 0, 1, 15 和 16 这四种情况，因为这没有意义。 </p><p><strong>来啦来啦，计算题来啦</strong></p><p>【例4-2】已知 IP 地址是 141.14.72.24，子网掩码是255.255.224.0。试求网络地址。 </p><p>解题思路图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415221801814.png" alt="image-20210415221801814"></p><p>【例4-3】上例中，若子网掩码改为 255.255.224.0，试求网络地址，讨论所得结果。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415221850867.png" alt="image-20210415221850867"></p><p>通过解题发现了啥，不同的子网掩码对同一个ip地址得出相同的网络地址，但实际上不同的掩码的效果是不同的，这对后面学习无分类编址CIDR很重要，当对一个ip地址进行掩码处理后，你会发现可能多个网络号都对应得上，那么我们往往会选择更大的那一个，因为离得更近嘛。</p><h2 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h2><p>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动。 看看改动后的算法是怎样的</p><ol><li>从收到的分组的首部提取<strong>目的 IP 地址 D</strong>。</li><li>先用各网络的<strong>子网掩码和 D 逐位相“与”</strong>，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。</li><li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则将分组传送给指明的下一跳路由器；否则，执行 (4)。</li><li>对路由表中的每一行，将<strong>子网掩码和 D 逐位相“与”</strong>。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。</li><li>若路由表中有一个<strong>默认路由</strong>，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。</li><li>报告转发分组出错。</li></ol><p>再来一题</p><p>【例4-4】已知互联网和路由器 R1 中的路由表。主机 H1 向 H2 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415222745188.png" alt="image-20210415222745188"></p><p>H1 首先检查主机 128.30.33.138 是否连接在本网络上，如果是，则直接交付；否则，就送交路由器 R1，并逐项查找路由表。</p><p>主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.33.138 逐比特相与”(AND 操作) </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210415223100270.png" alt="image-20210415223100270"></p><p>因此 H1 必须把分组传送到路由器 R1，然后逐项查找路由表</p><p>路由器 R1 收到分组后就用路由表中第 1 个项目的子网掩码和 128.30.33.138 逐比特 AND 操作 ，然后如此下去，直到得出的网络地址和路由表中子网掩码的对应目的网络地址匹配</p><p>255.255.255.128 AND 128.30.33.138 = 128.30.33.128     不匹配!<br>（因为128.30.33.128 与路由表中的 128.30.33.0 不一致）</p><p>255.255.255.128 AND 128.30.33.138 = 128.30.33.128     匹配!<br>这表明子网 2 就是收到的分组所要寻找的目的网络。</p><h2 id="无分类编址-CIDR（构造超网）"><a href="#无分类编址-CIDR（构造超网）" class="headerlink" title="无分类编址 CIDR（构造超网）"></a>无分类编址 CIDR（构造超网）</h2><p>为了解决B 类地址分配快完的以及互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）的问题。</p><p>使用<strong>变长子网掩码 VLSM</strong> (Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率。</p><p>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是<strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li><li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</li><li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。 </li></ul><p>无分类的两级编址的记法是</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416072608149.png" alt="image-20210416072608149"></p><blockquote><p>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</p></blockquote><p>为了同三级编址一样划分子网，CIDR 使用<strong>“斜线记法”(slash notation)</strong>，它又称为 CIDR 记法，即在 IP 地址里面加上一个<strong>斜线“/”</strong>，然后<strong>写上网络前缀所占的位数</strong>（这个数值对应于三级编址中子网掩码中 1 的个数）。例如： 220.78.168.0/24</p><h3 id="CIDR-地址块"><a href="#CIDR-地址块" class="headerlink" title="CIDR 地址块"></a>CIDR 地址块</h3><blockquote><p>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</p></blockquote><p>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。</p><p>这个地址块的起始地址是 128.14.32.0。</p><p>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</p><p>128.14.32.0/20 地址块的最小地址：128.14.32.0</p><p>128.14.32.0/20 地址块的最大地址：128.14.47.255</p><h4 id="其他形式的记法"><a href="#其他形式的记法" class="headerlink" title="其他形式的记法"></a>其他形式的记法</h4><p>10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。<br>10.0.0.0/10 隐含地指出 IP 地址 10.0.0.0 的掩码 255.192.0.0。此掩码可表示为：</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416073332167.png" alt="image-20210416073332167"></p><p>网络前缀的后面加一个星号 * 的表示方法，如 00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。 </p><p><strong>注意：全 0 和全 1 的主机号地址一般不使用。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416072842853.png" alt="image-20210416072842853"></p><h3 id="路由聚合-route-aggregation"><a href="#路由聚合-route-aggregation" class="headerlink" title="路由聚合 (route aggregation)"></a>路由聚合 (route aggregation)</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。<strong>路由聚合也称为构成超网 (supernetting)。</strong></p><p>简单来说，就是将一部分具有相同网络前缀以及掩码的地址聚合成一个整体</p><p>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。对于 /20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。 </p><p><strong>常用的CIDR地址块</strong></p><table><thead><tr><th>CIDR 前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于包含分类的网络数</th></tr></thead><tbody><tr><td>/13</td><td>255.248.0.0</td><td>512 K</td><td>8 个   B类或  2048 个 C  类</td></tr><tr><td>/14</td><td>255.252.0.0</td><td>256 K</td><td>4 个 B  类或1024 个 C  类</td></tr><tr><td>/15</td><td>255.254.0.0</td><td>128 K</td><td>2 个 B  类或512 个 C  类</td></tr><tr><td>/16</td><td>255.255.0.0</td><td>64 K</td><td>1 个 B  类或256 个 C  类</td></tr><tr><td>/17</td><td>255.255.128.0</td><td>32 K</td><td>128 个 C  类</td></tr><tr><td>/18</td><td>255.255.192.0</td><td>16 K</td><td>64 个 C  类</td></tr><tr><td>/19</td><td>255.255.224.0</td><td>8 K</td><td>32 个 C  类</td></tr><tr><td>/20</td><td>255.255.240.0</td><td>4 K</td><td>16 个 C  类</td></tr><tr><td>/21</td><td>255.255.248.0</td><td>2 K</td><td>8 个 C  类</td></tr><tr><td>/22</td><td>255.255.252.0</td><td>1 K</td><td>4 个 C  类</td></tr><tr><td>/23</td><td>255.255.254.0</td><td>512</td><td>2 个 C  类</td></tr><tr><td>/24</td><td>255.255.255.0</td><td>256</td><td>1 个 C  类</td></tr><tr><td>/25</td><td>255.255.255.128</td><td>128</td><td>1/4 个 C  类</td></tr><tr><td>/26</td><td>255.255.255.192</td><td>64</td><td>1/4 个 C  类</td></tr><tr><td>/27</td><td>255.255.255.224</td><td>32</td><td>1/8 个 C  类</td></tr></tbody></table><p>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C  类地址。这些 C 类地址合起来就<strong>构成了超网</strong>。<strong>CIDR 地址块中的地址数一定是 2 的整数次幂</strong>。网络前缀越短，其地址块所包含的地址数就越多。而在<strong>三级结构的IP地址中，划分子网是使网络前缀变长</strong>。</p><p>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。 </p><p>比如下面的例子</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416073719888.png" alt="image-20210416073719888"></p><p>这个 ISP 共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。</p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。 应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配 (longest-prefix matching)。网络前缀越长，其地址块就越小，因而路由就越具体 (more specific) 。<strong>最长前缀匹配又称为最长匹配或最佳匹配。</strong></p><p>比如</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416073906784.png" alt="image-20210416073906784"></p><p>接着</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416073927958.png" alt="image-20210416073927958"></p><p>怎么选择呢，当然就是选择两个匹配的地址中更具体的一个，即选择最长前缀的地址。 这样就能更具体更快的找到主机所在网络啦</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416074031309.png" alt="image-20210416074031309"></p><h3 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h3><p>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。 为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种<strong>层次的数据结构中，然后自上而下地按层次进行查找</strong>。这里最常用的就是二叉线索 (binary trie)。</p><p>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。<br>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。 </p><p>如下面的例子</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416074305521.png" alt="image-20210416074305521"></p><p>从二叉线索的根节点自顶向下的深度最多有 32 层，每一层对应于IP地址中的一位。一个IP地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为 0，则第一层的节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层的节点。依此类推，直到唯一前缀的最后一位。</p><h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a><strong>网际控制报文协议 ICMP</strong></h1><h2 id="ICMP-报文的种类"><a href="#ICMP-报文的种类" class="headerlink" title="ICMP 报文的种类"></a>ICMP 报文的种类</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。ICMP 是互联网的标准协议。</p><p>ICMP 允许<strong>主机或路由器报告差错情况和提供有关异常情况的报告</strong>。但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416082346847.png" alt="image-20210416082346847"></p><p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。 ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型、代码和检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。 </p><h3 id="ICMP-差错报告报文"><a href="#ICMP-差错报告报文" class="headerlink" title="ICMP 差错报告报文"></a>ICMP 差错报告报文</h3><p>ICMP 差错报告报文共有 4 种</p><ul><li>终点不可达 </li><li>时间超过 </li><li>参数问题 </li><li>改变路由（重定向）(Redirect) </li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416082743895.png" alt="image-20210416082743895"></p><p>有几种情况不会发送ICMP差错报告报文</p><ol><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对<strong>第一个分片的数据报片的所有后续数据报片</strong>都不发送 ICMP 差错报告报文。</li><li>对具有<strong>多播地址</strong>的数据报都不发送 ICMP 差错报告报文。</li><li>对具有<strong>特殊地址</strong>（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ol><h3 id="ICMP-询问报文"><a href="#ICMP-询问报文" class="headerlink" title="ICMP 询问报文"></a>ICMP 询问报文</h3><p>ICMP 询问报文有两种</p><ol><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ol><h2 id="ICMP-的应用举例"><a href="#ICMP-的应用举例" class="headerlink" title="ICMP 的应用举例"></a>ICMP 的应用举例</h2><h3 id="PING-Packet-InterNet-Groper"><a href="#PING-Packet-InterNet-Groper" class="headerlink" title="PING (Packet InterNet Groper)"></a>PING (Packet InterNet Groper)</h3><p>PING 用来测试两个主机之间的连通性。PING 使用了 <strong>ICMP 回送请求与回送回答报文</strong>。PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 </p><p>下图是用 PING 测试主机的连通性</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416083452619.png" alt="image-20210416083452619"></p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>在 Windows 操作系统中这个命令是 tracert。它用来<strong>跟踪一个分组从源点到终点的路径</strong>。它利用 IP 数据报中的 <strong>TTL 字段</strong>和 <strong>ICMP 时间超过差错报告报文</strong>实现对从源点到终点的路径的跟踪。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416084136437.png" alt="image-20210416084136437"></p><p>用 tracert 命令获得到目的主机的路由信息</p><h1 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a><strong>互联网的路由选择协议</strong></h1><h2 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h2><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><p>算法必须是正确的和完整的。 在计算上应简单。 应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。 应具有稳定性。应是公平的。应是最佳的。 </p><p>不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。 </p><p><strong>静态</strong>路由选择策略——即<strong>非自适应路由选择</strong>，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </p><p><strong>动态</strong>路由选择策略——即<strong>自适应路由选择</strong>，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。 </p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>互联网采用分层次的路由选择协议。这是因为：</p><p>(1) 互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</p><p>(2) 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。 </p><h4 id="自治系统-AS"><a href="#自治系统-AS" class="headerlink" title="自治系统 AS"></a>自治系统 AS</h4><p><strong>自治系统 AS 的定义：</strong>在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</p><p>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是<strong>一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416090330427.png" alt="image-20210416090330427"></p><h4 id="内部网关协议-IGP-Interior-Gateway-Protocol"><a href="#内部网关协议-IGP-Interior-Gateway-Protocol" class="headerlink" title="内部网关协议 IGP (Interior Gateway Protocol)"></a>内部网关协议 IGP (Interior Gateway Protocol)</h4><p>在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</p><h4 id="外部网关协议-EGP-External-Gateway-Protocol"><a href="#外部网关协议-EGP-External-Gateway-Protocol" class="headerlink" title="外部网关协议 EGP (External Gateway Protocol)"></a>外部网关协议 EGP (External Gateway Protocol)</h4><p>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。 </p><p>它们之间的关系可以用下面的图来表示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416090740503.png" alt="image-20210416090740503"></p><p>还有两个概念要知道</p><blockquote><p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong> (interdomain routing)，在自治系统内部的路由选择叫做<strong>域内路由选择</strong> (intradomain routing) 。</p></blockquote><blockquote><p>互联网的早期 RFC 文档中未使用“路由器”而是使用“网关”这一名词。但是在新的 RFC 文档中又使用了“路由器”这一名词。应当把这两个术语当作同义词</p></blockquote><h2 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 是一种<strong>分布式的、基于距离向量的路由选择协议</strong>。<strong>RIP 协议</strong>要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 </p><blockquote><p>这里的“距离”不是咱们普通的单位量算，而是路由器到直接相连的网络的距离（也就是跳数）</p><p>从一个路由器到直接连接的网络的距离定义为 1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。这里的“距离”实际上指的是“最短距离”。 </p></blockquote><p>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。<br>RIP 允许<strong>一条路径最多只能包含 15 个路由器</strong>。</p><p><strong>“距离”的最大值为 16 时即相当于不可达</strong>。可见 RIP 只适用于小型互联网。</p><p>RIP <strong>不能在两个网络之间同时使用多条路由</strong>。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。 </p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>仅和相邻路由器交换信息。 </li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ol><h3 id="工作过程（路由表的建立）"><a href="#工作过程（路由表的建立）" class="headerlink" title="工作过程（路由表的建立）"></a>工作过程（路由表的建立）</h3><p>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</p><blockquote><p>RIP 协议的<strong>收敛 (convergence)</strong> 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。 </p></blockquote><h3 id="距离量算法"><a href="#距离量算法" class="headerlink" title="距离量算法"></a>距离量算法</h3><p>完整算法流程如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416091523557.png" alt="image-20210416091523557"></p><p>距离向量算法的基础就是 Bellman-Ford 算法（或 Ford-Fulkerson 算法）。这种算法的要点是这样的：设X是结点 A 到 B 的最短路径上的一个结点。若把路径 A→B 拆成两段路径 A→X 和 X→B，则每一段路径 A→X 和 X→B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。</p><p>RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</p><p>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p>例题又来啦 </p><p>下图为路由表更新的一个例子以及解题过程<br><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092004254.png" alt="image-20210416092004254"></p><h3 id="RIP2-协议的报文格式"><a href="#RIP2-协议的报文格式" class="headerlink" title="RIP2 协议的报文格式"></a>RIP2 协议的报文格式</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092103127.png" alt="image-20210416092103127"></p><p>RIP2 报文由首部和路由部分组成。RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 <strong>20 个字节</strong>。<strong>地址族标识符（又称为地址类别）字段</strong>用来标志所使用的地址协议。<strong>路由标记</strong>填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。 </p><p>一个 RIP 报文最多可包括 <strong>25 个路由</strong>，因而 RIP 报文的最大长度是 4+20 x25=504 字节。如超过，必须再用一个 RIP 报文来传送。</p><p><strong>RIP2 具有简单的鉴别功能。</strong><br>若使用鉴别功能，则将原来写入第一个路由信息（20 个字节）的位置用作鉴别。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。</p><p><strong>RIP 协议特点：好消息传播得快，坏消息传播得慢</strong>。<br><strong>RIP 存在的一个问题：</strong>当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。通过多图小漫画来了解该过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092825114.png" alt="image-20210416092825114"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092839477.png" alt="image-20210416092839477"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092854326.png" alt="image-20210416092854326"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092911949.png" alt="image-20210416092911949"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092923117.png" alt="image-20210416092923117"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416092941221.png" alt="image-20210416092941221"></p><p>这就是好消息传播得快，而坏消息传播得慢。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。 </p><h3 id="RIP-协议的优缺点"><a href="#RIP-协议的优缺点" class="headerlink" title="RIP 协议的优缺点"></a>RIP 协议的优缺点</h3><p><strong>优点</strong>：</p><ol><li>实现简单，开销较小。</li></ol><p><strong>缺点</strong>：</p><ol><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 </li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol><h2 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h2><p>开放最短路径优先 OSPF (Open Shortest Path First)是为克服 RIP 的缺点在 1989 年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。</p><p>“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF</p><p>采用分布式的链路状态协议 (link state protocol)。 </p><blockquote><p>注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p></blockquote><p>OSPF 规定每隔一段时间，如 30 分钟，要刷新一次<strong>数据库中的链路状态</strong>。 </p><p>由于一个路由器的链路状态只涉及到与<strong>相邻路由器的连通状态</strong>，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF  协议要比距离向量协议 RIP 好得多。 </p><p>OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。 </p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>向本自治系统中所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<strong>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</strong>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 </p><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的同步）。</p><p>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416093937924.png" alt="image-20210416093937924"></p><p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</p><p><strong>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</strong>OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做主干区域 (backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 </p><p>其中：R3、R4、R7为边界路由器，R5、R6为主干路由器</p><h3 id="OSPF-直接用-IP-数据报传送"><a href="#OSPF-直接用-IP-数据报传送" class="headerlink" title="OSPF 直接用 IP 数据报传送"></a>OSPF 直接用 IP 数据报传送</h3><p>OSPF 不用 UDP 而是直接用 IP 数据报传送。</p><p>OSPF 构成的<strong>数据报很短</strong>。这样做可<strong>减少路由信息的通信量</strong>。数据报很短的另一好处是可以不必将长的数据报分片传送。而分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 </p><h3 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h3><p>OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。</p><p>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>。</p><p>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。<strong>支持可变长度的子网划分和无分类编址 CIDR。</strong>每一个链路状态都带上一个 32 位的序号，<strong>序号越大状态就越新</strong>。</p><h3 id="OSPF-分组"><a href="#OSPF-分组" class="headerlink" title="OSPF 分组"></a>OSPF 分组</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416112557225.png" alt="image-20210416112557225"></p><p>OSPF <strong>的五种分组类型</strong></p><p>类型1，问候 (Hello) 分组。<br>类型2，数据库描述 (Database Description) 分组。<br>类型3，链路状态请求 (Link State Request) 分组。<br>类型4，链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。<br>类型5，链路状态确认 (Link State Acknowledgment)分组。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416112700434.png" alt="image-20210416112700434"></p><p>OSPF 使用可靠的洪泛法发送更新分组 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416112711490.png" alt="image-20210416112711490"></p><h3 id="指定的路由器"><a href="#指定的路由器" class="headerlink" title="指定的路由器"></a>指定的路由器</h3><p>若N个路由器连接在一个以太网上，则每个路由器要向其它N-1个路由器发送链路信息，因而总共需要N(N-1)个链路状态要传递</p><p>多点接入的局域网采用了指定的路由器 (designated router) 的方法，使广播的信息量大大减少。</p><p>指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。 </p><h2 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h2><blockquote><p>简介：BGP 是<strong>不同自治系统的路由器之间交换路由信息的协议</strong>。 BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278。 可以将 BGP-4 简写为 BGP。</p></blockquote><p>互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。自治系统之间的路由选择必须考虑有关策略。因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。 </p><h3 id="BGP-发言人"><a href="#BGP-发言人" class="headerlink" title="BGP 发言人"></a>BGP 发言人</h3><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker) 。</p><p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。 </p><h3 id="BGP-工作方式（交换路由信息）"><a href="#BGP-工作方式（交换路由信息）" class="headerlink" title="BGP 工作方式（交换路由信息）"></a>BGP 工作方式（交换路由信息）</h3><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要<strong>先建立 TCP 连接</strong>，然后在此连接上<strong>交换 BGP 报文</strong>以<strong>建立 BGP 会话(session)</strong>，<strong>利用 BGP 会话交换路由信息</strong>。</p><p>使用 TCP 连接能提供<strong>可靠的服务</strong>，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) 。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416151101050.png" alt="image-20210416151101050"></p><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416151211430.png" alt="image-20210416151211430"></p><p>自治系统 AS2 的 BGP 发言人通知主干网 AS1 的 BGP 发言人：“要到达网络 N1、 N2、N3 和 N4 可经过 AS2。” </p><p>主干网还可发出通知：“要到达网络 N5、N6 和 N7 可沿路径（AS1, AS3）。” </p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。</p><p>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的<strong>路由选择不致过分复杂</strong>。 </p><p><strong>BGP 支持 CIDR</strong>，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在<strong>发生变化时更新有变化的部分</strong>。这样做对节省网络带宽和减少路由器的处理开销都有好处。 </p><h3 id="BGP-4报文"><a href="#BGP-4报文" class="headerlink" title="BGP-4报文"></a>BGP-4报文</h3><p>BGP-4 共使用四种报文</p><ol><li><strong>打开 (OPEN) 报文</strong>，用来与相邻的另一个BGP发言人建立关系。</li><li><strong>更新 (UPDATE) 报文</strong>，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li><strong>保活 (KEEPALIVE) 报文</strong>，用来确认打开报文和周期性地证实邻站关系。</li><li><strong>通知 (NOTIFICATION) 报文</strong>，用来发送检测到的差错。</li></ol><p>注意：撤销路由一次可以撤销许多条，而增加新路由时，每条更新报文只能增加一条</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416151624933.png" alt="image-20210416151624933"></p><h1 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h1><blockquote><p>路由器是一种典型的网络层设备。路由器是互联网中的关键设备。</p></blockquote><p><strong>路由器的主要作用是：</strong></p><ol><li><strong>连通不同的网络</strong>。</li><li><strong>选择信息传送的线路</strong>。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</li></ol><h2 id="路由器的结构以及工作方式"><a href="#路由器的结构以及工作方式" class="headerlink" title="路由器的结构以及工作方式"></a>路由器的结构以及工作方式</h2><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是<strong>转发分组</strong>。也就是说，<strong>将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器</strong>。</p><p>下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。 路由器的转发分组正是<strong>网络层</strong>的主要工作。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416152047881.png" alt="image-20210416152047881"></p><p>整个的路由器结构可划分为<strong>两大部分</strong>：</p><ol><li><strong>路由选择</strong>部分<ul><li>也叫做控制部分，其核心构件是路由选择处理机。</li><li>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</li></ul></li><li>分组<strong>转发</strong>部分（由三部分组成）<ol><li>交换结构 (switching fabric)：又称为交换组织，其作用是<strong>根据转发表 (forwarding table) 对分组进行处理</strong>。</li><li>一组输入端口（硬件端口）</li><li>一组输出端口（硬件端口）</li></ol></li></ol><p><strong>“转发”(forwarding)</strong> 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</p><p><strong>“路由选择”(routing)</strong> 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。</p><p><strong>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</strong>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</p><p>路由器的<strong>输入端口</strong>里面装有物理层、数据链路层和网络层的处理模块。数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。 <strong>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416153037296.png" alt="image-20210416153037296"></p><p>输出端口将交换结构传送来的分组发送到线路 </p><p>输出端口里面同样装有物理层、数据链路层和网络层的处理模块。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。</p><p>在网络层的处理模块中设有一个<strong>缓冲区（队列）</strong>。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。</p><p>数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416153257591.png" alt="image-20210416153257591"></p><h2 id="分组丢弃"><a href="#分组丢弃" class="headerlink" title="分组丢弃"></a>分组丢弃</h2><p>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。<strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</strong></p><h2 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h2><p>交换结构是路由器的关键构件。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。</p><p>实现交换有多种方法。常用交换方法有三种：<br>(1) 通过存储器<br>(2) 通过总线<br>(3) 通过纵横交换结构</p><h3 id="通过存储器"><a href="#通过存储器" class="headerlink" title="通过存储器"></a>通过存储器</h3><p>(1) 当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。</p><p>(2) 路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</p><p>(3) 若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于 M/2。这是因为存储器对分组的读和写花费的时间是同一个数量级</p><h3 id="通过总线"><a href="#通过总线" class="headerlink" title="通过总线"></a>通过总线</h3><p>(1) 数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。</p><p>(2) 因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。如果总线在忙，则被堵塞而没法通过交换结构，并在输入端口等待</p><p>(3) 现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此<strong>许多的路由器产品都采用这种通过总线的交换方式</strong>。</p><h3 id="通过纵横交换结构-crossbar-switch-fabric"><a href="#通过纵横交换结构-crossbar-switch-fabric" class="headerlink" title="通过纵横交换结构 (crossbar switch fabric)"></a>通过纵横交换结构 (crossbar switch fabric)</h3><p>(1) 这种交换结构常称为互连网络 (interconnection network)。</p><p>(2) 它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接。</p><p>(3) 当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。</p><p>(4) 若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。</p><p>(5) 但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到达的分组就被阻塞，必须在输入端口排队。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416153548115.png" alt="image-20210416153548115"></p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>IP 是互联网的核心协议。互联网经过几十年的飞速发展，到 2011 年 2 月，IPv4 的 32 位地址已经耗尽。ISP 已经不能再申请到新的 IP 地址块了。我国在 2014 – 2015 年也逐步停止了向新用户和应用分配 IPv4 地址。解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。</p><p>IPv6 仍支持<strong>无连接的传送</strong>，但将协议数据单元 PDU 称为<strong>分组</strong>。为方便起见，计算机网络这本书仍采用<strong>数据报</strong>这一名词。所引进的主要变化如下：</p><ol><li><strong>更大的地址空间</strong>。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 </li><li><strong>扩展的地址层次结构。</strong> </li><li><strong>灵活的首部格式。</strong> IPv6 定义了许多可选的扩展首部。</li><li><strong>改进的选项。</strong> IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。</li><li><strong>允许协议继续扩充。</strong> </li><li><strong>支持即插即用</strong>（即自动配置）。因此 IPv6 <strong>不需要使用 DHCP</strong>。</li><li><strong>支持资源的预分配</strong>。  IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。</li><li><strong>IPv6 首部改为 8 字节对齐。</strong>首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</li></ol><h2 id="IPv6-的基本首部"><a href="#IPv6-的基本首部" class="headerlink" title="IPv6 的基本首部"></a>IPv6 的基本首部</h2><p>IPv6 数据报由两大部分组成：</p><ol><li><strong>基本首部 (base header)</strong></li><li><strong>有效载荷 (payload)</strong>。有效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部 (extension header)，再后面是数据部分。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416160353874.png" alt="image-20210416160353874"></p><p>IPv6 将首部长度变为固定的 40 字节，称为基本首部。把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个。IPv6 对首部中的某些字段进行了如下的更改：</p><ul><li>取消了首部长度字段，因为首部长度是固定的 40 字节；</li><li>取消了服务类型字段；</li><li>取消了总长度字段，改用有效载荷长度字段；</li><li>把 TTL 字段改称为跳数限制字段；</li><li>取消了协议字段，改用下一个首部字段；</li><li>取消了检验和字段；</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416160803438.png" alt="image-20210416160803438"></p><p><strong>版本(version)</strong>—— 4 位。它指明了协议的版本，对 IPv6 该字段总是 6。 </p><p><strong>通信量类(traffic class)</strong>—— 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。 </p><p><strong>流标号(flow label)</strong>—— 20 位。 “流”是互联网络上从特定源点到特定终点的一系列数据报， “流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号。 </p><p><strong>有效载荷长度(payload length)</strong>—— 16 位。它指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内），其最大值是 64 KB。 </p><p><strong>下一个首部(next header)</strong>—— 8 位。它相当于 IPv4 的协议字段或可选字段。 </p><p><strong>跳数限制(hop limit)</strong>—— 8 位。源站在数据报发出时即设定跳数限制。路由器在转发数据报时将跳数限制字段中的值减 1。当跳数限制的值为零时，就要将此数据报丢弃。 </p><p><strong>源地址</strong>—— 128 位。是数据报的发送站的 IP 地址。 </p><p><strong>目的地址</strong>—— 128 位。是数据报的接收站的 IP 地址。 </p><p>IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理。</p><p>数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。这样就<strong>大大提高了路由器的处理效率</strong>。 </p><p>在 RFC 2460 中定义了六种扩展首部：</p><ol><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项 </li></ol><h2 id="IPv6-的地址"><a href="#IPv6-的地址" class="headerlink" title="IPv6 的地址"></a>IPv6 的地址</h2><p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：</p><ol><li><strong>单播 (unicast)</strong>：传统的点对点通信。</li><li><strong>多播 (multicast)</strong>：一点对多点的通信。</li><li><strong>任播 (anycast)</strong>：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。</li></ol><p>IPv6 将实现 IPv6 的主机和路由器均称为结点。一个结点就可能有多个与链路相连的接口。IPv6 地址是分配给结点上面的接口的。</p><ol><li>一个接口可以有多个单播地址。</li><li>其中的任何一个地址都可以当作到达该结点的目的地址。即一个结点接口的单播地址可用来唯一地标志该结点。</li></ol><p>为了使地址再稍简洁些，IPv6 使用冒号十六进制记法(colon hexadecimal notation, 简写为 colon hex)。每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF，在十六进制记法中，允许把数字前面的 0 省略。例如把 0000 中的前三个 0 省略，写成 1 个 0。</p><p>冒号十六进制记法可以允许<strong>零压缩 (zero compression)</strong>，即一连串连续的零可以为一对冒号所取代。</p><p>FF05:0:0:0:0:0:0:B3    可压缩为：<br>FF05::B3<br><strong>注意：在任一地址中只能使用一次零压缩。</strong></p><p>冒号十六进制记法可结合使用点分十进制记法的后缀，这种结合在 IPv4 向 IPv6 的转换阶段特别有用。</p><p>例如：0:0:0:0:0:0:128.10.2.1 再使用零压缩即可得出：  ::128.10.2.1</p><p><strong>CIDR 的斜线表示法仍然可用。</strong><br>例如：60 位的前缀 12AB00000000CD3 可记为：<br>    12AB:0000:0000:CD30:0000:0000:0000:0000/60<br>或 12AB::CD30:0:0:0:0/60 （零压缩）<br>或 12AB:0:0:CD30::/60 （零压缩）</p><p>IPv6地址分类</p><table><thead><tr><th>地址类型</th><th>二进制前缀</th></tr></thead><tbody><tr><td>未指明地址</td><td>00…0（128位），可记为 ::/128。</td></tr><tr><td>环回地址</td><td>00…1（128位），可记为 ::1/128。</td></tr><tr><td>多播地址</td><td>11111111（8位），可记为 FF00::/8。</td></tr><tr><td>本地链路单播地址</td><td>1111111010（10位）,  可记为 FE80::/10。</td></tr><tr><td>全球单播地址</td><td>（除上述四种外，所有其他的二进制前缀）</td></tr></tbody></table><p><strong>未指明地址</strong>：这是 16 字节的全 0 地址，可缩写为两个冒号“::”。这个地址只能为还没有配置到一个标准的 IP 地址的主机当作源地址使用。这类地址仅此一个。</p><p><strong>环回地址：</strong>即 0:0:0:0:0:0:0:1（记为 ::1）。作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</p><p><strong>多播地址：</strong>功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1/256。</p><p><strong>本地链路单播地址 (Link-Local Unicast Address)</strong> ：有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1/1024。（也就是<strong>专用网</strong>，[虚拟专用网 VPN](#虚拟专用网 VPN)会聊到这部分）</p><p><strong>全球单播地址</strong><br>IPv6 的这一类单播地址是使用得最多的一类。<br>曾提出过多种方案来进一步划分这 128 位的单播地址。<br>根据 2006 年发布的草案标准 RFC 4291 的建议，  IPv6 单播地址的划分方法非常灵活。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163300216.png" alt="image-20210416163300216"></p><h2 id="从-IPv4-向-IPv6-过渡"><a href="#从-IPv4-向-IPv6-过渡" class="headerlink" title="从 IPv4 向 IPv6 过渡"></a>从 IPv4 向 IPv6 过渡</h2><p>向 IPv6 过渡只能采用逐步演进的办法，同时，还必须使新安装的 IPv6 系统能够向后兼容：IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由。两种向 IPv6 过渡的策略：</p><ol><li><strong>使用双协议栈</strong></li><li><strong>使用隧道技术</strong></li></ol><h3 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h3><p>双协议栈 (dual stack) 是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有两个协议栈，一个 IPv4 和一个 IPv6。</p><p>双协议栈的主机（或路由器）记为 IPv6/IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</p><p>双协议栈主机在和 IPv6 主机通信时是采用 IPv6 地址，而和 IPv4 主机通信时就采用 IPv4 地址。</p><p>根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163413506.png" alt="image-20210416163413506"></p><h3 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h3><p>在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报，整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的 IPv6 协议栈。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163442462.png" alt="image-20210416163442462"></p><h2 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h2><p>IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。</p><p>因此 IPv6 也需要使用 <strong>ICMP</strong> 来反馈一些差错信息。新的版本称为 ICMPv6。</p><p><strong>地址解析协议 ARP 和网际组管理协议 IGMP 协议的功能都已被合并到 ICMPv6 中。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163550279.png" alt="image-20210416163550279"></p><p>CMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。</p><p>ICMPv6 还增加了几个定义报文的功能及含义的其他协议。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163605022.png" alt="image-20210416163605022"></p><h1 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h1><h2 id="IP-多播的基本概念"><a href="#IP-多播的基本概念" class="headerlink" title="IP 多播的基本概念"></a>IP 多播的基本概念</h2><p>IP 多播 (multicast，以前曾译为组播) 已成为互联网的一个热门课题。</p><blockquote><p>在互联网上进行多播就叫做 IP 多播。<br>互联网范围的多播要靠路由器来实现。<br>能够运行多播协议的路由器称为<strong>多播路由器(multicast router)</strong>。当然它<strong>也可以转发普通的单播IP数据报</strong>。</p></blockquote><p><strong>目的：更好地支持一对多通信。</strong></p><p><strong>一对多通信：一个源点发送到许多个终点</strong>。</p><p>例如，实时信息的交付（如新闻、股市行情等），<strong>软件更新</strong>，<strong>交互式会议</strong>及其他多媒体通信。</p><p>采用单播方式，向 90 台主机传送，同样的视频节目需要发送 90 个单播，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163820605.png" alt="image-20210416163820605"></p><p>采用多播方式，只需发送一次到多播组。<strong>路由器复制分组</strong>。<strong>局域网具有硬件多播功能</strong>，不需要复制分组。</p><p>这样的好处是：当多播组的主机数很大时（如成千上万个），采用多播方式就可明显地减轻网络中各种资源的消耗。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416163835811.png" alt="image-20210416163835811"></p><h3 id="多播-IP-地址"><a href="#多播-IP-地址" class="headerlink" title="多播 IP 地址"></a>多播 IP 地址</h3><ul><li>IP 多播所传送的分组需要使用多播 IP 地址。</li><li>在多播数据报的目的地址写入的是<strong>多播组的标识符</strong>。</li><li>多播组的标识符就是 <strong>IP 地址中的 D 类地址</strong>（多播地址，前面有提到过——[ip地址的分类](#分类的 IP 地址)）。</li><li><strong>每一个 D 类地址标志一个多播组</strong>。</li><li><strong>多播地址只能用于目的地址</strong>，不能用于源地址。</li></ul><h3 id="多播数据报"><a href="#多播数据报" class="headerlink" title="多播数据报"></a>多播数据报</h3><p>多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的<strong>协议字段值是 2，表明使用网际组管理协议 IGMP</strong>。</p><p>多播数据报也是<strong>“尽最大努力交付”</strong>，不保证一定能够交付多播组内的所有成员。</p><p>对<strong>多播数据报不产生 ICMP 差错报文</strong>。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p><h2 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h2><p>互联网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5E。因此 TCP/IP 协议使用的以太网地址块的范围是<strong>从   00-00-5E-00-00-00 到   00-00-5E-7F-FF-FF</strong> ，不难看出（挺难看出的），在每一个地址中，只有23位可用作多播。D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416164552924.png" alt="image-20210416164552924"></p><p>由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，<strong>还要在 IP 层利用软件进行过滤，</strong>把不是本主机要接收的数据报丢弃。</p><h2 id="网际组管理协议-IGMP-和多播路由选择协议"><a href="#网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="网际组管理协议 IGMP 和多播路由选择协议"></a>网际组管理协议 IGMP 和多播路由选择协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了使路由器知道多播组成员的信息，需要利用<strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong>。</p><p>连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416165016871.png" alt="image-20210416165016871"></p><p>IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上<strong>。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416165127191.png" alt="image-20210416165127191"></p><p>多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</p><p>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个<strong>多播数据报从什么地方来和要到什么地方去。</strong> </p><p>多播数据报<strong>可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。</strong> </p><h3 id="网际组管理协议-IGMP"><a href="#网际组管理协议-IGMP" class="headerlink" title="网际组管理协议 IGMP"></a>网际组管理协议 IGMP</h3><p>和 ICMP 相似，<strong>IGMP 使用 IP 数据报传递其报文</strong>（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。 </p><h4 id="第一阶段：加入多播组"><a href="#第一阶段：加入多播组" class="headerlink" title="第一阶段：加入多播组"></a>第一阶段：加入多播组</h4><p>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。</p><h4 id="第二阶段：探询组成员变化情况"><a href="#第二阶段：探询组成员变化情况" class="headerlink" title="第二阶段：探询组成员变化情况"></a>第二阶段：探询组成员变化情况</h4><p>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。</p><p>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p><p><strong>在主机和多播路由器之间的所有通信都是使用 IP 多播。</strong></p><p>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒发送一次。</p><p>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。 </p><p>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</p><p>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。 </p><h3 id="多播路由选择"><a href="#多播路由选择" class="headerlink" title="多播路由选择"></a>多播路由选择</h3><p>多播路由选择协议尚未标准化。一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。</p><p><strong>多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</strong></p><p>在多播转发树上的路由器不会收到重复的多播数据报。对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>多播路由选择协议在转发多播数据报时使用三种方法：</p><ol><li>洪泛与剪除</li><li>隧道技术 (tunneling)</li><li>基于核心的发现技术 </li></ol><h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。</p><p>一开始，路由器转发多播数据报使用洪泛的方法（这就是<strong>广播</strong>）。<br>为了避免兜圈子，采用了叫做<strong>反向路径广播 RPB</strong> (Reverse Path Broadcasting) 的策略。 </p><p>什么是RPB</p><blockquote><p>路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</p><p>如果存在几条同样长度的最短路径，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。 </p><p>最后就得出了用来转发多播数据报的多播转发树，以后就按这个多播转发树转发多播数据报。避免了多播数据报的兜圈子，同时每一个路由器也不会接收重复的多播数据报。</p></blockquote><p>要点</p><ul><li>如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。</li><li>当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416171012381.png" alt="image-20210416171012381"></p><h4 id="隧道技术-tunneling"><a href="#隧道技术-tunneling" class="headerlink" title="隧道技术 (tunneling)"></a>隧道技术 (tunneling)</h4><p>隧道技术适用于<strong>多播组的位置在地理上很分散</strong>的情况。</p><p>简单地说就是讲多播数据报进行封装成单播数据包，然后在不支持多播的网络上传递，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416171052103.png" alt="image-20210416171052103"></p><h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="基于核心的发现技术"></a>基于核心的发现技术</h4><p>这种方法对于多播组的大小在较大范围内变化时都适合。这种方法是<strong>对每一个多播组 G 指定一个核心(core) 路由器，给出它的 IP 单播地址。</strong>核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。</p><p>没了，就这样 </p><h1 id="虚拟专用网-VPN-和网络地址转换-NAT"><a href="#虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="虚拟专用网 VPN 和网络地址转换 NAT"></a>虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。</p><p>所以地址被分成了两种——本地地址与全球地址</p><p><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p><p><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </p><p>但是在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</p><p>解决方法：RFC 1918 指明了一些专用地址 (private address)。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416172336933.png" alt="image-20210416172336933"></p><p>采用这样的专用 IP 地址的互连网络称为<strong>专用互联网</strong>或<strong>本地互联网</strong>，或更简单些，就叫做<strong>专用网</strong>。<br>因为这些专用地址仅在本机构内部使用。<strong>专用IP地址也叫做可重用地址 (reusable address)</strong>。</p><blockquote><p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。</p></blockquote><p>“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通信专线，而VPN只是在效果上和真正的专用网一样。</p><p>如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p><p>用隧道技术实现虚拟专用网（如下图）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416172632581.png" alt="image-20210416172632581"></p><p>具体看看隧道技术如何实现</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416172718117.png" alt="image-20210416172718117"><br>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联网 (intranet)，表示部门 A 和 B 都是在同一个机构的内部。一个机构和某些外部机构共同建立的虚拟专用网 VPN 又称为外联网 (extranet)。 它们都是基于 TCP/IP 协议的。</p><h3 id="远程接入-VPN"><a href="#远程接入-VPN" class="headerlink" title="远程接入 VPN"></a>远程接入 VPN</h3><p>远程接入 VPN (remote access VPN)可以满足外部流动员工访问公司网络的需求。</p><p>在外地工作的员工拨号接入互联网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。 </p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>如何在专用网上使用专用地址的主机与互联网上的主机通信</p><p>想象一下，咱们用的校园网，如果细心点的话你会发现它就是一个本地互联网，而如果你连上了校园网wifi，不通过登录你是可以访问得到校园网里面的某些网址的，也就是内部互相访问，但是一旦你需要上个百度啥的，你就需要登录自己的校园网账号，那这是怎么做到滴呢，这个问题就和上面那个问题一致</p><p>有两种方法</p><ol><li>再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。</li><li>采用网络地址转换 NAT。这是目前使用得最多的方法。</li></ol><h3 id="NAT使用前提"><a href="#NAT使用前提" class="headerlink" title="NAT使用前提"></a>NAT使用前提</h3><p>需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。<br>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416173906968.png" alt="image-20210416173906968"></p><ol><li>内部主机 A 用本地地址 IPA 和互联网上主机 B 通信所发送的数据报必须经过 NAT 路由器。</li><li>NAT 路由器将数据报的<strong>源地址 IPA 转换成全球地址 IPG</strong> ，并把转换结果记录到NAT地址转换表中，目的地址 IPB 保持不变，然后发送到互联网。</li><li>NAT 路由器收到主机 B 发回的数据报时，知道数据报中的源地址是  IPB  而目的地址是 <strong>IPG</strong>  。</li><li>根据 NAT 转换表，NAT 路由器将目的地址 IPG 转换为 IPA ，转发给最终的内部主机 A。 </li></ol><p>可以看出，在内部主机与外部主机通信时，在NAT路由器上发生了两次地址转换：离开专用网时：替换源地址，将内部地址替换为全球地址；进入专用网时：替换目的地址，将全球地址替换为内部地址；</p><table><thead><tr><th>方向</th><th>字段</th><th>旧的IP地址</th><th>新的IP地址</th></tr></thead><tbody><tr><td>出</td><td>源IP地址</td><td>192.168.0.3</td><td>172.38.1.5</td></tr><tr><td>入</td><td>目的IP地址</td><td>172.38.1.5</td><td>192.168.0.3</td></tr><tr><td>出</td><td>源IP地址</td><td>192.168.0.7</td><td>172.38.1.6</td></tr><tr><td>入</td><td>目的IP地址</td><td>172.38.1.6</td><td>192.168.0.7</td></tr></tbody></table><p>当 NAT 路由器具有 <strong>n 个全球 IP 地址时</strong>，专用网内<strong>最多可以同时有 n 台主机接入到互联网</strong>。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的全球 IP 地址。</p><p><strong>通过 NAT 路由器的通信必须由专用网内的主机发起。专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。</strong></p><h3 id="网络地址与端口号转换-NAPT"><a href="#网络地址与端口号转换-NAPT" class="headerlink" title="网络地址与端口号转换 NAPT"></a>网络地址与端口号转换 NAPT</h3><p>为了更加有效地利用 NAT 路由器上的全球IP地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，<strong>共用一个 NAT 路由器上的全球 IP 地址</strong>，因而可以同时和互联网上的不同主机进行通信。</p><p><strong>使用端口号的 NAT 叫做网络地址与端口号转换NAPT (Network Address and Port Translation)</strong>，而不使用端口号的 NAT 就叫做传统的 NAT (traditional NAT)。</p><p>举个栗子，如下表所示，讲专用网内的ip地址进行转换</p><table><thead><tr><th>方向</th><th>字段</th><th>旧的IP地址和端口号</th><th>新的IP地址和端口号</th></tr></thead><tbody><tr><td>出</td><td>源IP地址:TCP源端口</td><td>192.168.0.3:30000</td><td>172.38.1.5:40001</td></tr><tr><td>出</td><td>源IP地址:TCP源端口</td><td>192.168.0.4:30000</td><td>172.38.1.5:40002</td></tr><tr><td>入</td><td>目的IP地址:TCP目的端口</td><td>172.38.1.5:40001</td><td>192.168.0.3:30000</td></tr><tr><td>入</td><td>目的IP地址:TCP目的端口</td><td>172.38.1.5:40002</td><td>192.168.0.4:30000</td></tr></tbody></table><p>NAPT把专用网内不同的源 IP 地址，都转换为同样的全球 IP 地址。但对源主机所采用的 TCP 端口号（不管相同或不同），则转换为不同的新的端口号。因此，当 NAPT 路由器收到从互联网发来的应答时，就可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从 NAPT 转换表中找到正确的目的主机。</p><h1 id="多协议标记交换-MPLS"><a href="#多协议标记交换-MPLS" class="headerlink" title="多协议标记交换 MPLS"></a>多协议标记交换 MPLS</h1><p><strong>“多协议”</strong>表示在 MPLS 的上层可以采用多种协议，例如：IP，IPX；可以使用多种数据链路层协议，例如：PPP，以太网，ATM 等。<strong>“标记”</strong>是指每个分组被打上一个标记，根据该标记对分组进行转发。</p><p>为了实现交换，可以利用面向连接的概念，使每个分组携带一个叫做标记 (label) 的小整数。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记值来检索分组转发表。 这样就比查找路由表来转发分组要快得多（下面会详细讲述其差别）。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416181924069.png" alt="image-20210416181924069"></p><p><strong>MPLS 的特点</strong></p><p>MPLS 并没有取代 IP，而是作为一种 IP 增强技术，被广泛地应用在互联网中。</p><p>MPLS 具有以下三个方面的特点：</p><ol><li>支持面向连接的服务质量；</li><li>支持流量工程，平衡网络负载；</li><li>有效地支持虚拟专用网 VPN。</li></ol><h2 id="MPLS-的工作原理"><a href="#MPLS-的工作原理" class="headerlink" title="MPLS 的工作原理"></a>MPLS 的工作原理</h2><h3 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h3><p>首先来看看传统的IP 分组的转发</p><p>(1) 在传统的 IP 网络中，分组每到达一个路由器后，都必须提取出其目的地址，按目的地址查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址（请注意，前缀的长度是不确定的）。</p><p>(2) 当网络很大时，查找含有大量项目的路由表要花费很多的时间。</p><p>(3) 在出现突发性的通信量时，往往还会使缓存溢出，这就会引起分组丢失、传输时延增大和服务质量下降。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416182509873.png" alt="image-20210416182509873"></p><p>而MPLS 协议的基本原理如下</p><p>在 <strong>MPLS 域的入口处</strong>，<strong>给每一个 IP 数据报打上固定长度“标记”</strong>，然后对打上标记的 IP 数据报用<strong>硬件</strong>进行<strong>转发</strong>。</p><p>采用硬件技术对打上标记的 IP 数据报进行转发就称为<strong>标记交换</strong>。</p><p>“交换”也表示在转发时<strong>不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行转发</strong>。</p><p><strong>MPLS 域 (MPLS domain)</strong> 是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的标记交换路由器 LSR (Label Switching Router)。</p><p>LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，<strong>但在这之前LSR 需要使用路由选择功能构造转发表</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416182738831.png" alt="image-20210416182738831"></p><h2 id="MPLS-的基本工作过程"><a href="#MPLS-的基本工作过程" class="headerlink" title="MPLS 的基本工作过程"></a>MPLS 的基本工作过程</h2><p>(1)  MPLS 域中的各 LSR 使用专门的<strong>标记分配协议 LDP</strong> 交换报文，并找出<strong>标记交换路径 LSP</strong>。各 LSR 根据这些路径<strong>构造出分组转发表</strong>。 </p><p>(2)  分组进入到 MPLS 域时， MPLS <strong>入口结点把分组打上标记</strong>，并按照转发表将分组转发给下一个 LSR。给 IP 数据报打标记的过程叫做<strong>分类 (classification)</strong>。</p><p>(3) 一个标记仅仅在两个标记交换路由器 LSR 之间才有意义。分组每经过一个 LSR，<strong>LSR 就要做两件事</strong>：<strong>一是转发</strong>，<strong>二是更换新的标记</strong>，即把入标记更换成为出标记。这就叫做标记对换 (label swapping)。</p><p>下面是转发表的一个举例</p><table><thead><tr><th>入接口</th><th>入标记</th><th>出接口</th><th>出标记</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>1</td><td>1</td></tr></tbody></table><p>该表的含义是含义：从入接口 0 收到一个入标记为 3 的IP 数据报，转发时，应当把该IP数据报从出接口 1 转发出去，同时把标记对换为 1。</p><p>(4) 当分组离开 MPLS 域时，MPLS 出口结点把分组的标记去除。再以后就按照一般分组的转发方法进行转发。</p><blockquote><p>上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为<strong>显式路由选择 (explicit routing)</strong>，它和互联网中通常使用的“<strong>每一个路由器逐跳进行路由选择</strong>”有着很大的区别。</p></blockquote><h2 id="转发等价类-FEC"><a href="#转发等价类-FEC" class="headerlink" title="转发等价类 FEC"></a>转发等价类 FEC</h2><p>MPLS 有个很重要的概念就是<strong>转发等价类 FEC</strong> (Forwarding Equivalence Class)。“转发等价类”就是<strong>路由器按照同样方式对待的分组的集合</strong>。 </p><blockquote><p>“按照同样方式对待”表示：从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。</p></blockquote><p>划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。</p><p>入口结点并不是给每一个分组指派一个不同的标记，而是将属于同样 FEC 的分组都指派同样的标记。</p><p>FEC 和标记是一一对应的关系。</p><p>这样，就可以把它用于<strong>负载平衡</strong>啦，如下图流量工程</p><h3 id="流量工程"><a href="#流量工程" class="headerlink" title="流量工程"></a>流量工程</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416183529710.png" alt="流量工程"></p><p>(1) 网络管理员采用自定义的 FEC 就可以更好地管理网络的资源。</p><p>(2) 这种均衡网络负载的做法也称为<strong>流量工程 TE</strong> (Traffic Engineering) 或<strong>通信量工</strong>程。</p><h2 id="MPLS-首部的位置与格式"><a href="#MPLS-首部的位置与格式" class="headerlink" title="MPLS 首部的位置与格式"></a>MPLS 首部的位置与格式</h2><p>MPLS 并不要求下层的网络都使用面向连接的技术。下层的网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。这就需要使用一种封装技术：<strong>在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部</strong>。</p><p><strong>从层次的角度看，MPLS 首部就处在第二层和第三层之间。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416183818917.png" alt="image-20210416183818917"></p><p><strong>“给 IP 数据报打上标记”</strong>其实就是在以太网的帧首部和  IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210416183828881.png" alt="image-20210416183828881"></p><p><strong>MPLS 首部共包括以下四个字段：</strong></p><p>(1) 标记值（占 20 位）。可以同时容纳高达 220 个流（即 1048576 个流）。实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</p><p>(2) 试验（占 3 位）。目前保留用作试验。</p><p>(3) 栈S（占 1 位）。在有“标记栈”时使用。</p><p>(4) 生存时间TTL（占 8 位）。用来防止 MPLS 分组在 MPLS 域中兜圈子。</p>]]></content>
    
    <summary type="html">
    
      内容最多、计算题最多也最重要的一章——网络层
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于Vue的新拟态版ToDoList（待办事项）</title>
    <link href="http://dong-666.github.io/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/"/>
    <id>http://dong-666.github.io/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/</id>
    <published>2021-04-03T14:30:05.000Z</published>
    <updated>2021-04-03T14:33:11.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基于Vue半全家桶的新拟态板ToDoList，一个todolist而已，用几乎Vue全家桶是不是有点小题大做，是的，必须的，因为要巩固的知识，并且功能也相应的增加了，你可以打卡想看的书或者电影，以及小小的改变了todolist的相应逻辑，当天未完成的ToDo会累计到待完成任务，看着一天一天积下来的待办，多多少少希望减少你的惰性吧（希望目的达到），从而激发你一天满满的动力</p><p><strong>注意：所使用的是localStorage存储数据（没用服务器），所以，如果你一不小心用了什么清垃圾软件或者手动清掉浏览器数据的话，它会消失，它会消失，它会消失</strong></p><p>采用纯less写样式，只写了PC端响应式布局，没做移动端适配（就不要尝试用手机打开了，大丑）</p><p><a href="https://ypigy.gitee.io/todolist" target="_blank" rel="noopener">在线地址</a></p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol><li>输入代办，按下回车键，添加到当天待办事项</li><li>点击完成按钮，完成该代办，添加至完成事项</li><li>点击删除按钮，删除该待办</li><li>动态显示已完成和未完成事项数量</li><li>当天未完成待办，第二天添加至待完成任务，可在第二天点击“今天完成”重新添加至我的一天中</li><li>阅读选项打卡想看的书</li><li>电影选项卡打卡想看的电影</li><li>点击头像就是回到我的博客啦</li><li>导航栏右侧文字根据时间改变相应问候语</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/image-20210403153631218.png" alt="image-20210403153631218"></p><p><img src= "/img/loading.gif" data-src="/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/image-20210403165129933.png" alt="image-20210403165129933"></p><h1 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h1><ul><li>Vue</li><li>Vue CLI</li><li>Vue Router</li><li>Less</li><li>webpack</li></ul><h1 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h1><p><img src= "/img/loading.gif" data-src="/2021/04/03/%E6%96%B0%E6%8B%9F%E6%80%81todolist/image-20210403172406380.png" alt="image-20210403172406380"></p><p>主要划分为三个大组件</p><p><strong>NavBar</strong></p><ul><li>分为左中右三个插槽</li><li>中间添加待办事项</li><li>左插槽展示当前路由信息</li><li>右插槽按时间显示问候信息</li></ul><p><strong>SideBar</strong></p><ul><li>用来控制路由的主要组件</li><li>分为两个部分，一个头像模块，一个路由切换模块</li><li>路由切换模块放置切换路由的小item</li></ul><p><strong>TaskBar</strong></p><ul><li>放置待办的组件</li><li>根据待办状态显示不同状态的item</li></ul><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><p>最重要的当然就是侦听数据的改变啦，毕竟你时时刻刻都在改变数据，vue官网<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watch函数介绍</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听数据变化</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  mydayList: &#123;</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 mydayList 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    handler()&#123;</span><br><span class="line">      saveData( <span class="keyword">this</span>.mydayList, <span class="string">"myday"</span>)</span><br><span class="line">      getData()</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: <span class="literal">true</span>          </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过监听mydayList数据的变化，实时保存改变后的数据以及加载保存后的数据</p><p>其它就是简单的localStorage增删改查操作啦</p><h1 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h1><p>这里通过函数封装，得到localStorage增删查操作，并单独设置成一个js文件，后面组件需要用到即可直接导入使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取本地数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">dataName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// localStorge为window内置属性，用于在浏览器存储本地信息</span></span><br><span class="line">  <span class="comment">// 该数据除非手动删除，否则会一直存在</span></span><br><span class="line">  <span class="comment">// let data = localStorage.getItem("todoList") //取值</span></span><br><span class="line">  <span class="keyword">let</span> data = localStorage.getItem(dataName) <span class="comment">//取值</span></span><br><span class="line">  <span class="keyword">if</span> (data !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//ES6将变量作为键→[变量名]</span></span><br><span class="line">    <span class="comment">// return JSON.parse(data).[dataName] //将数据转换为json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存本地数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params">data, dataName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//JSON.stringify()将json数据转换为字符串</span></span><br><span class="line">  localStorage.setItem(dataName, <span class="built_in">JSON</span>.stringify(data)) <span class="comment">//设值    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params">index, dataName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取本地数据</span></span><br><span class="line">  <span class="keyword">let</span> data = getData(dataName)</span><br><span class="line">  <span class="comment">// let index = index //获取索引号</span></span><br><span class="line">  <span class="comment">//改本地数据（删除数据）</span></span><br><span class="line">  data.splice(index, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">//保存本地数据</span></span><br><span class="line">  saveData(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就是简单的给各个组件注册事件，然后执行相关操作就可以啦</p>]]></content>
    
    <summary type="html">
    
      小破站自带Vue-ToDoList操作手册＋制作过程
    
    </summary>
    
    
      <category term="Vue" scheme="http://Dong-666.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://Dong-666.github.io/tags/Vue/"/>
    
      <category term="新拟态" scheme="http://Dong-666.github.io/tags/%E6%96%B0%E6%8B%9F%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>利用斐波拉契数列理解递归</title>
    <link href="http://dong-666.github.io/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/"/>
    <id>http://dong-666.github.io/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/</id>
    <published>2021-03-23T02:30:52.000Z</published>
    <updated>2021-03-29T07:48:03.570Z</updated>
    
    <content type="html"><![CDATA[<p>递归是啥，你可以去谷歌一下，没有解答，你就会一直循环下去，直到你了解了递归是啥，这便是递归，哈哈哈哈哈，我自己都不相信自己说的自己能不能理解，怎么来和你们讲呢，好的，就让我们直接用实例去理解递归吧</p><p>可以看看这个<a href="https://www.zhihu.com/zvideo/1219550997229522944" target="_blank" rel="noopener">视频</a>先，形象了解下</p><h2 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h2><p>什么是斐波拉契数列，如下数字所示</p><p>1、1、2、3、5、8、13、21、34、55、…</p><p>看到规律了有没有，从第三个开始，他的值总会等于它前两个值相加，像这样→<strong>f(n - 1) + f(n - 2)(n &gt;= 3)</strong>，好的，目前看起来这个原理很容易理解，让我们来点难的，现在我直接问你，当n = 11时，对应的斐波拉契数是多少，啊这这这这，让我拿出一张纸先，好的你开始了推演，计算第11的斐波拉契数，它等于第10的斐波拉契数加第9的斐波拉契数，第10的斐波拉契数是啥，是第9＋第8的斐波拉契数…..最终我们来到了1，所以我需要从1开始算起，算到第11个数：继续1，然后1+1，然后(1+1)+1，接着((1+1)+1)+(1+1)，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/image-20210311212046966.png" alt="image-20210311212046966"></p><p>最后我们来到了11这边，答案出来啦，就是89，这便是递归的过程，从哪里开始，从哪里结束，中间经历着一堆同样规则的计算</p><p>用网上的一个例子：你用你手中的钥匙（f(n - 1) + f(n - 2)）打开一扇门（n = 11），结果去发现前方还有一扇门（n=10)，紧接着你又用钥匙打开了这扇门，然后你又看到一扇门（n=9)，…，当你开到某扇门时（n = 2），发现前方是一堵墙(f(n) = 1(n = 1、2))无路可走了，你选择原路返回（(((((1+1)+1)+1)+1)+1)…）,最后返回最开始的门（n = 11）。</p><p>钥匙便是这个过程的规律（通用的关系式），第一个门就是你所需要求的值的索引，开过一个又一个需要相同钥匙开的门，墙便是终止条件，然后重新回去你就知道了你所求的值是什么，这便是整个过程了，这也就是递归</p><p>也可以通过下面的代码理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fac = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fac(n<span class="number">-1</span>) + fac(n<span class="number">-2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算斐波拉契数</span></span><br><span class="line"><span class="built_in">console</span>.log(fac(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>在哪里使用递归，你可以按以下三点进行分析</p><ol><li><p>你想完成一个怎样的功能</p><p>斐波拉契数列</p></li><li><p>终止条件 </p><p>1</p></li><li><p>找出关系式 </p><p>fac(n-1) + fac(n-2)</p></li></ol><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>接下来就让我们用递归解决阶乘的代码编写问题，按以下三点进行</p><ol><li><p>你想完成一个怎样的功能</p><p>当我给一个数字n时，计算出n以及n-1,n-2直到1时相乘的值</p></li><li><p>终止条件</p><p>1</p></li><li><p>找出关系式</p><p>n * f(n-1) </p></li></ol><p>开始编写代码</p><p>定义一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写终止条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算关系式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> n * jie(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jie(n<span class="number">-1</span>) * n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是我所理解的递归，与循环不同，循环是按照一个规律一直进行下去，直到终止条件发生，便停止循环，简单来说，即有去无回。而递归便是有去有回，就是从哪里开始，就从哪里结束。</p>]]></content>
    
    <summary type="html">
    
      自认为这篇文章自己写得并不是很好,没能把自己的理解写出来
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
