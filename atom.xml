<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dong</title>
  
  <subtitle>y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dong-666.github.io/"/>
  <updated>2022-04-17T12:33:24.157Z</updated>
  <id>http://dong-666.github.io/</id>
  
  <author>
    <name>天际线上的猪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm操作</title>
    <link href="http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/"/>
    <id>http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-18T07:00:00.000Z</published>
    <updated>2022-04-17T12:33:24.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm操作"><a href="#npm操作" class="headerlink" title="npm操作"></a>npm操作</h1><p>查看全局安装的npm包： <code>npm list -g -dept 0</code></p><p>解决因node版本过高而引起的依赖安装失败报错问题：<code>npm i --legacy-peer-deps</code> </p><p>清除缓存：<code>npm cache clean</code></p><p>（待补充…）</p>]]></content>
    
    <summary type="html">
    
      记录一些npm操作
    
    </summary>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="http://Dong-666.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据入库</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/</id>
    <published>2022-04-10T07:20:10.000Z</published>
    <updated>2022-04-17T12:49:52.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据入库方式"><a href="#数据入库方式" class="headerlink" title="数据入库方式"></a>数据入库方式</h2><p>打开MongoDB Compass（<a href="https://www.mongodb.com/try/download/compass" target="_blank" rel="noopener">点击此处下载官方安装包</a>）</p><p>下载完解压即可使用</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162053358.png" alt="image-20220211162053358"></p><p>连接数据库，默认一般是这个地址</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162138766.png" alt="image-20220211162138766"></p><p>接着选择你要导入的数据库数据集位置，然后点击ADD DATA→Import file 选项进行数据导入</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162802872.png" alt="image-20220211162802872"></p><p>然后就可以根据两种不同的数据源格式方式进行导入</p><h3 id="CSV格式导入"><a href="#CSV格式导入" class="headerlink" title="CSV格式导入"></a>CSV格式导入</h3><ol><li><p>选择完csv格式的数据后，在下面的Ignore empty strings选项中根据自己需求进行选择，打勾则是会将空数据忽略，取消勾选则会保留空数据</p></li><li><p>接着在下面的字段名中选择当前字段所属的类型，最好一一确定每个字段类型并选择好，避免后面因数据类型而引起的其他开发问题</p></li><li><p>确定好之后点击INPORT选项即可导入数据了</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163028242.png" alt="image-20220211163028242"></p></li><li><p>导入成功</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163445590.png" alt="image-20220211163445590"></p></li><li><p>最后提醒，一般现在的excel保存后的数据都是xlsx格式的文件类型，这样的文件类型导入后只会出现一堆乱码，所以记得在excel另存为csv类型的文件</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163807052.png" alt="image-20220211163807052"></p></li></ol><h3 id="JSON格式导入"><a href="#JSON格式导入" class="headerlink" title="JSON格式导入"></a>JSON格式导入</h3><ol><li><p>JSON数据比前面的csv数据好导，选择完文件即可导入了，so easy</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163958511.png" alt="image-20220211163958511"></p></li></ol><h2 id="出库方式"><a href="#出库方式" class="headerlink" title="出库方式"></a>出库方式</h2><p>出库方式非常简单，摸索摸索就出来了</p><p>通过下面的小按钮，然后可以选择根据查询条件导出，也可以选择全部导出，然后点击SELECT FIELDS，选择完想要导出的字段即可导出啦</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211164313741.png" alt="image-20220211164313741"></p><h2 id="控制台导出导入方式（cmd）"><a href="#控制台导出导入方式（cmd）" class="headerlink" title="控制台导出导入方式（cmd）"></a>控制台导出导入方式（cmd）</h2><ol><li><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport -d 数据库名 -c 数据集名 --type 数据类型 --headerline --file 文件名（记得加后缀）</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">mongoimport <span class="literal">-d</span> MZedu <span class="literal">-c</span> MiddleSchool -<span class="literal">-type</span> csv -<span class="literal">-headerline</span> -<span class="operator">-file</span> 梅城中学.csv</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>导出</strong></p><ol><li><p>管理员身份运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h 127.0.0.1 -d 数据库名 -o 保存路径</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport -d 数据库名 -c collections的名字 -o filename.json/filename.csv  -f field</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参数说明：</p><ol><li>-d   数据库名(database)</li><li>-c   collections名</li><li>-o   要存入的文件名(xxx.json/xxx.csv)</li><li>-f   输出特定属性列(一般情况下可以不加这个参数)</li></ol></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>MongoDB最新版（5.0）bin文件夹里面已经没有这两个导出程序了，所以上面的几个命令无法在5.0执行，但在4.2版本，自己试了试是可以的</p></blockquote><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170735586.png" alt="4.2"></p><p>对比可以看到，5.0已经没有该导入导出程序了</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170800643.png" alt="image-20220211170800643"></p>]]></content>
    
    <summary type="html">
    
      MongoDB数据入库
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Web存储</title>
    <link href="http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/"/>
    <id>http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/</id>
    <published>2022-04-10T07:00:00.000Z</published>
    <updated>2022-04-17T12:30:58.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies - HTTP | MDN (mozilla.org)</a></p><p>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</p><blockquote><p>🔺信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。</p><p>当机器处于不安全环境时，切记<em>不能</em>通过 HTTP Cookie 存储、传输敏感信息。</p></blockquote><p>客户端（浏览器端）可以修改cookie（所以某种意义上来讲它是不安全的，客户端可以随意修改或获取cookie的内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">documont.cookie <span class="comment">//获取</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'abcdefg'</span><span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。推荐阅读：<a href="https://juejin.cn/post/6844903812092674061" target="_blank" rel="noopener">深入了解浏览器存储–从cookie到WebStorage、IndexedDB</a></p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Window.sessionStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p><code>sessionStorage</code> 属性允许你访问一个，对应当前源的 session <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a> 对象。它与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener"><code>localStorage</code></a> 相似，不同之处在于 <code>localStorage</code> 里面存储的数据没有过期时间设置，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</li><li>打开多个相同的 URL 的 Tabs 页面，会创建各自的 <code>sessionStorage</code>。</li><li>关闭对应浏览器标签或窗口，会清除对应的 <code>sessionStorage</code>。 </li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">Window.localStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p>只读的<code>localStorage</code> 属性允许你访问一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener"><code>Document</code></a> 源（origin）的对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener"><code>sessionStorage</code></a>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除 。</p><p>应注意，无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，<strong>它们都特定于页面的协议。</strong></p><p>另外，<code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>该语法用于设置 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'myCat'</span>, <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于读取 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = localStorage.getItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除所有的 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除所有</span></span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>表格转自<a href="https://juejin.cn/post/6844903989096497159" target="_blank" rel="noopener">localStorage、sessionStorage、cookie、session几种web数据存储方式对比总结</a></p><table><thead><tr><th>分类</th><th>生命周期</th><th>存储容量</th><th>存储位置</th></tr></thead><tbody><tr><td>cookie</td><td>默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</td><td>4KB</td><td>保存在客户端，每次请求时都会带上</td></tr><tr><td>localStorage</td><td>理论上永久有效的，除非主动清除。</td><td>4.98MB（不同浏览器情况不同，safari 2.49M）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr><tr><td>sessionStorage</td><td>仅在当前网页会话下有效，关闭页面或浏览器后会被清除。</td><td>4.98MB（部分浏览器没有限制）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      吃块cookie？
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB环境配置过程</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-10T03:15:10.000Z</published>
    <updated>2022-04-17T12:49:54.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB配置过程"><a href="#MongoDB配置过程" class="headerlink" title="MongoDB配置过程"></a>MongoDB配置过程</h1><p>环境变量配置</p><p>右键”计算机”，点击”属性“，下拉选择”高级系统设置“→”环境变量“，在”系统变量“中双击”Path“，在后面添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MongoDB\Server\5.0\bin</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160446805.png" alt="image-20220211160446805"></p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160738853.png" alt="image-20220211160738853"></p>]]></content>
    
    <summary type="html">
    
      MongoDB配置过程
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>解决arcgis字段长度限制</title>
    <link href="http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
    <id>http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</id>
    <published>2022-03-28T08:00:00.000Z</published>
    <updated>2022-04-17T12:24:21.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决arcgis字段长度限制"><a href="#解决arcgis字段长度限制" class="headerlink" title="解决arcgis字段长度限制"></a>解决arcgis字段长度限制</h1><p>在一般的shp文件<img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092734837.png" alt="image-20220319092734837">下修改文本字段的长度，只要超过255，通常会现实这样一个错误</p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092714321.png" alt="image-20220319092714321"></p><p>解决方法为，新建一个个人地理数据库，再将该shp文件放到该数据库下，重新在该文件下的<code>属性</code>窗口修改文本字段的长度，现在无论你输入多少，都可以修改成功</p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092544606.png" alt="image-20220319092544606"></p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319093201270.png" alt="image-20220319093201270"></p>]]></content>
    
    <summary type="html">
    
      如题
    
    </summary>
    
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/categories/ArcGIS/"/>
    
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/tags/ArcGIS/"/>
    
      <category term="GIS" scheme="http://Dong-666.github.io/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>前端知识小汇总</title>
    <link href="http://dong-666.github.io/2022/03/05/study/"/>
    <id>http://dong-666.github.io/2022/03/05/study/</id>
    <published>2022-03-05T09:58:15.000Z</published>
    <updated>2022-03-08T00:38:37.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><p>🔴重点🟠难点🟡性能🟢算法🔵JS高阶🟣框架</p><h2 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h2><ol><li><p>get、post（请求参数长度限制）——HTTP协议</p><ol><li><a href="https://juejin.cn/post/6844903433674178574" target="_blank" rel="noopener">两者区别</a></li><li><a href="https://juejin.cn/post/6992933721703710750" target="_blank" rel="noopener">GET 和 POST</a></li></ol></li><li><p>原型链</p><ol><li><p>gitee -&gt; 原型链代码</p></li><li><p>processOn <a href="https://mp.processon.com/view/link/604b5ac963768958e9989002#map" target="_blank" rel="noopener">思维导图</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211217103257781.png" alt="image-20211217103257781"></p></li></ol></li><li><p>mouseover、mouseenter</p><ol><li><p><a href="https://blog.csdn.net/LPLIFE/article/details/80436623" target="_blank" rel="noopener">文章</a></p></li><li><p>共同点：鼠标移入元素触发事件</p></li><li><p>不同点：</p><ul><li><p>mouseover：若存在子元素，则会冒泡触发多次mouseover事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseover.gif" alt="mouseover"></p></li><li><p>mouseenter：不存在子元素冒泡，也就是鼠标移入只会触发一次mouseenter事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseenter.gif" alt="mouseenter"></p></li></ul></li></ol></li><li><p><a href="https://juejin.cn/post/6844904126199889927" target="_blank" rel="noopener">可视区域高度</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/js%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.png" alt></p><p>可视区域就是不包括上下左右的工具栏、状态栏（滚动条特殊）。代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可视区域宽度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="comment">//可视区域高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"><span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><p>document.documentElement也可以为document.body</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平滚动条的位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft</span><br><span class="line"><span class="comment">//垂直滚动条位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollRight</span><br></pre></td></tr></table></figure></li><li><p>defer（异步加载js)</p><ol><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ol></li><li><p>防抖节流</p><ol><li><p>防抖（高阶）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, context, param</span>) </span>&#123;</span><br><span class="line">        clearTimeout(method.tId);</span><br><span class="line">        method.tId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          method.apply(context, param);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>防抖（闭包型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> out = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">          clearTimeout(out);</span><br><span class="line">          out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            method.call(that, args);</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>节流（自定义）</p><p><a href="https://juejin.cn/post/6844903669389885453" target="_blank" rel="noopener">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throlle</span>(<span class="params">method, timeout = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out;</span><br><span class="line">  <span class="keyword">let</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; timeout) &#123;</span><br><span class="line">      clearTimeout(out);</span><br><span class="line">      out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        method(...args);</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      method(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>事件流</p><ol><li><p><a href="https://juejin.cn/post/6844903741783556109" target="_blank" rel="noopener">JS事件流和事件委托</a></p></li><li><p><a href="https://juejin.cn/post/6844903834075021326" target="_blank" rel="noopener">你真的理解 事件冒泡 和 事件捕获</a>吗</p></li><li><p>阻止冒泡,阻止默认事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c 冒泡'</span>);</span><br><span class="line">    e.stopPropagation();<span class="comment">//阻止冒泡</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span><span class="comment">//阻止默认事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身</p></blockquote></li><li><p><a href="https://juejin.cn/post/6844903450493321223" target="_blank" rel="noopener">javascript 事件流</a></p></li></ol></li><li><p>JS拖拽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖动开始--&gt;拖动过程中--&gt;拖动结束</span></span><br><span class="line"><span class="comment">// 监听目标DOM的onmousedown事件→document的onmousemove→document的onmouseup</span></span><br><span class="line"><span class="comment">//记录旧坐标鼠标移动后记录下新坐标,通过新坐标减去旧坐标得出变化的坐标,然后改变其位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldX, oldY, newX, newY; <span class="comment">//存储新旧鼠标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素点击事件</span></span><br><span class="line">  ele.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    oldX = e.clientX; <span class="comment">//存储鼠标当前位置(初始化位置)</span></span><br><span class="line">    oldY = e.clientY;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.style.left &amp;&amp; !<span class="keyword">this</span>.style.top) &#123;</span><br><span class="line">      <span class="comment">//如果元素无初始值,则需要赋值</span></span><br><span class="line">      <span class="keyword">this</span>.style.left = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.style.top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      newX = e.clientX; <span class="comment">//存储移动后的鼠标位置</span></span><br><span class="line">      newY = e.clientY;</span><br><span class="line">      <span class="comment">// 移动后的位置 = 当前位置 - (移动后的鼠标位置-移动前的鼠标位置)</span></span><br><span class="line">      ele.style.top = <span class="built_in">parseFloat</span>(ele.style.top) + (newY - oldY) + <span class="string">'px'</span>;</span><br><span class="line">      ele.style.left = <span class="built_in">parseFloat</span>(ele.style.left) + (newX - oldX) + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">      oldX = newX; <span class="comment">//移动完后旧鼠标位置为新鼠标位置</span></span><br><span class="line">      oldY = newY;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标松开事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 解绑事件</span></span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js drag api</p><p><a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="noopener">HTML5 拖放（Drag 和 Drop）详解与实例 - 风雨后见彩虹 - 博客园 (cnblogs.com)</a></p><p>在被拖动的元素上需定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./PoinkoParrot2.jpeg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"draggable"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在拖放的过程中会触发以下事件：</p><ul><li><p>在拖动目标上触发事件(源元素):</p><ul><li>ondragstart - 用户开始拖动元素时触发</li><li>ondrag - 元素正在拖动时触发</li><li>ondragend - 用户完成元素拖动后触发</li></ul></li><li><p>释放目标时触发的事件:</p><ul><li>ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件</li><li>ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件</li><li>ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件</li><li>ondrop - 在一个拖动过程中，释放鼠标键时触发此事件</li></ul></li></ul></li><li><p>eval</p><ul><li><a href="https://juejin.cn/post/6938775708739207182" target="_blank" rel="noopener">Eval</a></li><li><a href="https://juejin.cn/post/6844903713140637709" target="_blank" rel="noopener">你不知道的 eval</a></li><li><a href="https://juejin.cn/post/6954380745871720462" target="_blank" rel="noopener">欺骗词法 eval 和 with</a></li></ul></li><li><p>AMD、CMD、CommonJs</p><ul><li><a href="https://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现 - ECMAScript 6入门</a></li><li><a href="https://juejin.cn/post/6844903576309858318" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul></li><li><p>🟠js监听对象属性改变（vue属性监听）</p><ul><li><a href="https://juejin.cn/post/6844903842828533767" target="_blank" rel="noopener">论如何监听一个对象某个属性的变化</a></li></ul></li><li><p>JS实现跨域</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li></ul></li><li><p>JS深度拷贝（浅拷贝、深拷贝…）</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211222145748666.png" alt="image-20211222145748666"></p></li><li><p>重排重绘</p><ul><li><a href="https://juejin.cn/post/6844903745914929165" target="_blank" rel="noopener">浏览器重绘(repaint)重排(reflow)与优化</a></li></ul></li><li><p>🟠JS全排列</p><ul><li><p><a href="https://juejin.cn/post/6844904191379374087" target="_blank" rel="noopener">前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">...chunks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span> (<span class="params">chunkIndex, prev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = chunks[chunkIndex];</span><br><span class="line">    <span class="keyword">let</span> isLast = chunkIndex === chunks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> chunk) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = prev.concat(val);</span><br><span class="line">      <span class="keyword">if</span> (isLast) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span></span><br><span class="line">        res.push(cur); <span class="comment">//将最后一个数组的所有选项分别压入</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        helper(chunkIndex + <span class="number">1</span>, cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 从属性数组下标为 0 开始处理</span></span><br><span class="line">  <span class="comment">// 并且此时的 prev 是个空数组</span></span><br><span class="line">  helper(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'iPhone X'</span>, <span class="string">'iPhone XS'</span>];</span><br><span class="line">  <span class="keyword">let</span> colors = [<span class="string">'黑色'</span>, <span class="string">'白色'</span>];</span><br><span class="line">  <span class="keyword">let</span> storages = [<span class="string">'64g'</span>, <span class="string">'256g'</span>];</span><br><span class="line">  <span class="keyword">let</span> res = combine(names, colors, storages);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="comment">/* result</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '256g' ]</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>  <img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211224151929493.png" alt="image-20211224151929493"></p></li></ul></li><li><p>this指向、隐式丢失、显式绑定</p><ul><li><a href="https://juejin.cn/post/6844904113352736776" target="_blank" rel="noopener">this绑定的四种方式：new，显式，隐式，默认</a></li></ul></li><li><p>🟠virtual dom</p><ul><li><a href="https://juejin.cn/post/6844903609667321863" target="_blank" rel="noopener">探索Virtual DOM的前世今生</a></li><li><a href="https://juejin.cn/post/6844903615652610055" target="_blank" rel="noopener">深入框架本源系列 —— Virtual Dom</a></li><li><a href="https://juejin.cn/post/6844903921442422791" target="_blank" rel="noopener">面试官问: 如何理解Virtual DOM？</a></li></ul></li><li><p>vue生命周期</p></li><li><p>🔴🟠Promise底层实现</p></li><li><p>事件监听</p><ul><li><a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">HTML DOM 事件对象</a></li><li><a href="https://juejin.cn/post/6844903886960984072" target="_blank" rel="noopener">一篇文章能否解决你事件监听的许多疑问</a></li><li>🔴🔵<a href="https://juejin.cn/post/6844903647197790221" target="_blank" rel="noopener">撸一个JS的事件管理</a></li><li>🔵<a href="https://juejin.cn/post/6844904069820055560" target="_blank" rel="noopener">🔥JavaScript 自定义事件如此简单！</a></li></ul></li><li><p>Generator</p><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112" target="_blank" rel="noopener">generator</a></p></li><li><p>基本使用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>生成自增id函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">next_id</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// !不是阻塞执行，是yield时跳出函数并储存当时的状态。</span></span><br><span class="line">    <span class="comment">// !执行next()时还原当时的状态，从上次yield的位置向下执行</span></span><br><span class="line">    <span class="keyword">yield</span> ++id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = next_id();</span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li></ul><ol start="22"><li><p>arguments（箭头函数）</p><ul><li><a href="https://juejin.cn/post/6844903616231260174" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li><li><a href="https://juejin.cn/post/6844903801799835655" target="_blank" rel="noopener">详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景</a></li><li><a href="https://juejin.cn/post/6844904152640782343" target="_blank" rel="noopener">曾经我以为我很懂箭头函数</a></li><li><a href="https://juejin.cn/post/6844904133409914894" target="_blank" rel="noopener">对阮一峰《ES6 入门》中箭头函数 this 描述的探究</a></li></ul></li><li><p>🔴🟠🔵继承</p><ul><li><a href="https://juejin.cn/post/6844903696111763470" target="_blank" rel="noopener">JavaScript常用八种继承方案</a></li><li><a href="https://juejin.cn/post/6844904094948130824" target="_blank" rel="noopener">🔥比继承家业还要简单的JS继承题-封装篇(牛刀小试)</a></li><li><a href="https://juejin.cn/post/6844903475021627400" target="_blank" rel="noopener">JS原型链与继承</a></li></ul></li><li><p>🔴script——async属性</p><ul><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ul></li><li><p>🔴jsonp——跨域的解决</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li><li><a href="https://juejin.cn/post/6844903462551945230" target="_blank" rel="noopener">原生 JavaScript 实现 AJAX、JSONP</a></li><li><a href="https://juejin.cn/post/6844903976505344013" target="_blank" rel="noopener">一分钟说完JSONP请求</a></li></ul></li><li><p>🔴ajax的返回状态——Fetch</p><ul><li><a href="https://juejin.cn/post/6844903618764603399" target="_blank" rel="noopener">Ajax原理一篇就够了</a></li><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/" target="_blank" rel="noopener">AJAX笔记 | Dong</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html" target="_blank" rel="noopener">Fetch API 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul></li><li><p>dns预加载（缓存）dns-preFetch</p><ul><li><a href="https://juejin.cn/post/6844903492490887182" target="_blank" rel="noopener">DNS Prefetching 的正确使用姿势</a></li><li><a href="https://juejin.cn/post/6915204591730556935" target="_blank" rel="noopener">preload、prefetch、preconnect 和 dns-prefetch 知多少</a></li></ul></li><li><p>🔵函数柯里化（currying）</p><ul><li><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">详解JS函数柯里化</a></li></ul></li><li><p>骨架屏</p><p><a href="https://www.jianshu.com/p/a72263d2d105" target="_blank" rel="noopener">什么是骨架屏 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/96455668" target="_blank" rel="noopener">如何实现优美的骨架屏 - 知乎 (zhihu.com)</a></p></li><li><p>🔴启动性能（异步）（前端性能优化）</p><ul><li><a href="https://juejin.cn/post/6892994632968306702" target="_blank" rel="noopener">前端性能优化 24 条建议（2020） - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6904517485349830670" target="_blank" rel="noopener">工作中如何进行前端性能优化(21种优化+7种定位方式) - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7020212914020302856" target="_blank" rel="noopener">写在 2021 的前端性能优化指南 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6844904195707895816" target="_blank" rel="noopener">前端性能优化总结 - 掘金 (juejin.cn)</a></li></ul></li><li><p>HTTP缓存机制</p><p><a href="https://juejin.cn/post/6844904100035821575#heading-59" target="_blank" rel="noopener">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903634002509832" target="_blank" rel="noopener">面试精选之http缓存 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903517702848526" target="_blank" rel="noopener">HTTP—-HTTP缓存机制 - 掘金 (juejin.cn)</a></p></li><li><p>websocket、AJAX</p><p><a href="https://juejin.cn/post/6844903544978407431" target="_blank" rel="noopener">WebSocket：5分钟从入门到精通 - 掘金 (juejin.cn)</a></p></li><li><p>TCP/IP模型（计算机网络）</p><p><a href="https://ypigy.gitee.io/2021/04/18/运输层/#传输控制协议TCP概述" target="_blank" rel="noopener">计算机网络-运输层 | Dong (gitee.io)</a></p><p>[计算机网络-网络层 | Dong (gitee.io)](<a href="https://ypigy.gitee.io/2021/04/18/网络层/#网际协议" target="_blank" rel="noopener">https://ypigy.gitee.io/2021/04/18/网络层/#网际协议</a> IP)</p></li><li><p>🟠gulp、webpack（打包原理）</p><p><a href="https://juejin.cn/post/6844903802382860296#heading-6" target="_blank" rel="noopener">Webpack 模块打包原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6917069979913289736#heading-15" target="_blank" rel="noopener">对比webpack，你更应该先掌握gulp【10分钟教你彻底掌握gulp】 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904038543130637#heading-22" target="_blank" rel="noopener">webpack打包原理 ? 看完这篇你就懂了 ! - 掘金 (juejin.cn)</a></p></li><li><p>PWA</p><p><a href="https://juejin.cn/post/6844904052166230030" target="_blank" rel="noopener">面试官：请你实现一个PWA 我：😭 - 掘金 (juejin.cn)</a></p></li><li><p>🔴单元测试</p><p><a href="https://juejin.cn/post/7039108357554176037" target="_blank" rel="noopener">如何做前端单元测试 - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/7049293284883038238" target="_blank" rel="noopener">前端单元测试入门与最佳实践 - 掘金 (juejin.cn)</a></p></li><li><p>🔴seo优化</p><p><a href="https://segmentfault.com/a/1190000019623624_vueseo" target="_blank" rel="noopener">基于Vue SEO的四种方案 - SegmentFault 思否</a></p><p><a href="https://juejin.cn/post/6980167371864424456" target="_blank" rel="noopener">前端搜索引擎优化（SEO）的技巧 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903824428105735#heading-4" target="_blank" rel="noopener">前端SEO优化 - 掘金 (juejin.cn)</a></p></li><li><p>grid栅格布局</p><p><a href="https://juejin.cn/post/6854573220306255880" target="_blank" rel="noopener">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p></li><li><p>bigint</p><p><a href="https://juejin.cn/post/6844903902295359502" target="_blank" rel="noopener">JS最新基本数据类型：BigInt - 掘金 (juejin.cn)</a></p></li><li><p>🔴🟠0.1+0.2 ？（是0.3吗）</p><p><a href="https://juejin.cn/post/7056934829920616461" target="_blank" rel="noopener">用了一天时间，我终于彻底搞懂了 0.1+0.2 是否等于 0.3！ - 掘金 (juejin.cn)</a></p></li><li><p>osi七层模型（计算机网路）</p><p><a href="https://ypigy.gitee.io/categories/计算机网络/" target="_blank" rel="noopener">分类: 计算机网络 | Dong (gitee.io)</a></p></li><li><p>🔴head、状态码</p><p><a href="https://ypigy.gitee.io/2020/07/28/http协议/" target="_blank" rel="noopener">http协议 | Dong (gitee.io)</a></p><p><a href="https://blog.csdn.net/wzx19840423/article/details/79073087" target="_blank" rel="noopener">http状态码总结_wzx19840423的专栏-CSDN博客_http状态码</a></p><p><a href="https://blog.csdn.net/u014346301/article/details/53995333" target="_blank" rel="noopener">HTTP状态码（HTTP Status Code）_Sweet oDream-CSDN博客</a></p></li><li><p>声明式绑定（REACT Query/ Apollo GtaphQL Client）<br>等有学react再来吧</p></li><li><p>假数据生产（Yapi、RAP2、Apifox）</p><ol><li><a href="https://hellosean1025.github.io/yapi/index.html" target="_blank" rel="noopener">YApi 接口管理平台 (hellosean1025.github.io)</a></li><li><a href="http://rap2.taobao.org/account/login" target="_blank" rel="noopener">RAP接口管理平台 (taobao.org)</a></li><li><a href="https://github.com/thx/rap2-delos" target="_blank" rel="noopener">阿里妈妈前端团队出品的开源接口管理工具RAP第二代</a></li><li><a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a></li></ol></li><li><p>BFF架构</p><p><a href="https://juejin.cn/post/6950530370810937352" target="_blank" rel="noopener">第 016 期 前后端经常争吵？ - BFF 了解一下 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7008840813069205512" target="_blank" rel="noopener">微服务/API时代的前端开发] BFF入门–5个实用的BFF使用案例 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903959333699598" target="_blank" rel="noopener">初识BFF架构设计 - 掘金 (juejin.cn)</a></p></li><li><p>🔴文档碎片</p><p><a href="https://juejin.cn/post/7012073594918273032" target="_blank" rel="noopener">前端性能优化：创建文档碎片 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/408738417" target="_blank" rel="noopener">性能优化之文档碎片 - 知乎 (zhihu.com)</a></p></li><li><p>🔴宏任务、微任务（同步异步）</p><p>直接看js代码and思维导图（可以的话整个笔记）</p></li><li><p>compose函数</p><p><a href="https://juejin.cn/post/6844904061821517832" target="_blank" rel="noopener">JavaScript中的compose函数和pipe函数 - 掘金 (juejin.cn)</a></p></li><li><p>forEach跳出循环（终止并返回值）</p><p><a href="https://juejin.cn/post/6971972782292729886" target="_blank" rel="noopener">面试官问我JS中forEach能不能跳出循环 - 掘金 (juejin.cn)</a>看完看看评论，挺有意思的</p></li><li><p>shell命令</p><p><a href="https://juejin.cn/post/6844903489911406599" target="_blank" rel="noopener">Shell常见命令实践 - 掘金 (juejin.cn)</a></p></li><li><p>git命令</p><ol><li>合并代码冲突（merge&amp;rebase）</li><li>代码回滚（reset&amp;checkout）</li><li>代码暂存（stash）</li></ol></li><li><p>linux命令</p></li><li><p>Element.</p><ol><li>getBounding</li><li>IntersectionOberver</li><li>createNodeIterator</li><li>getComputedStyle</li><li>getPropertyValue</li><li>MutationObserver</li></ol></li><li><p>ES6常用方法</p><ul><li><a href="https://juejin.cn/post/6906398702269628424" target="_blank" rel="noopener">混子前端24个解决工作问题的ES6代码片段 - 掘金 (juejin.cn)</a></li></ul></li></ol><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol><li><a href="https://chinese.freecodecamp.org/learn" target="_blank" rel="noopener">编程学习</a></li><li>面试题：<ul><li><a href="https://juejin.cn/post/6989422484722286600" target="_blank" rel="noopener">2021年我的前端面试准备 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7035259189966405668" target="_blank" rel="noopener">面试的时候面试官是这样问我Js基础的，角度真刁钻 - 掘金 (juejin.cn)</a></li></ul></li><li><a href="https://juejin.cn/post/7013247812628381704" target="_blank" rel="noopener">组件库</a></li><li><a href="https://juejin.cn/post/7026339412799651876" target="_blank" rel="noopener">Vue源码(一些数据结构)</a></li><li><a href="https://juejin.cn/post/7025868886914400293" target="_blank" rel="noopener">现代web开发困局</a></li><li><a href="https://www.zhihu.com/question/458213150" target="_blank" rel="noopener">为什么 WeakSet 和 WeakMap 无法获取到元素的数量，也无法迭代其中的元素</a></li><li><a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">JS垃圾回收机制</a></li><li><a href="https://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="noopener">前端性能优化</a></li><li><a href="https://segmentfault.com/a/1190000012571492" target="_blank" rel="noopener">gzip</a></li><li><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener">PWA</a></li><li><a href="https://juejin.cn/post/7007206194276204575#heading-26" target="_blank" rel="noopener">前端学习路线以及知识体系：</a></li><li><a href="https://juejin.cn/post/7038297948630827039" target="_blank" rel="noopener">11个非常有用的HTML单行代码🎃 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7048916480032768013" target="_blank" rel="noopener">「前端该如何优雅地Mock数据🏃」每个前端都应该学会的技巧 - 掘金 (juejin.cn)</a></li></ol>]]></content>
    
    <summary type="html">
    
      记录一下看过的前端知识点，进行汇总并整理
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
      <category term="前端" scheme="http://Dong-666.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>K最近邻算法KNN</title>
    <link href="http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-20T10:00:00.000Z</published>
    <updated>2022-03-02T08:00:45.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>KNN（K- Nearest Neighbor）法即K最邻近法，最初由 Cover和Hart于1968年提出，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路非常简单直观：如果一个样本在特征空间中的K个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别 </p><p>该方法的不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最邻近点。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。另外还有一种 Reverse KNN法，它能降低KNN算法的计算复杂度，提高分类的效率 </p><p>KNN算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分</p></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>准备数据，对数据进行预处理 。</li><li>计算测试样本点（也就是待分类点）到其他每个样本点的距离</li><li>对每个距离进行排序，然后选择出距离最小的K个点</li><li>对K个点所属的类别进行比较，根据少数服从多数的原则，将测试样本点归入在K个点中占比最高的那一类</li></ol><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221648768.png" alt="image-20220221221648768"></p><p>使用毕达哥拉斯公式计算A和B的相似性（距离），值越小，相似性越大</p><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221215435440.png" alt="image-20220221215435440"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221838593.png" alt="image-20220221221838593"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>原理上挺简单的，所以没解释，直接上代码，包含两个函数，一个毕达哥拉斯公式，一个KNN算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毕达哥拉斯  Math.sqrt((x1-x2)² + (y1 - y2)²)</span></span><br><span class="line"><span class="comment">// 传参：目标对象1，目标对象2，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pythagoras</span>(<span class="params">obj1, obj2, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> common = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj2[key]) &#123;</span><br><span class="line">      res.push(<span class="built_in">Math</span>.pow(<span class="built_in">parseFloat</span>(obj1[key]) - <span class="built_in">parseFloat</span>(obj2[key]), <span class="number">2</span>)); <span class="comment">//差值取平方</span></span><br><span class="line">      common.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">Math</span>.sqrt(res.reduce(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> (cur += next), <span class="number">0</span>)).toFixed(<span class="number">2</span>); <span class="comment">//累加取平方根且保留两位小数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; res, common &#125;;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法-KNN-毕达哥拉斯比较距离</span></span><br><span class="line"><span class="comment">// 传参：对象集合，当前对象，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kNN</span>(<span class="params">objs, newObj, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allDistance = []; <span class="comment">//存储所有距离</span></span><br><span class="line">  <span class="keyword">let</span> minDistance = <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//存储最小距离,默认js能读的最大数值</span></span><br><span class="line">  <span class="keyword">let</span> minObjName; <span class="comment">//存储最小对象名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> objs) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = pythagoras(objs[key], newObj); <span class="comment">//对每个对象执行毕达哥拉斯公式</span></span><br><span class="line">    allDistance.push(&#123; <span class="attr">distance</span>: res, <span class="attr">targetName</span>: key &#125;); <span class="comment">//将所有结果压入</span></span><br><span class="line">    <span class="comment">// res &lt; minDistance &amp;&amp; ((minDistance = res), (minObjName = key));</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历查找最小距离对象</span></span><br><span class="line">  <span class="keyword">let</span> resultObj = allDistance.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.distance - b.distance)[<span class="number">0</span>];</span><br><span class="line">  minObjName = resultObj[<span class="string">'targetName'</span>];</span><br><span class="line">  minDistance = resultObj[<span class="string">'distance'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; allDistance, minDistance, minObjName &#125;;</span><br><span class="line">  <span class="keyword">return</span> minObjName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟数据以及测试"><a href="#模拟数据以及测试" class="headerlink" title="模拟数据以及测试"></a>模拟数据以及测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">//数据库已有用户及其喜欢的电影类型的打分</span></span><br><span class="line"><span class="keyword">let</span> favoriteType = &#123;</span><br><span class="line">  xiaoming: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">3</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaohong: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">4</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaolv: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">1</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaozi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoqi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">2</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">3</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoquan: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = kNN(favoriteType, &#123; <span class="attr">terror</span>: <span class="number">1</span>, <span class="attr">comedy</span>: <span class="number">4</span>, <span class="attr">love</span>: <span class="number">2</span>, <span class="attr">action</span>: <span class="number">5</span>, <span class="attr">scienceFiction</span>: <span class="number">5</span> &#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allDistance: [</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.12'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoqi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.36'</span>, <span class="attr">targetName</span>: <span class="string">'xiaozi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.00'</span>, <span class="attr">targetName</span>: <span class="string">'xiaohong'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.10'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoquan'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.20'</span>, <span class="attr">targetName</span>: <span class="string">'xiaolv'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'6.78'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoming'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  minDistance: <span class="string">'4.12'</span>,</span><br><span class="line">  minObjName: <span class="string">'xiaoqi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221222005339.png" alt="image-20220221222005339"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。 </li><li>回归就是预测结果（如数字）。 </li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 </li><li>能否挑选合适的特征事关KNN算法的成败</li></ol>]]></content>
    
    <summary type="html">
    
      KNN（K- Nearest Neighbor）法即K最邻近法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-02-13T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:49.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式</p></blockquote><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221172703812.png" alt="image-20220221172703812"></p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180313039.png" alt="image-20220221180313039"></p><p>解决方式就是采用动态规划</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180638182.png" alt="image-20220221180638182"></p><p>背包分割的最小重量取决于能拿的最小物品重量，如果此时最小物品为0.5，那么背包就要被划分成4/0.5 = 8，8列</p><p>在每一行， <strong>可偷的商品都为当前行的商品以及之前各行的商品</strong>，逐行进行计算，比如第一行，可拿的物品只有吉他，那么接下来四格，就都只能考虑吉他，所以全都填充为单个吉他的价值，等到第二行时，可选的选项就有音响和前一行的吉他了，这时候每个单元格再根据物品价值和质量综合判断来进行数据填充，音响重量有4，所以前面依旧沿用吉他的价值，直接到音响的重量所处格子，这时候我们发现音响价值在4的时候大于1500，也就是音响本身价值大于吉他，所以进行替换，接下来亦是如此，到第三行第四个格子我们发现笔记本电脑的价格加上<strong>上一行</strong>4-笔记本重量所处单元格的价值大于上一行4所处价值，所以得出最终的结果</p><p>计算结果如下</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180723661.png" alt="image-20220221180723661"></p><p>计算每个单元格的价值时，使用的公式如下</p><p>在1和2之间进行比较，选择大的那方</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221182208929.png" alt="image-20220221182208929"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p><strong>各行的排列顺序无关紧要</strong></p><p>也就是说哪个物品先判断都行，你想把音响放在最开始进行分析都可以，不影响结果（但在后面的代码中为了方便我还是会为数据进行排序，从最轻的拿起，可以思考下我为什么那样做，当然也有可能会是我想不到（不足）的地方（怕打脸哈哈哈））</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183039104.png" alt="image-20220221183039104"></p></li><li><p><strong>使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分（你只能把它当作一个最小的整体，不能继续分割的整体）</strong></p><p>如果想处理像偷大米、黄豆之类可以拆出来倒到背包的问题时，则可以使用贪婪算法</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183404146.png" alt="image-20220221183404146"></p></li><li><p>相互依赖的情况</p><p>没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是<strong>离散</strong>的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了子问题会相互产生影响的问题</p></li><li><p>为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包</p><p>形象来说就是一分为二，再在每个子背包中一分为二（有点类似二叉树）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183745856.png" alt="image-20220221183745856"></p></li><li><p>最优解可能会导致背包没装满</p><p>假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路如下</p><ol><li>因为从上面的算法得出：每次计算当前行都只会用到上一行的数据，所以我并没有像书里一样使用表格去记录这个过程，我使用了两个二维数组prices、goods分别用来存储每格的价值和所含物品，每次每行计算后的最新结果goods[1]会重新赋值给goods[0]，计算前又将goods[0]默认赋值给goods[1]，这样就可以只在价格有改变时改变单元格即可， prices同理</li><li>然后对初始数据initData进行排序，这样可以保证最开始那一行是有数据的，如果是别的比较重的物品，则最开始那几个空格就会为空，就又要去做一些多余的判断或者赋默认值，挺麻烦的，怕代码冗余和出现一些问题</li><li>内层（列）遍历，每次都只用从当前物品重量对应单元格开始算，毕竟前几格你也放不下嘛，默认当前格的上一行值即可，减少代码判断</li><li>核心判断语句不变，跟上面一致</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDeep</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetGoods</span>(<span class="params">data, bagWeight</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initData = <span class="built_in">Array</span>.from(data); <span class="comment">//数据初始化，防止修改到原数据</span></span><br><span class="line">  <span class="keyword">let</span> prices = [[], []]; <span class="comment">//存放价值的数组</span></span><br><span class="line">  <span class="keyword">let</span> goods = [[], []]; <span class="comment">//存放每个最大价值所含物品</span></span><br><span class="line">  initData.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.weight - b.weight); <span class="comment">//数据初始化排序，从小到大</span></span><br><span class="line">  <span class="keyword">let</span> baseWeight = initData[<span class="number">0</span>][<span class="string">'weight'</span>]; <span class="comment">//获得基础容量</span></span><br><span class="line">  <span class="keyword">let</span> pricesLength = <span class="built_in">Math</span>.floor(bagWeight / baseWeight); <span class="comment">//获得背包应分割的数量,向下取整，排除书包额外容量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据,相当于遍历第一件商品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pricesLength; i++) &#123;</span><br><span class="line">    prices[<span class="number">0</span>].push(initData[<span class="number">0</span>][<span class="string">'price'</span>]);</span><br><span class="line">    goods[<span class="number">0</span>].push([initData[<span class="number">0</span>][<span class="string">'name'</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除当前商品，避免参与下面的算法执行</span></span><br><span class="line">  <span class="keyword">delete</span> initData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心，从第二件商品开始遍历，对每一件商品进行数据填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initData) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = initData[key];</span><br><span class="line">    <span class="keyword">let</span> elementWeightIndex = element[<span class="string">'weight'</span>] / baseWeight - <span class="number">1</span>; <span class="comment">//物品重量对应索引</span></span><br><span class="line"></span><br><span class="line">    prices[<span class="number">1</span>] = copyDeep(prices[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line">    goods[<span class="number">1</span>] = copyDeep(goods[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = elementWeightIndex; i &lt; pricesLength; i++) &#123;</span><br><span class="line">      <span class="comment">//第一种情况：当前物品重量同当前背包小格重量相等</span></span><br><span class="line">      <span class="keyword">if</span> (i == elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品及价格</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>]];</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况，当前物品重量大于当前背包小格重量</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格加上（当前背包质量-当前物品质量）的价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品和（当前背包质量-当前物品质量）的物品总和及价格总和</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>], ...goods[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prices[<span class="number">0</span>] = copyDeep(prices[<span class="number">1</span>]);</span><br><span class="line">    goods[<span class="number">0</span>] = copyDeep(goods[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    goods: goods[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">    price: prices[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下"><a href="#运行下" class="headerlink" title="运行下"></a>运行下</h4><p>模拟数据有点多，不要介意，确保可靠嘛</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'吉他'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'音响'</span>, <span class="attr">price</span>: <span class="number">3000</span>, <span class="attr">weight</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'笔记本电脑'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'iphone'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ipad'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'自行车'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'钻石'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'花'</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'巧克力'</span>, <span class="attr">price</span>: <span class="number">500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'耳机'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = dynamicToGetGoods(data, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; goods: [ '音响', '钻石', 'iphone', '吉他', '耳机', '巧克力' ], price: 58500 &#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 </li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴</li></ol><p>每次用的时候问问自己</p><blockquote><ol><li>单元格中的值是什么？</li><li>如何将这个问题划分为子问题？ </li><li>网格的坐标轴是什么？</li></ol></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>建立表格</li><li>确定每一个格的值代表什么 </li><li>如何将大问题划分为具有相同解法的子问题</li><li>确定网格坐标轴</li></ol><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185431847.png" alt="image-20220221185431847"></p><p>尝试一下，在纸上绘制网格，将每个单词分解（子问题）</p><p>答案如下（思考下，这是如何得出的）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185929563.png" alt="image-20220221185929563"></p><p>解决这个问题核心的伪代码类似于下面这样</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185552675.png" alt="image-20220221185552675"></p><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ol><li><p>对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190054121.png" alt="image-20220221190054121"></p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>你可以先尝试着根据上面的思路自己写一下</p><p>在写的过程中你是否会发现一个问题，在代码的实现上，我们会发现上面的公式会有些问题，毕竟我们是用二维数组去记录这个过程，所以某些情况下会出现<code>data[index1 - 1][index2 - 1]</code>报错的情况，什么情况下呢</p><p>如下图，这些情况下的值在你按部就班时运行会报错的，因为它缺少斜对角的值，毕竟没有<code>data[-1][-1]</code>这样的值出现</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220222085726502.png" alt="image-20220222085726502"></p><p>怎么解决，有两种方法，第一种是每次到该计算都做一下判断，判断是否有值，我嫌太麻烦了，且影响从代码上去理解这个算法的思路，所以使用第二种，给你一个二维数组，你就会理解了，然后我就懒得解释了哈哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在里面，我会用一个函数<code>fillDataByWordLength</code>去填充第一行的0，以及在内层循环（列）中每次一开始填充一个0</p><p>还有一点，我使用了<code>max</code>和<code>maxWord</code>在每次判断时去分别存储<strong>最长公共子串长度</strong>和<strong>最长公共子串</strong>，免得后面再在二维数组去找一个最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br></pre></td></tr></table></figure><p><code>getMaxWord</code>函数主要用作获得最长的公共子串，比如，fish和fosh最长的公共子串就为sh</p><p>然后再看看下面的代码，应该没啥问题了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得最长的公共子串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxWord</span>(<span class="params">word, maxWordPosition, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = maxWordPosition - max + <span class="number">1</span>; i &lt;= maxWordPosition; i++) &#123;</span><br><span class="line">    res += word[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">//存储最长公共子串数</span></span><br><span class="line">  <span class="keyword">let</span> maxWord; <span class="comment">//存储最长公共子串</span></span><br><span class="line">  <span class="keyword">let</span> maxWord1Position; <span class="comment">//存储最长公共子串截至位置</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">        data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不相等则赋值为0</span></span><br><span class="line">        data[index1][index2] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxWord = getMaxWord(word1, maxWord1Position, max);</span><br><span class="line">  <span class="keyword">return</span> &#123; max, maxWord &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-1"><a href="#运行下-1" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190426458.png" alt="image-20220221190426458"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190516948.png" alt="image-20220221190516948"></p><p>这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的 字母数。如何计算最长公共子序列呢</p><p>计算过程如下：图很重要！！！！！！（懒得打字了）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190615957.png" alt="image-20220221190615957"></p><p>核心伪代码</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190713163.png" alt="image-20220221190713163"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>思路是和上面例子很相近的，只是判断语句不同了而已，直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若不相等，则从左边或上边的邻居方格中取一个最大值</span></span><br><span class="line">        data[index1][index2] = <span class="built_in">Math</span>.max(data[index1][index2 - <span class="number">1</span>], data[index1 - <span class="number">1</span>][index2]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">res</span>: data[word1.length][word2.length], <span class="attr">calculationMatrix</span>: data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-2"><a href="#运行下-2" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221191104618.png" alt="image-20220221191104618"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="动态规划的实际应用"><a href="#动态规划的实际应用" class="headerlink" title="动态规划的实际应用"></a>动态规划的实际应用</h3><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 </li><li>你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ol>]]></content>
    
    <summary type="html">
    
      动态规划算法通常用于求解具有某种最优性质的问题
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法</title>
    <link href="http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-10T06:00:00.000Z</published>
    <updated>2022-03-02T08:00:37.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，<strong>算法得到的是在某种意义上的局部最优解</strong></p><p>换句话说：贪婪算法就是每步都选择局部最优解，最终得到的就是全局最优解</p></blockquote><p>贪心算法也存在如下问题：</p><ol><li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑</li><li>贪心算法一般用来解决求最大或最小解</li><li>贪心算法只能确定某些问题的可行性范围</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150319952.png" alt="image-20220220150319952"></p><h3 id="集合覆盖问题（广播站问题）"><a href="#集合覆盖问题（广播站问题）" class="headerlink" title="集合覆盖问题（广播站问题）"></a>集合覆盖问题（广播站问题）</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150857304.png" alt="image-20220220150857304"></p><p>这一节的算法代码会在后面放出来，我们先专注于这个算法以及其应用先，毕竟会用但不知道在哪用就跟不会用差不多嘛</p><p>通过上面两个例子，我们可以得出如简介一样的总结，贪婪算法不算最优解，但是在某些复杂的问题下我们用它可以达到非常接近最优解的解，那什么又是复杂的问题，也就是哪些问题才需要用到贪婪算法呢</p><h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><blockquote><p>NP完全问题的简单定义：以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常 聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。</p></blockquote><p>比如<a href="https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/7737042" target="_blank" rel="noopener">旅行商问题</a>，这个<a href="https://zhuanlan.zhihu.com/p/159266077" target="_blank" rel="noopener">链接</a>会讲述TSP问题以及帮你引入到贪婪算法里，懂了这一节的例子也可以不用看了</p><p>比如有这么三个城市-北京、石家庄、呼和浩特，你都想去旅游，于是有一天，你开始规划路线，那么从哪里出发，最后去哪里，你会如何规划呢</p><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220152241040.png" alt="image-20220220152241040"></p><p>我们先不考虑起点从哪，假设我们想先去石家庄，然后去呼和浩特，最后再到北京，这便是其中一条路线，但我们想找出最短的那条路程，比较把时间花在路上，玩的很累不是吗，那么怎么选呢，<strong>穷举法</strong>？好像很不错的样子，我们来试试</p><blockquote><p>北京-石家庄-呼和浩特</p><p>北京-呼和浩特-石家庄</p><p>石家庄-北京-呼和浩特</p><p>石家庄-呼和浩特-北京</p><p>呼和浩特-北京-石家庄</p><p>呼和浩特-石家庄-北京</p></blockquote><p>然后就是在里面挑出一条最佳路线，显然，这个方法的时间复杂度是<strong>O(n！)</strong></p><p>这可是阶乘啊，意味着啥，当你越来越富，想玩的地方越来越多，你要挑选出一条最佳路线的难度可是越来越大，原来有钱人也不是那么好的</p><p>那么这个时候我们就要选择贪婪算法了</p><h3 id="如何识别-NP-完全问题"><a href="#如何识别-NP-完全问题" class="headerlink" title="如何识别 NP 完全问题"></a>如何识别 NP 完全问题</h3><p>NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小</p><p>下面几点可作为辨别NP问题的参考</p><ol><li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一 个NP完全问题吗？</li><li>在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？</li><li>你要制作中国地图，需要用不同的颜色标出相邻的省。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻省的颜色都不同。请问这是NP完全问题吗？</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说完上面，我们来看看JavaScript如何实现广播站问题的贪婪算法</p><p>首先，运行该算法我们需要什么样的数据格式，一个用于存储省名的数组、一个用于表达广播站及其可以广播的省份的映射关系-散列表，在里面，我们用字母来表示广播站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省份缩写</span></span><br><span class="line"><span class="keyword">let</span> address = [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>, <span class="string">'SC'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播站-散列表</span></span><br><span class="line"><span class="keyword">let</span> radioStation = &#123;</span><br><span class="line">  a: [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>],</span><br><span class="line">  b: [<span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'SC'</span>],</span><br><span class="line">  c: [<span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>],</span><br><span class="line">  d: [<span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  e: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  f: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'SC'</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着就是算法的实现了</p><p>记住我们的步骤</p><p>(1) 选出这样一个广播台，即它覆盖了<strong>最多的未覆盖</strong>省份。即便这个广播台覆盖了一些已覆盖的省，也没有关系。</p><p> (2) 重复第一步，直到覆盖了所有的州。</p><p>根据第二步，我们就应该会感觉到可能要用到迭代了</p><p>首先先不管用不用迭代，我们来分析下这个过程</p><p>最核心的一步：我们要找出<strong>最多的未覆盖</strong>省份的广播站，那么这一步如何实现</p><p>通过<strong>遍历</strong>广播站，找出广播站和所需要覆盖的省份间的<strong>交集</strong>，谁的交集包含的元素<strong>最多</strong>，就选哪个，这就是最核心的了，遍历、交集、最多，这三个名称就是算法核心代码了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line"><span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line"><span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">  <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">  <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">  intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着遍历完第一遍，有可能会剩下其他省份还没找出广播站呢，那该如何做呢，再对剩下的省份执行上述步骤嘛，这不就要用到迭代了，代码如下，我们用<code>res</code>这个变量用于存储最终的广播站结果集合，然后记得把当前选到的广播站从下次执行的函数参数中的数据删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line"><span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line"><span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br></pre></td></tr></table></figure><p>既然是迭代，那肯定要有终止条件，不然就无限迭代下去了，这个问题的基线条件是所有的地址都已找到所能广播的广播站了，换成代码的解释就是address长度为零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line"><span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是这个算法的大致代码了，等等，如果有一个地址没有任何广播站能广播到呢，出现这种情况怎么办，这种问题我们只能当作无解，毕竟没有广播站能广播到你要的地址，说明数据有问题，需求也就根本无法解决</p><p>代码上也就是，两者交集没有任何结果，如果address长度还没为0时，没有结果意味着没有广播站可以服务该地址了，所以注意该代码位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法： 参数：所有地点（数组）、广播站（散列表）、最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greedy</span>(<span class="params">address, radioStation, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line">  <span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line">  <span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line">  <span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">    <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">    <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">    intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br><span class="line"></span><br><span class="line">  res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">  address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line">  <span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line">  <span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 </li><li>对于NP完全问题，还没有找到快速解决方案。 </li><li>面临NP完全问题时，最佳的做法是使用近似算法。 </li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol><h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><p>三个都是NP问题，快去用贪婪算法试着解出来吧！加油💪</p>]]></content>
    
    <summary type="html">
    
      贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>狄克斯特拉算法</title>
    <link href="http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T14:00:00.000Z</published>
    <updated>2022-03-02T07:59:40.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800" target="_blank" rel="noopener">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>假设给定一个二维数组，里面存储着各个相邻点之间的距离，</p><p>比如第一个<code>[&#39;a&#39;, &#39;b&#39;, 20]</code>，表示着从A点到B点的距离为20，以此类推</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">30</span>],</span><br><span class="line">  [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="string">'e'</span>, <span class="string">'a'</span>, <span class="number">20</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而我们的需求则是，以某个确定的点为起点，得出其到其余点的最短距离，比如以a为起点，我们想得到其到b、c、d、e的最短距离</p><p>那么这个算法该如何在js上实现</p><p>单纯从这个数组来看，好像有点想不出解法，我们先试着把它转化成图形关系，从而更加容易理解点</p><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220218093850197.png" alt="image-20220218093850197"></p><p>从这个图，我们可以更加直观的理解每个点之间的位置距离关系，比如A，可以直接到达B、C、E，但却不能直接到达D，要想过去，还得通过一些“中介点”</p><p>接着，我们来简略介绍下狄克斯特拉算法的使用步骤</p><blockquote><p>(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 </p><p>(2) 更新该节点的邻居的开销。</p><p>(3) 重复这个过程，直到对图中的每个节点都这样做了。</p><p> (4) 计算最终路径。</p></blockquote><p>在默认初始化条件下：我们用一个表来记录默认起点下到其他点的最短距离</p><table><thead><tr><th>次数</th><th>S</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>{a}</td><td>20</td><td>3</td><td>∞</td><td>20</td></tr><tr><td>2</td><td>{a,c}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>3</td><td>{a,c,b}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>4</td><td>{a,c,b,d}</td><td>20</td><td>3</td><td>8</td><td>14</td></tr></tbody></table><p>用一个表格记录更新完最短距离表格后的目标地点的上一个节点</p><table><thead><tr><th>次数</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>2</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>3</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>4</td><td>a</td><td>a</td><td>c</td><td>d</td></tr></tbody></table><p>阐述下这个过程</p><p>首先，我们将A到各个其他点的距离记录进去，接着按<strong>初始距离从短到长</strong>的顺序将a,b、a,c、a,d这三个当作一个整体去更新表格(注意：这里不是简单的就是a→b，而是他们之间的最短路径)</p><p>记住，每次我们都从最短的路径入手，比如a到c的距离最短，那么我们就从该点c入手，其次就是在b和d中选择</p><p>比如在接下来，我们把a→c当作一个整体，它的默认权重为3，然后去对比其他各个点，注意看图，根据结果去刷新最短距离，比如c到e的距离是30，加上默认权重（a→c）3，是33，比a直接到达e还远，所以我们不更新该距离，以及c的最短距离的上一个节点还是a，其他类似，每一步更新完，即可得出起点到达该点的最短距离了</p><p>我们重点看下第三次和第四次，在第三次，a到b，c还是不变，但是c可以直接到d了,也就是说，在原先的基础a到c的距离3上加5，得出该距离为8，同时途径点可以更新为c</p><p>第四次，我们发现d到e的距离为6，加上a到d的最短距离8可以达到14，比a直接过去还短，所以我们更新表格，最短距离为14，上个节点为e</p><p>我们可以看到这样的规律，如果当前节点pass到终点end的距离(passEnd)加上起点start到当前节点pass的距离(startPass)小于默认起点start到终点end的距离(startEnd)，那么就更新表格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果startPass + passEnd &lt; startEnd</span><br><span class="line">则startEnd = startPass + passEnd（更新）</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>我们用一个对象来存储当个点到其他点的距离，比如下面</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    instance: 20,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    instance: 3,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个函数来格式化该操作，data为数组数据，startPoint为起点，targetPoint为终点集合（数组），格式完数据后，我们把起点到起点的数据删掉，因为该点并没有什么用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着，我们用另一个对象把所有数据包裹起来，</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   起点1:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2: &#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;,</span><br><span class="line">   起点2:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;...</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现该操作的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对比长度的函数，通过前面的介绍我们可以知道这个过程的实现，无需多言，直接看代码，入参含义为（数组数据，起点名称，当前点名称，终点名称）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>主函数入口：最主要的就是迭代，对每个点进行迭代执行analyse函数，再对每个点下的终点距离进行遍历判断</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>将结果进行描述的函数，在这里对于算法来说没啥用处，主要就是结果的文字展示</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>拿前面的数据进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = dijkstra(data, <span class="string">'a'</span>, [<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br><span class="line"><span class="keyword">let</span> res1Text = roadPoint(res1, <span class="string">'e'</span>) <span class="comment">//文字描述</span></span><br><span class="line"><span class="built_in">console</span>.log(res1Text);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220219164513219.png" alt="image-20220219164513219"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪杰斯特拉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法</li><li>狄克斯特拉算法用于在加权图中查找最短路径。 </li><li>仅当权重为正时狄克斯特拉算法才管用。 </li><li>如果图中包含负权边，请使用贝尔曼福德算法。</li></ol>]]></content>
    
    <summary type="html">
    
      迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广度优先搜索</title>
    <link href="http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2021-10-01T12:00:00.000Z</published>
    <updated>2022-03-02T08:26:26.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>宽度优先<a href="https://baike.baidu.com/item/搜索算法/2988274" target="_blank" rel="noopener">搜索算法</a>（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra<a href="https://baike.baidu.com/item/单源最短路径/6975204" target="_blank" rel="noopener">单源最短路径</a>算法和Prim<a href="https://baike.baidu.com/item/最小生成树" target="_blank" rel="noopener">最小生成树</a>算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>广度优先搜索的运行时间为O(顶点 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数</p><p>对于检查过的人（顶点），务必不要再去检查，否则可能导致无限循环</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ol><h2 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h2><p>有向图是单向的</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904144514052.png" alt="image-20210904144514052"></p><p>无向图没有箭头，直接相连的节点互为邻居，无向图相邻的两个结点彼此指向对方，其实就是一个环，跟上图一样</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>有这么一个人员数据表，他们都有各自的<strong>职业</strong>和<strong>邻居</strong>，假设你是其中一个人：a——工地搬砖工。有一天，你想吃新鲜的蔬菜，但是你不相信陌生人，所以你打算问你的邻居，看看有没有什么认识的人（职业为农民）可以提供保证新鲜的蔬菜给你，如何操作呢（下面为思路）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'worker'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>],</span><br><span class="line">    profession: <span class="string">'panter'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'teacher'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    neighbor: [<span class="string">'c'</span>, <span class="string">'e'</span>],</span><br><span class="line">    profession: <span class="string">'doctor'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  e: &#123;</span><br><span class="line">    neighbor: [<span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'police'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  f: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'farmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  g: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>],</span><br><span class="line">    profession: <span class="string">'programmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据广度优先搜素算法，我们首先根据各个人员的邻居构建出图模型</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904145548745.png" alt="image-20210904145548745"></p><p>接着就是从你（a）自己入手，首先你从b和c开始找起，如若b和c就是农民，那么久返回该对象的名字,我们可以将这两人压入待查找数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c];</span><br></pre></td></tr></table></figure><p>b如果不是，那么就把b的邻居加入数组，一起找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c,a,f,g];</span><br></pre></td></tr></table></figure><p>同时把b弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c,a,f,g];</span><br></pre></td></tr></table></figure><p>当然，a也不是，否则查找会造成循环，不断去找a，所以一开始我们需要定义一个数组用以存储已查过的对象，然后每次查完一个放进一个，后面的每次查找待找数组时在已查找数组中查看是否已查过，是则把该值从待找数组中丢掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finded = [<span class="string">'a'</span>];</span><br></pre></td></tr></table></figure><p>继续上面几个步骤，对后面的数据进行查找↓</p><p>接下来是c，c也不是，所以把c的邻居也加进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,f,g,a,f,d];</span><br></pre></td></tr></table></figure><p>重复这几个步骤，直到找出最终的结果</p><p>方法代码如下</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/carbon.png" alt="carbon"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>广度优先搜索指出是否有从A到B的路径。</li><li>如果有，广度优先搜索将找出最短路径。</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来 解决问题。</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 </li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约 会，而rachel也与ross约会”。</li><li>队列是先进先出（FIFO）的。 </li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必 须是队列。 </li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环。</li></ol>]]></content>
    
    <summary type="html">
    
      宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2021-08-30T08:00:00.000Z</published>
    <updated>2022-03-02T08:26:48.472Z</updated>
    
    <content type="html"><![CDATA[<p>必看：<a href="https://zhuanlan.zhihu.com/p/95156642" target="_blank" rel="noopener">来吧！一文彻底搞定哈希表！</a></p><p>进阶：<a href="https://baike.baidu.com/item/哈希表/5981869?fr=aladdin" target="_blank" rel="noopener">哈希表_百度百科 (baidu.com)</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20210904161554231.png" alt="image-20210904161554231"></p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型</li><li>一种包含额外逻辑的数据结构</li><li>也被称为散列映射、映射、字典和<br>关联数组</li><li>散列表的查找、插入和删除速度都非常快</li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>查找（模拟映射关系）</li><li>防止重复</li><li>用作缓存</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="什么是冲突"><a href="#什么是冲突" class="headerlink" title="什么是冲突"></a>什么是冲突</h4><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20220216142535367.png" alt="image-20220216142535367"></p><blockquote><p>冲突很糟糕，应使用可以最大限度减少冲突的散列函数</p></blockquote><p>避免方法：</p><ol><li>较低的填装因子<ul><li>填装因子越低，发生冲突的可能性越小，<br>散列表的性能越高</li><li>经验：一旦填装因子大于0.7，就调整散列表的长度</li><li>虑到调整长度所需的时间，散列表操作所需的时间也为O(1)</li></ul></li><li>良好的散列函数<ul><li>良好的散列函数让数组中的值呈均匀分布</li><li>糟糕的散列函数让值扎堆，导致大量的冲突</li><li>散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置</li></ul></li></ol><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100</li></ol><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="伪散列函数查找商品价格"><a href="#伪散列函数查找商品价格" class="headerlink" title="伪散列函数查找商品价格"></a>伪散列函数查找商品价格</h3><p>功能：</p><ol><li>添加商品及其价格</li><li>输入商品，得到其价格</li></ol><p>思路：</p><ol><li>使用类存储</li><li>获取商品价格方法<ul><li>通过遍历已有商品得到其价格并返回出去</li></ul></li><li>添加商品方法<ul><li>通过添加商品将该数据添加到对象中</li></ul></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/6130935fe401fd1fb6a2dfb5.png" alt="6130935fe401fd1fb6a2dfb5"></p><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h3><p>该散列表默认按照最高长度为24来进行字符串存储</p><p>slots用于初始化散列表时的数据存储</p><ul><li>add方法<ul><li>得到当前传入值的字符串长度</li><li>判断当前长度对应的数组位置是否还未开辟出新的数组，是则开辟出新的内存地址</li><li>将当前字符串添加到散列表（slots）中去</li></ul></li><li>delete方法<ul><li>从散列表中查找该字符串长度对应的数组位置</li><li>获得该元素在该数组（对应字符串长度的数组）中的<strong>位置</strong></li><li>将该数据从散列表中数组对应的位置删除</li></ul></li><li>get方法<ul><li>通过<strong>过滤函数（filter）</strong>将数据从散列表中取出来，并返回该值</li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/613095421efad40d9391d4ad.png" alt="613095421efad40d9391d4ad"></p>]]></content>
    
    <summary type="html">
    
      是根据关键码值(Key value)而直接进行访问的一种数据结构
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js原型小记（大记）</title>
    <link href="http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/</id>
    <published>2021-08-22T08:00:00.000Z</published>
    <updated>2022-03-04T08:44:41.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型、原型链、-proto-、prototype"><a href="#原型、原型链、-proto-、prototype" class="headerlink" title="原型、原型链、__proto__、prototype"></a>原型、原型链、__proto__、prototype</h1><blockquote><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p></blockquote><p>也就是说，在js中，我们是可以通过克隆创造世界，看下面的代码，首先我们创建一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个构造函数，暂且将它想象成类，然后我们来new一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>我们创造了一个admin对象，接着，如果有一个admin和上面所创造的对象同名同年龄时，我们该怎么创建呢，有人说：这还不简单嘛，再new一个不就得了，确实，在这里new一个难度不大，但当我们构造同一个对象需要的参数很多时，那又该怎么办，按着原来的参数继续new吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, height, weigt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.height = height,</span><br><span class="line">  <span class="keyword">this</span>.weight = weight,</span><br><span class="line">  <span class="comment">//... 还有其它很多的属性</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经创建了一个对象</span></span><br><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>,<span class="number">177</span> ,<span class="number">110</span>,...)</span><br><span class="line"><span class="comment">// 要再创建同个对象</span></span><br></pre></td></tr></table></figure><p>这样的参数要我们一个一个填进去，但我们已经新建了一个完全的一样的对象，而且这样子做还要防止参数一不小心填错导致对象不同</p><p>所以我们采用克隆的方式来创造一个一模一样的对象，ECMAScript 5提供了Object.create 方法，可以用来克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneAdmin = <span class="built_in">Object</span>.create( admin);</span><br></pre></td></tr></table></figure><p>这，便是js的克隆，在这时候，cloneAdmin.__proto__会指向admin，__proto__是啥，后面我们会提到，这里你只需要知道，这时候的cloneAdmin已经继承admin几乎所有属性包括方法了</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>我们再来了解下原型和原型链，什么是原型，就像上面举的例子，cloneAdmin是通过admin克隆而来的，那么它的原型便是admin，如果现在有一个对象clone2，克隆自cloneAdmin，那么clone2的原型便是cloneAdmin，而从它到admin这一条线上的所有对象便是原型链</p><blockquote><p>js的继承：基于原型链的委托机制就是原型继承的本质</p></blockquote><p>如何理解这句话，我们继续上面的例子，现在cloneAdmin克隆自admin，那么它是可以使用admin的所有属性和方法的，前提是它没有覆盖掉原型的方法，这类似于我们学习其它语言的继承特性</p><p>所以我们也就可以知道：<strong>当对象无法响应某个请求时，会把该请求委托给它自己的原型</strong></p><p>所以，通过以上，可以得出：原型编程范型至少包括以下基本规则</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><h2 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h2><p>JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。</p><p>在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。</p><h2 id="JS的克隆"><a href="#JS的克隆" class="headerlink" title="JS的克隆"></a>JS的克隆</h2><p>JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。</p><h2 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h2><p>JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。</p><p>__proto__就是对象跟“对象构造器的原型”联系起来的纽带。（__proto__：指向该对象的构造函数的原型对象，prototype指向该构造函数的原型对象——来自<a href="https://www.zhihu.com/question/34183746/answer/58155878" target="_blank" rel="noopener">知乎</a>，强烈建议阅读该文章）</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h2><p>JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。</p><p>如：我们可以创建一个无原型的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一参数为原型指向，第二个为对象属性编辑</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'hhh'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原型链并不是无限长的，当对象通过原型链找某个属性找到根节点而找不到时，则会返回undefined（Object.prototype 的原型是 null）</p><h1 id="基于原型的继承以及constructor"><a href="#基于原型的继承以及constructor" class="headerlink" title="基于原型的继承以及constructor"></a>基于原型的继承以及constructor</h1><p>通过上面，我们可以知道继承是可以通过原型实现，通过上面的继承原型图，我们进行相应的练习</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><p>首先创建构造函数User</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getDetail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，我们新建一个对象zhangsan</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>现在我们想新建另一个对象李四，让它直接继承于张三（也就是张三的儿子），我们可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> lisi = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(lisi, zhangsan)</span><br><span class="line">lisi.name = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure><p>ok，这样我们就简单的实现了继承，然后，提出一个问题，张三、李四以及构造函数User之间的关系是怎样的（通过上图理解）</p><p>弄清楚之后，你便会对__proto__、prototype、原型继承、原型和原型链有了更深刻的理解(下面是答案，记住一点，prototype是构造函数独有的，对象并没有这个属性，且这个属性指向构造函数原型)</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt="原型继承"></p><p>通过这张图，我们也可以知道</p><p><code>User.prototype.constructor() === User()</code></p><p>也就是说，你也可以通过<code>new User.prototype.constructor()</code>创建对象，当然正常人不会这样做（麻烦）</p><h1 id="构造函数-对象的原型检测"><a href="#构造函数-对象的原型检测" class="headerlink" title="构造函数/对象的原型检测"></a>构造函数/对象的原型检测</h1><p>我们想要对某一个对象的原型进行判断，有两种方法，一种是通过判断构造函数，另一种则是直接判断对象</p><p>首先我们声明三个类、定义它们间的关系以及实例化出各自的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">B.prototype = a</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line">C.prototype = b</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br></pre></td></tr></table></figure><ol><li><p>instanceof方法（构造函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> C)</span><br></pre></td></tr></table></figure><p>结果都为真</p></li><li><p>dad isPrototypeOf(son)（对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(b))</span><br><span class="line"><span class="built_in">console</span>.log(b.isPrototypeOf(c))</span><br><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(c))</span><br></pre></td></tr></table></figure><p>结果也都为真</p></li></ol><p>两个方法都会循着原型链向上找，唯一不同的便是instanceof需要传入构造函数，而另一个方法则是传入对象</p><h1 id="原型链中的对象遍历"><a href="#原型链中的对象遍历" class="headerlink" title="原型链中的对象遍历"></a>原型链中的对象遍历</h1><p>首先胡乱设置两个对象，同时这两个对象有继承关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">  A() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我叫"</span> + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  age: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.__proto__ = a</span><br></pre></td></tr></table></figure><p>好的，也就是说a是b的爸爸，然后我们来遍历一下b对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是什么(name 、age、A())</p><p>由此我们可以得出：in遍历是会遍历出包含原型链上其它原型的属性方法，那么如果我们只是想要遍历b独有的方法呢</p><p>这时候可以利用hasOwnProperty()方法去判断方法属性是否属于当前调用对象独有的，使用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被检测对象.hasOwnProperty(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure><p>所以我们就可以使用for_in循环遍历出当前对象的属性方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="comment">// 判断当前属性是否为当前对象独有</span></span><br><span class="line">  <span class="keyword">if</span> (b.hasOwnProperty( key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出的结果就是b自己独有的属性方法啦</p><h1 id="借用其他原型链方法"><a href="#借用其他原型链方法" class="headerlink" title="借用其他原型链方法"></a>借用其他原型链方法</h1><p>现在我们有个数组arr，当有个需求要我们求出这个数组的最大值时，你会咋做嘞</p><p>有些人可能会这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>也有可能这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">v, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt; v ? c : v</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>但是嘞，这些都是基于数组原型的方法实现的，声明的数组类型本来就是指向该原型的，那如果这时候我想调用Math里面的方法去实现这一需求，Math.max()方法不需要上面那么复杂的逻辑实现，更简单有木有，但是要如何做呢</p><p>这时候我们就要用到apply或call方法啦（两个函数都可以改变方法的this指向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><p>这样得出来的结果也是一样的，更简单明了是不，他的原理便是改变原函数max的指向，使得我们可以调用不处于同一条原型链的其它对象的方法</p><p>再来一个例子，我们利用数组的过滤来对Dom进行操作，需求是这样的：给出两个input控件，我们想要获得指定的控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"我是a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"我是b"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想要获得name=a的元素，怎么做呢，很简单：1.获取所有input控件 2.调用数组的filter方法进行过滤筛选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = <span class="built_in">document</span>.querySelectorAll(<span class="string">'[v-model]'</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Array</span>.prototype.filter.call(ts, e =&gt; e.getAttribute(<span class="string">'name'</span>) === <span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//下面的方法也行</span></span><br><span class="line"><span class="comment">// let res = [].filter.call(ts,e =&gt; e.getAttribute('name') === 'a')</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>].value)</span><br></pre></td></tr></table></figure><h1 id="构造函数原型方法和构造函数内的方法"><a href="#构造函数原型方法和构造函数内的方法" class="headerlink" title="构造函数原型方法和构造函数内的方法"></a>构造函数原型方法和构造函数内的方法</h1><p>从前面我们可以知道，用构造函数实例化出来的对象，他的原型是构造函数的prototype属性，那么当我们给构造函数的prototype对象添加方法时，这个实例化出来的对象也可以使用该方法，那要是将一个对象的__proto__指向该构造函数的prototype时，它是否可以使用构造函数内部定义的方法呢，让我们看一下</p><p>首先定义一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age= <span class="number">18</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给它的原型新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个对象，并分别调用构造函数内的方法和构造函数prototype的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">'user1'</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1.getAge())</span><br><span class="line">user1.getName()</span><br></pre></td></tr></table></figure><p>结果都可以正常显示</p><p>接着我们直接定义另一个对象，并强制将其原型指向User.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = &#123;&#125;</span><br><span class="line">user3.__proto__ = User.prototype</span><br></pre></td></tr></table></figure><p>调用getAge()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user3.getAge())</span><br></pre></td></tr></table></figure><p>正常显示，调用getName()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user3.getName()</span><br></pre></td></tr></table></figure><p>无法执行，程序报错，显示该错误：user3.getName is not a function</p><p>所以由此我们可以得出，构造函数内部定义的方法，只有在由他实例化出来的对象才会得到，而将一个自定义对象原型指向该构造函数的prototype对象时，是无法使用该构造函数内部的方法的，但是毫无疑问的，它可以使用该构造函数的prototype对象内的方法</p><h1 id="设置和获得原型"><a href="#设置和获得原型" class="headerlink" title="设置和获得原型"></a>设置和获得原型</h1><p>上面我们可以知道，设置对象的原型可以直接使用obj.__proto__属性强制绑定，下面是Object自带的两个方法进行原型设置以及获得当前对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置原型</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(son, dad)</span><br></pre></td></tr></table></figure><p>该方法和son.__proto__ = dad一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(son)</span><br></pre></td></tr></table></figure><p>使用该方法即可获得他爹了</p><h1 id="proto-原理（get、set）"><a href="#proto-原理（get、set）" class="headerlink" title="__proto__原理（get、set）"></a>__proto__原理（get、set）</h1><p>不知道你们有没有试过，将对象的__proto__属性定义成出对象外的其它值类型数据是不可行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;&#125;</span><br><span class="line">obj.__proto__ = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这样是没有任何效果的，为什么呢，因为__proto__实际上是访问器(get/set)构造而成的，他会对设置的值进行过滤，只有符合对象类型的数据，它才会赋值，让我们来仿造一个，了解其实质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Obj  = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> _proto_() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.obj</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> _proto_(e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Obj._proto_ = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj._proto_);</span><br></pre></td></tr></table></figure><p>核心代码便是<code>e instanceof Object</code>，即判断当前传入类型是否为对象，是则赋值成功，否则忽略该赋值</p><h1 id="基于原型面向对象的多态"><a href="#基于原型面向对象的多态" class="headerlink" title="基于原型面向对象的多态"></a>基于原型面向对象的多态</h1><p>js也可以多态，你没骗我吧，没有的事呢，那就让我们来看看js的多态究竟是个啥</p><p>假设现在有个情况，你家里来客人了，你爸叫你和你妹跟客人打招呼，你说了句“叔叔好，我是我爸的儿子jie（假设你叫jie）”，你妹说：“叔叔好，我是我爸的女儿hua（假设你妹叫hua）”</p><p>看到没有，同样的一个行为，哥哥和妹妹的表现是不同的，这便是多态。让我们用代码实现一下</p><p>首先定义爸爸构造函数，然后 给爸爸原型定义一个介绍的方法（毕竟指令由爹地发出的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.introduction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.show());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着构造儿子，并继承于老爸，然后定义儿子的介绍方法show()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使得Son.prototype.__proto__指向Father.prototype</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Son.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是儿子'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来就是女儿，和儿子一样，但是其show()方法和儿子有所不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Daughter.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Daughter.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是女儿'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是实例化一个儿子和女儿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="keyword">new</span> Son(<span class="string">'jie'</span>)</span><br><span class="line"><span class="keyword">let</span> hua = <span class="keyword">new</span> Daughter(<span class="string">'hua'</span>)</span><br></pre></td></tr></table></figure><p>假设此时他们接收到了父亲的指令，于是乎分别调用introduction方法并介绍自己</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jie.introduction() <span class="comment">//我是儿子jie</span></span><br><span class="line">hua.introduction() <span class="comment">//我是女儿hua</span></span><br></pre></td></tr></table></figure><p>这便是js的多态实现</p><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>没啥好说的，就是继承父类的方法，但是由自己的实现方式，需要重新定义，这便是重写，直接理解代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个father构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建son对象</span></span><br><span class="line"><span class="keyword">let</span> son = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化爹地</span></span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 让son的原型指向爹地对象</span></span><br><span class="line">son = <span class="built_in">Object</span>.create(father);</span><br><span class="line">son.hi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写son方法</span></span><br><span class="line">son.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'son hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">son.hi();</span><br></pre></td></tr></table></figure><h1 id="禁止自定义函数原型的constructor被遍历"><a href="#禁止自定义函数原型的constructor被遍历" class="headerlink" title="禁止自定义函数原型的constructor被遍历"></a>禁止自定义函数原型的constructor被遍历</h1><p>之前我们已经了解过consructor，它是构造函数原型里面指向构造函数的一个属性，如下，两者是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.constructor === User</span><br></pre></td></tr></table></figure><p>但当我们想让一个构造函数的原型继承于另一个构造函数时，会发生一点意外</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'son'</span></span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br></pre></td></tr></table></figure><p>在这里面，我们让Son的prototype原型指向Father.prototype，看起来好像一切都正常，也不影响继承，但是仔细观察你会发现，里面的constructor不见了，通过打印<code>console.dir(Son.prototype)</code>，我们可以发现它的constructor确实不见了</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528202637586.png" alt="image-20210528202637586"></p><p>这会造成什么问题，你会无法通过下列方法实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son.prototype.constructor();</span><br></pre></td></tr></table></figure><p>所以，为了避免它原先的constructor丢失造成的问题，我们需要把它纠正回来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure><p>OK啦，只要在每次继承之后加上这句代码，就可以防止constructor丢失了，但其实在这里，还会有一个问题，让我们来遍历一下这个原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> Son.prototype) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到什么结果：hi以及constructor，我们希望constructor出现吗，并不会，我们希望这些原本对象自带的属性是隐藏且不可遍历的，但是在这里，我们将原本丢失的自带构造器添加上去，导致其暴露并可以遍历出来，所以我们要将其可枚举的属性设置为false，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，最后，当我们需要构造函数继承时，需要以下三个步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复原有构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="父类构造函数初始化属性"><a href="#父类构造函数初始化属性" class="headerlink" title="父类构造函数初始化属性"></a>父类构造函数初始化属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>， 我今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我们定义的一个父类构造函数，也就是说，有一个构造函数会继承它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如何正确继承，哎对了，三步走实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Admin.prototype = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line"></span><br><span class="line">Admin.prototype.constructor = Admin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Admin.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Admin,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，我们现在想让Admin不用自定义的同时也可以同User一样初始化对象（name、age），怎么实现呢</p><p>前面有讲过的，改变User的this指向不就可以实现了吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  User.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过args传值同时改变User实例化的this指向，从而实现Admin同User一样初始化属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mayun = <span class="keyword">new</span> Admin(<span class="string">'mayun'</span>, <span class="number">22</span>);</span><br><span class="line">mayun.show();</span><br></pre></td></tr></table></figure><p>正确输出啦</p><h1 id="原型工厂封装属性"><a href="#原型工厂封装属性" class="headerlink" title="原型工厂封装属性"></a>原型工厂封装属性</h1><p>每次对构造函数原型进行继承，都要三步走，是不是有点麻烦，要是多个构造函数原型都要继承，岂不是要写很多次，所以我们把它给封装了吧，这样每次就可以直接调用啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">child, dad</span>) </span>&#123;</span><br><span class="line">  child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">    value: child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后的函数也称为原型工厂，我们来看看它的使用方法把</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Son, Father);</span><br></pre></td></tr></table></figure><p>OK，这样子每次继承就不会很麻烦了，直接调用该函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Daughter, Father);</span><br></pre></td></tr></table></figure><h1 id="对象工厂派生对象实现继承"><a href="#对象工厂派生对象实现继承" class="headerlink" title="对象工厂派生对象实现继承"></a>对象工厂派生对象实现继承</h1><p>我们之前已经了解过Object.create()可以实现对象继承，现在让我们来封装一个函数，来理解下构造函数实例化对象的原理，从而实现继承吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' is '</span> + <span class="keyword">this</span>.age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有这么一个构造函数，我们想用它创造出许多子对象（类似于构造函数初始化），如何实现呢</p><p>第一步便是克隆出构造函数原型对象（creat）</p><p>第二步初始化对象(call、apply（前面刚讲过）)</p><p>第三步便是返回这个对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象工厂造对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line">  User.call(instance, name, age);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来实例化看看吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dy = admin(<span class="string">'dy'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dy.show())</span><br></pre></td></tr></table></figure><p>成功！</p><h1 id="使用mixin实现多继承"><a href="#使用mixin实现多继承" class="headerlink" title="使用mixin实现多继承"></a>使用mixin实现多继承</h1><p>在上面，我们了解到了可以借用其他原型链上的方法满足需求，但有没有其它方式可以使用其它原型链的方法呢。</p><p>“这个我知道，继承那个原型不就好嘛”，哎哟，好像有点道理哦，但这样却可能会导致继承的混乱。</p><p>我们知道，原型链为线形的，也就是说，你只能单向继承，大白话就是你只能有一个亲生爸爸，而如果这时候，跟上面的需求一样，arr数组想用Math对象中的方法时怎么办，</p><p>有小朋友提到了，我可以让Math当Array的爸爸嘛，这样顺着一条原型链上去就能实现方法了嘛，是的没错，但你有没有想过在这个过程中，只是你一个数组需要用到Math中的方法，如果其他数组不需要呢，那么它们也没办法，依然会被绑定到这条原型链上，这样就会造成这条原型链混乱且复杂。</p><p>我们更加希望，事物是有序的，一条继承链下来，对象之间都是有需求的，都是相关联且合理的，所以，这个方法并不可取</p><p>那么有什么方法可以实现这一需求呢：mixin思想，我们使用混入来实现类似多继承的效果，从而使得原原型链（主干）不受影响</p><p>这里要用到Object的一个方法实现类似mixin的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj1, obj2);</span><br></pre></td></tr></table></figure><p>首先创造一个事物构造函数还有其原型的一个方法show</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫`</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创造两个事物构造函数分别继承它，extend详见上面的原型工厂继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Human, Thing);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Car, Thing);</span><br></pre></td></tr></table></figure><p>然后实例化对象并验证下是否继承到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohong = <span class="keyword">new</span> Human(<span class="string">'xiaohong'</span>);</span><br><span class="line">xiaohong.show();</span><br><span class="line"><span class="keyword">let</span> benchi = <span class="keyword">new</span> Car(<span class="string">'banchi'</span>);</span><br><span class="line">benchi.show();</span><br></pre></td></tr></table></figure><p>很幸运，可以使用父类方法展示自己（我叫xiaohong，我叫banchi）</p><p>然后我们创建一个行为类action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我跑'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我叫'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想让benchi和xiaohong都能使用这个类中的方法，但是他们已经有爹地了，这时候我们用mixin思想实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(benchi, action);</span><br><span class="line"><span class="built_in">Object</span>.assign(xiaohong, action);</span><br></pre></td></tr></table></figure><p>然后就执行方法吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">benchi.move(); <span class="comment">//banchi给我跑</span></span><br><span class="line">xiaohong.call(); <span class="comment">//xiaohong给我叫</span></span><br></pre></td></tr></table></figure><p>成功！我们实现了类似多继承</p><h1 id="mixin的内部继承以及super"><a href="#mixin的内部继承以及super" class="headerlink" title="mixin的内部继承以及super"></a>mixin的内部继承以及super</h1><p>还是依照上面的例子，我们想让mixin内部的对象实现继承且，banchi和xiaohong可以调用得到，如何实现嘞</p><p>假设有个todo类，想让它当action的爸爸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todo = &#123;</span><br><span class="line">  doing() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'在 '</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实还是和前面一样的继承，让action的__proto__继承todo即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.__proto__ = todo;</span><br></pre></td></tr></table></figure><p>这样便成功继承，然后我们稍微修改下action里面的方法，使得它可以调用父类todo的方法，这里我们用到<strong>super</strong>关键字</p><blockquote><p>super === this(action).__proto__（this指<strong>当前定义</strong>的对象）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'跑'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'叫'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后同上面一样运行一下，结果也是正常显示啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(benchi.move());</span><br><span class="line"><span class="built_in">console</span>.log(xiaohong.call());</span><br></pre></td></tr></table></figure><p>我们来看一下他们之间的继承关系（可以多画画这种继承图帮助理解）</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/mixin%E6%8C%87%E5%90%91.png" alt="mixin指向"></p><p>好哒，这一部分我们就了解了mixin内部继承以及super代替原型（son.__proto__）这两个重要的知识点啦</p><h1 id="继承操作Dom（综合案例）"><a href="#继承操作Dom（综合案例）" class="headerlink" title="继承操作Dom（综合案例）"></a>继承操作Dom（综合案例）</h1><p>现在有这样一个需求，我们有三个几乎一样的组件，我们想让他们的功能一致，只是样式稍微不同而已，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214206292.png" alt="image-20210528214206292"></p><p>三者都是点击切换按钮切换状态语且改变背景颜色，点击隐藏，下面的状态语模块消失，同时按钮提示语改变，开始动手吧</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214431075.png" alt="image-20210528214431075"></p><p>样式不说，直接上核心代码</p><p>首先创造动作构造函数，并且定义三个方法——隐藏、显示、背景颜色以及提示语改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animation</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animation.prototype.hide = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.change = <span class="function"><span class="keyword">function</span> (<span class="params">color, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.backgroundColor = color;</span><br><span class="line">  <span class="keyword">this</span>.innerHTML = value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创造APP构造函数用于创建展示模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">id, data=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">  <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span><br><span class="line">    value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span><br><span class="line">    tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span><br><span class="line">  &#125;,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让它继承于动作构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(App, Animation);</span><br></pre></td></tr></table></figure><p>接着为两个按钮注册点击事件，同时调用父类的显示隐藏以及切换背景方法</p><p>显示隐藏切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.changeIf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态语切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.toggle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及首次打开页面的初始化方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span><br><span class="line">  <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是执行这三个方法的启动函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.toggle();</span><br><span class="line">  <span class="keyword">this</span>.changeIf();</span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以实例化对象，调用run方法啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span><br><span class="line"> color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span><br><span class="line"> value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span><br><span class="line">&#125;);</span><br><span class="line">div1.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span><br><span class="line">div2.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span><br><span class="line">  color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">div3.run()</span><br></pre></td></tr></table></figure><p>就算你有其它需要类似功能的模块，你也可以直接实例化该对象并执行run方法，而不用每个同功能的模块书写多次相同冗余的代码了</p><p>全部代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        margin: 5px;</span><br><span class="line">        border: 2px solid rgba(226, 121, 247);</span><br><span class="line">        height: 300px;</span><br><span class="line">        width: 500px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      *<span class="selector-attr">[name=<span class="string">"sec"</span>]</span> &#123;</span></span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 80%;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">        color: pink;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">input</span><span class="selector-attr">[name]</span> &#123;</span></span><br><span class="line">        background-color: pink;</span><br><span class="line"><span class="css">        <span class="comment">/* border: pink; */</span></span></span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 10%;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">Animation</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="actionscript">      Animation.prototype.hide = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.change = <span class="function"><span class="keyword">function</span> <span class="params">(color, value)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.backgroundColor = color;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.innerHTML = value;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// * 原型继承工厂函数</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(child, dad)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span></span><br><span class="line">        child.prototype.constructor = child;</span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span></span><br><span class="line">          value: child,</span><br><span class="line"><span class="actionscript">          enumerable: <span class="literal">false</span>,</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">App</span><span class="params">(id, data=&#123;&#125;)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span></span><br><span class="line"><span class="actionscript">          color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span></span><br><span class="line"><span class="actionscript">          value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span></span><br><span class="line"><span class="actionscript">          tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span></span><br><span class="line">        &#125;,data)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      extend(App, Animation);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.changeIf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.toggle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.init = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.run = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.toggle();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.changeIf();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.init()</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">       color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span></span><br><span class="line"><span class="actionscript">       value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span></span><br><span class="line">      &#125;);</span><br><span class="line">      div1.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span></span><br><span class="line">      div2.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span></span><br><span class="line">      &#125;)</span><br><span class="line">      div3.run()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>思维导图总结</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210529101210203.png" alt="image-20210529101210203"></p><p>这便是对以上全部知识点综合练习的案例了，不足之处还望批评指出，<strong>请多多指教</strong></p>]]></content>
    
    <summary type="html">
    
      来吧，快七千字的js原型笔记，好好嚼吧，😭😭😭
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://Dong-666.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-20T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:01.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-amp-C（分而治之）"><a href="#D-amp-C（分而治之）" class="headerlink" title="D&amp;C（分而治之）"></a>D&amp;C（分而治之）</h2><p>工作原理：</p><ol><li>找出简单的基线条件；</li><li>确定如何缩小问题的规模，使其符合基线条件</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>对一块400m * 640m的土地进行划分</p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165345879.png" alt="image-20210829165345879" style="zoom:50%;"><p>对于640 m × 400 m的土地，可从中划出的最 大方块为400 m × 400 m。 这将余下一块更小的土地，其尺寸为400 m × 240 m</p><p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165421947.png" alt="image-20210829165421947"></p><blockquote><p>重点：适用于这小块地的最大方块（正方形），也是适用于整块地的最大方块</p><p>这是关于“欧几里得算法”的知识</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>采用分而治之的思想进行排序，是对<a href="https://baike.baidu.com/item/冒泡排序/4602306" target="_blank" rel="noopener">冒泡排序</a>算法的一种改进</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p>1) 选择基准值。</p><p>2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 </p><p>3) 对这两个子数组进行快速排序。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>使用快速排序进行排序</p><ol><li>定义左数组存储比当前值小的值，右数组存储比当前数值大的值，以及当前比较目标值</li><li>定义基线条件：当当前传参数组索引小于等于1时，停止执行下面代码并返回当前数组</li><li>定义递归条件<ol><li>截取当前数组内要进行比较的目标值，避免参与遍历导致无限循环</li><li>进行遍历：大于当前值放至右数组，小于当前值放至左数组</li></ol></li><li>返回左数组＋当前值+右数组</li></ol><p>![carbon (1)](快速排序/carbon (1).png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 </li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 </li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n) 快得多。</li></ol>]]></content>
    
    <summary type="html">
    
      采用分而治之的思想进行排序，是对冒泡排序算法的一种改进
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-12T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:41.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h2><p>这里涉及的数据类型为<a href="https://blog.csdn.net/Oralinge/article/details/103585108" target="_blank" rel="noopener">引用类型</a>，计算机就像是很多抽屉的集合体，每个抽屉都有地址，当你往里面存储数据时，计算机会将每个数据存储到各自的“抽屉”去，然后用一个内存地址指向该抽屉，方便你根据内存地址去拿取你所需的值</p><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。</p><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>这里只会简单阐述数组和链表的概念，更多会讲述这两种不同数据类型的区别</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>链表是一种物理<a href="https://baike.baidu.com/item/存储单元/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/存储结构/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/数据元素/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/数据元素" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>域。 </p></blockquote><p>简单来说，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。所以，<strong>链表的优势在插入元素方面</strong>。</p><p>当你要往数组插入元素时，计算机要根据数组的长度去寻找一块连续的跟该数组长度相匹配的内存去进行存储，而链表只要存储下个元素的内存地址即可，所以即使链表中的各个数据是分开的不连续的，但还是能通过上一个数据去寻找下个数据的位置。所以在插入数据方面，链表无需考虑其他，直接往内存插入新值即可</p><p>这里举个例子，你和两个朋友去看电影，一般来说，你们三个如果关系太好了，好基友那种，分不开了，你们一般会买三张连续座位的票，从而可以坐在一起看，这便是数组，而当没有三张连续的电影票时，你们只能分开看，但可以根据电影票上的座位位置去找你的小伙伴，这便是链表。这里的座位编号便是内存地址，而你们就是一个又一个的数据。</p><p>在删除方面：链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p><strong>数组</strong>（Array）是有序的元素序列。 [1] 若将有限个类型相同的变量的<a href="https://baike.baidu.com/item/集合/2908117" target="_blank" rel="noopener">集合</a>命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为<a href="https://baike.baidu.com/item/下标变量/12713827" target="_blank" rel="noopener">下标变量</a>。用于区分数组的各个元素的数字编号称为下标。数组是在<a href="https://baike.baidu.com/item/程序设计/223952" target="_blank" rel="noopener">程序设计</a>中，为了处理方便， 把具有相同类型的若干元素按<strong>有序</strong>的形式组织起来的一种形式。  这些有序排列的同类数据元素的集合称为数组</p></blockquote><p>数组的优势：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素</p><h3 id="两者总结"><a href="#两者总结" class="headerlink" title="两者总结"></a>两者总结</h3><ul><li>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起</li><li>数组的元素都在一起</li><li>数组的读取速度比链表快</li><li>链表的插入和删除速度比数组快</li><li>在同一个数组中，所有元素的类型都必须相同</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418" target="_blank" rel="noopener">选择排序（Selection sort）</a>是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><p>有没有思考过对一组数进行排序时的过程是怎样的</p><p>比如要对【1，3，9，5，2】数组进行排序</p><ol><li>我们首先在原数组内进行比较，找出最大值，结果是9，所以我们把他放到新建数组第一个位置【9】</li><li>接着在剩下的数组遍历找出最大的值，是5，放到新数组第二个位置【9，5】</li><li>继续对剩下的三个数字进行同样操作【1，3，2】，得出最终结果【9，5，3，2，1】</li></ol><p>这便是选择排序的过程，一共需要几步呢上面，每次都对原数组进行比较排序，需要进行5趟比较，每趟比较又是和另外几个数的比较，也是5次，所以最终的所需的步数是25，也就是n²</p><blockquote><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n² )呢</p><p>确实，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n – 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但<strong>大O表示法省略诸如1/2这样的常数</strong></p></blockquote><h2 id="选择排序实例代码"><a href="#选择排序实例代码" class="headerlink" title="选择排序实例代码"></a>选择排序实例代码</h2><ol><li><p>数组内比较使用一个函数max进行最大值获取，对数组内每个值进行遍历，找出最大值的索引，具体思路如下</p><blockquote><p>使用变量存储最大值以及最大值索引，给其赋初始值，即为数组第一个数据，接着对数组内数据进行遍历，若遍历到的数据比当前数值大，即将当前变量赋值为它，不断执行该操作，直到遍历完返回该数值索引</p></blockquote></li><li><p>对数组进行排序sort的主函数，使用新数组进行存储排序后的值，接着对原数组进行遍历和最大值查找，找出一个便在原数组删除该数据，避免引起无限循环导致内存泄漏，重复执行，直到最终结果出来</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      arr[minIndex] &gt; arr[j] &amp;&amp; (minIndex = j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一种简单直观的排序算法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-01T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:54.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</p><h2 id="简单查找"><a href="#简单查找" class="headerlink" title="简单查找"></a>简单查找</h2><p>我们在日常生活中经常会玩一个游戏：找数字</p><p>提问者给出该数字的范围，然后回答者根据这个范围进行猜数，如果比正确答案大，提问者便会说大了，如若小了，则提问者回答小了，直至猜出正确答案</p><p>比如：提问者随便想出一个数字-57，范围是0-100，回答者开始猜，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829090857846.png" alt="算法图解-简单查找"></p><p>等到他猜到57，便成功猜到正确答案了，这便是简单查找，回答者一个一个说，直到正确答案出来</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>更简单的查找方式，根据方法名即可猜到，将猜测范围一分为二，比如0-100，那么你猜50，无论是大了还是小了，你立即就可以排除掉一半的数字，接着重复一分为二的操作进行猜数，最后得出正确答案</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091346823.png" alt="image-20210829091346823"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091357416.png" alt="image-20210829091357416"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091407604.png" alt="image-20210829091407604"></p><p>梳理下这个猜数的过程，我们一共进行了几步</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091706567.png" alt="image-20210829091706567"></p><p>回过头去，如果你采用暴力式简单查找，那么你猜的数字便是n（答案n）步，如果目标数字小，还好，如果是99呢，你就得猜到99才能猜到</p><p>引用书籍的另一个例子——</p><blockquote><p>假设你要在字典中查找一个单词，而该字典包含240 000个单词， 你认为每种查找最多需要多少步？ 如果要查找的单词位于字典末尾，使用简单查找将需要240 000步。使用二分查找时，每次排除一半单词，直到最后只剩下一个单词。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829092007999.png" alt="image-20210829092007999"></p><p>可见，随着要猜的范围越来越大，二分查找的优势也越加凸显，而二分查找所需的步数也符合对数的规律</p><blockquote><p>二分查找最多需要log2n步</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单查找-1"><a href="#简单查找-1" class="headerlink" title="简单查找"></a>简单查找</h3><p>我们首先看简单查找的代码实现（这里包括后面只会给出图片格式的代码，因为更多的希望通过实操去理解每个算法的过程）</p><p>直接通过遍历，一个一个判断，最后返回结果</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%AE%80%E5%8D%95%E6%9F%A5%E6%89%BE.png" alt></p><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>看看二分查找的实现代码（因为是根据自己的理解所写，所以多多少少可能会有不合理的地方，望指出）</p><ol><li>首先是写一个回答函数，相当于提问者的回答，传入参数包括回答者的数字和正确的数字</li><li>接着便是使用二分法进行猜数，每次猜中间数，对了返回，不对就根据情况进行数组裁剪，裁剪完继续重复该函数（递归思想）</li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png" alt="二分查找"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>O(log n)比O(n)快（也就是二分法比简单查找快），当需要搜索的元素越多时，前者比后者快得越多</p></blockquote>]]></content>
    
    <summary type="html">
    
      二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/"/>
    <id>http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/</id>
    <published>2021-07-22T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>作用：递归只是让解决方案更清晰，并没有性能上的优势，如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解(但在我看来，递归有时候也很难理解)</p></blockquote><p><a href="https://ypigy.gitee.io/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/" target="_blank" rel="noopener">斐波那契数列</a>就是运用递归的想法进行计算</p><h2 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h2><blockquote><p>每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件</span></span><br><span class="line"><span class="keyword">if</span> (newArr.length === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> newArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归条件</span></span><br><span class="line"><span class="keyword">return</span> newArr.pop() + sum(newArr);</span><br></pre></td></tr></table></figure><p>上面为利用递归进行累加的函数</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>栈只有两种操作：压入 （插入）和弹出（删除并读取）</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829162227622.png" alt="image-20210829162227622"></p><p>数组的压入与弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.pop() <span class="comment">//弹出</span></span><br><span class="line">array.push() <span class="comment">//压入</span></span><br></pre></td></tr></table></figure><p>计算机在内部使用被称为调用栈的栈</p><h3 id="函数与调用栈"><a href="#函数与调用栈" class="headerlink" title="函数与调用栈"></a>函数与调用栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  hi();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bye'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bye();</span><br></pre></td></tr></table></figure><p>下面分析调用bye()发生的事</p><p>首先会为bye分配内存控件，以及该函数所创建的变量也会放到内存</p><p>接着里面会调用另一个函数，所以会在bye上面压入另一个函数hi()，开辟新的内存，同时为其变量分配内存，最后如下图，就像压入一样的操作，根据调用顺序压入内存</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829163034381.png" alt="image-20210829163034381"></p><p>接着就是函数执行，从上到下执行，先弹出最顶部的函数（对应嵌套最深的函数）进行执行，接着一步一步往下执行，最后到最底部的函数（就是最外层函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">hi</span><br><span class="line">bye</span><br></pre></td></tr></table></figure><h2 id="实操-阶乘"><a href="#实操-阶乘" class="headerlink" title="实操-阶乘"></a>实操-阶乘</h2><p>简单阶乘的实现使用了递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fact = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * fact(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析其调用栈如何变化</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164134539.png" alt="image-20210829164134539"></p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164213432.png" alt="image-20210829164213432"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>递归指的是调用自己的函数。 </li><li>每个递归函数都有两个条件：基线条件和递归条件。</li><li>栈有两种操作：压入和弹出。</li><li>所有函数调用都进入调用栈。</li><li>调用栈可能很长，这将占用大量的内存。</li></ul>]]></content>
    
    <summary type="html">
    
      从前有座山，山里有座庙，庙里有个老和尚。。。
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大O表示法</title>
    <link href="http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2021-07-20T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:36.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><blockquote><p>大O表示法指出了算法有多块</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095256434.png" alt="image-20210829095256434"></p><ol><li>大 O 表示法指出了最糟情况下的运行时间（算法执行步数）<ul><li>除最糟情况下的运行时间外，还应考虑平均情况的运行时间</li></ul></li></ol><h2 id="一些常见的大-O-运行时间"><a href="#一些常见的大-O-运行时间" class="headerlink" title="一些常见的大 O 运行时间"></a>一些常见的大 O 运行时间</h2><ol><li>O(log n)，也叫对数时间，这样的算法包括二分查找。 </li><li>O(n)，也叫线性时间，这样的算法包括简单查找。</li><li>O(n * log n)，一种速度较快的排序算法。</li><li>O(n2 )，一种速度较慢的排序算法。</li><li>O(n!)，包括旅行商问题等——一种非常慢的算法。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095521599.png" alt="image-20210829095521599"></p><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><blockquote><p>算法的速度指的并非时间，而是操作数的增速。</p><p>谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 </p><p>算法的运行时间用大O表示法表示。</p><p>大O表示法省略诸如1/2这样的常数</p></blockquote>]]></content>
    
    <summary type="html">
    
      大O表示法指出了算法有多块
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-数据链路层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2022-04-17T13:31:52.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先看看不同定义下的计算机网络体系结构</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412184905304.png" alt="image-20210412184905304"></p><p>在OSI和五层协议里面，数据链路层都在其中扮演着重要的角色，在TCP/IP的体系结构里，数据链路层及以下则被抽象掉了</p><p>数据链路层是实现设备之间通信的非常重要的一层，不管经过的是什么网络，电话网、局域网、广域网等，需要注意的是：在里面，<strong>路由器在转发分组时只用到下三层协议</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185205003.png" alt="image-20210412185205003"></p><p>再来看看处于交换机下的数据链路层</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185623966.png" alt="image-20210412185623966"></p><p>若主机H1向H2发送数据，则实际上数据的流动是通过五层从左向右，从上向下传递过去的，但若只从数据链路层来看的话，数据是从H1→R1→R2→R2→R3→H2的链路层传过去的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412185733062.png" alt="image-20210412185733062"></p><p>数据链路层使用的信道主要有以下两种类型</p><p>(a) <strong>点对点信道</strong>：这种信道使用一对一的点对点通信方式。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412190326192.png" alt="image-20210412190326192"></p><p>(b) <strong>广播信道</strong>：使用一对多的广播通信方式。必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412190337871.png" alt="image-20210412190337871"></p><h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><h2 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h2><h3 id="链路和数据链路的区别"><a href="#链路和数据链路的区别" class="headerlink" title="链路和数据链路的区别"></a>链路和数据链路的区别</h3><p><strong>链路 (link)</strong> 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>简单来说：一条链路只是一条通路的一个组成部分。</p><p><strong>数据链路 (data link)</strong> 除了物理线路外，还必须有<strong>通信协议</strong>来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 </p><p>也有人采用另外的术语。这就是把链路分为<strong>物理链路</strong>和<strong>逻辑链路</strong>。<br>物理链路就是上面所说的链路。逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。</p><p>早期的数据通信协议曾叫做<strong>通信规程 (procedure)</strong>。因此在数据链路层，<strong>规程和协议是同义语</strong>。</p><h3 id="数据链路层传送的是帧"><a href="#数据链路层传送的是帧" class="headerlink" title="数据链路层传送的是帧"></a>数据链路层传送的是帧</h3><p>数据链路层通过将网络层传下来的ip数据包进行<strong>封装成帧</strong>然后再传给物理层，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412191405152.png" alt="image-20210412191405152"></p><p>通常，我们会在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412191726824.png" alt="image-20210412191726824"></p><p>数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。在之后的学习也是一样，随着往上层的学习，有时候为了屏蔽掉下层带给自己的干扰，我们大多时候会直接考虑数据是在对等层之间进行传递（实际上并不是）</p><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：</p><ol><li><strong>封装成帧</strong></li><li><strong>透明传输</strong></li><li><strong>差错控制</strong> </li></ol><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p><p>首部和尾部的一个重要作用就是进行帧定界。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194144658.png" alt="image-20210412194144658"></p><p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。</p><p>控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194215116.png" alt="image-20210412194215116"></p><p>如果<strong>数据中</strong>的某个字节的<strong>二进制代码</strong>恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412194504407.png" alt="image-20210412194504407"></p><p>为啥会出现这种情况呢，因为数据链路层在传递数据的时候是“透明”的，即透明传输</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p>透明：指某一个实际存在的事物看起来却好像不存在一样。（想象一个完全透明的玻璃在你面前）</p></blockquote><p>“在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。这便是透明传输，也就是说，对面的数据链路层也会去解析你的整个帧，一不小心解析到了本存在于数据而不是帧定界的EOT时，就会误认终止而抛弃掉后面的帧</p><p>解决方法：<strong>字节填充 (byte stuffing)</strong> 或<strong>字符填充 (character stuffing)</strong>。</p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195139392.png" alt="image-20210412195139392"></p><h2 id="差错检错"><a href="#差错检错" class="headerlink" title="差错检错"></a>差错检错</h2><p>在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195225962.png" alt="image-20210412195225962"></p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER (Bit Error Rate)。</strong></p><p>误码率与<strong>信噪比</strong>有很大的关系。</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种<strong>差错检测</strong>措施。 下面介绍一种检测措施——循环循环冗余检验码</p><h3 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h3><p>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验 CRC</strong> 的<strong>检错技术。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412195833103.png" alt="image-20210412195833103"></p><p>在发送端，先把数据划分为组。假定每组 k 个比特。 </p><p>在每组 M 后面再添加供差错检测用的 n 位冗余码，然后一起发送出去。 </p><h3 id="冗余码的计算"><a href="#冗余码的计算" class="headerlink" title="冗余码的计算"></a>冗余码的计算</h3><p>用二进制的模 2 运算进行 2n 乘数据M 的运算，这相当于<strong>在 M 后面添加 n 个 0</strong>。</p><p>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 </p><p>将余数 R 作为冗余码拼接在数据 M 后面，一起发送出去。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412200326411.png" alt="image-20210412200326411"></p><p>接收端会对收到的每一帧进行 CRC 检验</p><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。</p><p>(2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。<br>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p><p>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 </p><h3 id="冗余码的计算举例"><a href="#冗余码的计算举例" class="headerlink" title="冗余码的计算举例"></a>冗余码的计算举例</h3><p>现在 k = 6, M = 101001。<br>设 n = 3, 除数 P = 1101，<br>被除数是 2的n次*M = 101001000。<br>模 2 运算的结果是：商 Q = 110101，余数 R = 001。<br>把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R，即：101001001，共 (k + n) 位。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412200553273.png" alt="image-20210412200553273"></p><h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p><p>循环冗余检验 CRC 和帧检验序列 FCS 并不等同。<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。<br><strong>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。</strong> </p><p>最后应当注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)。</p><p>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。</p><p>应当明确，<strong>“无比特差错”</strong>与<strong>“无传输差错”</strong>是不同的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。要做到“无差错传输”（即发送什么就收到什么）就必须再加上<strong>确认和重传机制。</strong> 本章介绍的数据链路层协议都<strong>不是可靠传输</strong>的协议。</p><h1 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h1><h2 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h2><p>对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p><p>PPP 协议在 1994 年就已成为互联网的正式标准。</p><p>用户到 ISP 的链路使用 PPP 协议 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412201655878.png" alt="用户到ISP的链路使用PPP协议 "></p><p><strong>PPP 协议应满足的需求</strong></p><ol><li><strong>简单 —— 这是首要的要求。</strong></li><li><strong>封装成帧</strong> —— 必须规定特殊的字符作为帧定界符。</li><li><strong>透明性</strong> —— 必须保证数据传输的透明性。</li><li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li><li>多种类型链路 —— 能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li><li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</li></ol><p><strong>PPP 协议有三个组成部分：</strong></p><ol><li>一个将 IP 数据报封装到串行链路的方法。</li><li><strong>链路控制协议 LCP</strong> (Link Control Protocol)。</li><li><strong>网络控制协议 NCP</strong> (Network Control Protocol)。 </li></ol><h2 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h2><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。</p><p>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。</p><p>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。<br>控制字段 C 通常置为 0x03。</p><p><strong>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202618347.png" alt="image-20210412202618347"></p><p>PPP 有一个 2 个字节的协议字段。其值<br>若为 0x0021，则信息字段就是 IP 数据报。<br>若为 0x8021，则信息字段是网络控制数据。<br>若为 0xC021，则信息字段是 PPP 链路控制数据。<br>若为 0xC023，则信息字段是鉴别数据。</p><p><strong>PPP在透明传输的相关问题</strong></p><p>当 PPP 用在异步传输时，就使用一种特殊的<strong>字符填充法</strong>。<br>当 PPP 用在同步传输链路时，协议规定采用硬件来完成<strong>比特填充</strong>（和 HDLC 的做法一样）。  </p><h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。 </p><p>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。</p><p>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202818142.png" alt="image-20210412202818142"></p><h3 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h3><p>PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p><p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。</p><p>接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412202911660.png" alt="image-20210412202911660"></p><p> PPP是不提供使用序号和确认的可靠传输的，为什么呢，原因如下</p><ol><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。</li></ol><h2 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h2><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p><p>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p><p>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p><p>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203110510.png" alt="image-20210412203110510"></p><h1 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h1><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p>局域网最主要的特点是：网络为一个单位所拥有；地理范围和站点数目均有限。 </p><p>局域网具有如下主要优点：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203528660.png" alt="image-20210412203528660"></p><p>一开始因为技术原因，没办法制造出廉价的集线器，所以采用的是总线型的局域网，这样的类型有着如下特点：各个主机是在一同条信道上进行通信的，使用一对多的广播通信方式。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412203948749.png" alt="image-20210412203948749"></p><p>但是它存在着问题：若多个设备在共享的广播信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p>共享信道要考虑的便是如何让众多用户能够合理方便的共享通信媒体资源，总的分为两种方法</p><ol><li><p>静态划分信道（物理层）</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用 </li></ul></li><li><p>动态媒体接入控制（多点接入）</p><ul><li>随机接入</li><li>受控接入 ，如多点线路探询 (polling)，或轮询。      </li></ul></li></ol><h3 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a><strong>以太网的两个标准</strong></h3><p> DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。<br>IEEE 802.3 是第一个 IEEE 的以太网标准。</p><p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。</p><p>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。</p><h3 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a><strong>数据链路层的两个子层</strong></h3><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层：</p><ol><li><p>逻辑链路控制 LLC (Logical Link Control)子层；</p></li><li><p>媒体接入控制 MAC (Medium Access Control)子层。</p></li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。不管采用何种协议的局域网，对 LLC 子层来说都是透明的（有点像TCP/IP协议）。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412204812504.png" alt="image-20210412204812504"></p><p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 </p><h3 id="适配器（网卡）"><a href="#适配器（网卡）" class="headerlink" title="适配器（网卡）"></a>适配器（网卡）</h3><blockquote><p>网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或“网卡”。 </p></blockquote><p>适配器的重要功能：</p><ol><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412204941268.png" alt="image-20210412204941268"></p><p>当适配器收到正确的帧时，它就会使用中断来通知计算机，并交付给协议栈中的网络层；这里值得注意的是：当收到的是有差错的帧时，适配器会直接丢掉该帧而不会去通知计算机。当计算机要发送ip数据包时，就由协议栈把IP数据包下交给适配器，组装成帧后发送到局域网。</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>最初的以太网是将许多计算机都连接到一根总线上。易于实现<strong>广播通信</strong>。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（当时普遍认为有源器件不可靠，无源的电缆线才是最可靠的）。</p><p> 为了实现一对一通信，将接收站的硬件地址写入帧首部中的目的地址字段中。仅当数据帧中的目的地址与适配器的硬件地址一致时，才能接收这个数据帧。比如下图中的B向D发送数据</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412205728382.png" alt="image-20210412205728382"></p><p>总线当然也有缺点。就像前面说的，若多台计算机或多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412205830005.png" alt="image-20210412205830005"></p><p>在讨论解决冲突或碰撞的方法前，先来看看以太网采取的两种重要的措施</p><p><strong>(1) 采用较为灵活的无连接的工作方式</strong></p><p>不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</p><p>以太网提供的服务是不可靠的交付，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p><p>而如果高层发现丢失了一些数据而进行重传，此时以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 </p><p><strong>(2) 以太网发送的数据都使用曼彻斯特 (Manchester) 编码</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412210100341.png" alt="image-20210412210100341"></p><p>曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p><p>下面就介绍碰撞或冲突的解决方法</p><h3 id="CSMA-CD-协议要点（多点接入、载波监听、碰撞检测）"><a href="#CSMA-CD-协议要点（多点接入、载波监听、碰撞检测）" class="headerlink" title="CSMA/CD 协议要点（多点接入、载波监听、碰撞检测）"></a>CSMA/CD 协议要点（多点接入、载波监听、碰撞检测）</h3><p><strong>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  (Carrier Sense Multiple Access with Collision Detection) 。</strong></p><p><strong>“多点接入”</strong>表示许多计算机以多点接入的方式连接在一根总线上。</p><p><strong>“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</strong> </p><p>总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p><p>实际上，不管在发送前还是发送中，每个站必须不停地检测信道，那么在发送中站是如何检测的呢？</p><p><strong>“碰撞检测”就是站在发送数据过程中对信道进行监听的操作</strong></p><p><strong>“碰撞检测”</strong>就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</p><p>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</p><p>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</p><p>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</p><p>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p><p>CSMA/CD协议工作流程如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412224725977.png" alt="image-20210412224725977"></p><p>为何要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响，比如你现在在开会，两个人都想发言，但你们都克制住了，因为有另一个人在发言，这时候你们采用的便是<strong>载波监听</strong>，等到他讲完了，你们两<strong>载波监听</strong>没有监听到有人在说话准备想讲时，你讲了出来，结果巧了，他也同时讲了出来，两句话便在传播上起了冲突，看似同个时间讲的，其实可能是你早了那么几毫秒讲，但同时他的<strong>载波监听</strong>刚返回确认没有声音传出，他也开讲。而在这时候，如果你们不在讲的时候采取<strong>碰撞检测</strong>，一方停止讲话，那么你们两个人的声音就会彼此“吵架”</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210412224847718.png" alt="image-20210412224847718"></p><p>最先发送数据帧的站，在发送数据帧后至多经过时间 2r （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</p><p>以太网的端到端往返时延 2r  称为争用期，或碰撞窗口。</p><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><h3 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h3><blockquote><p>以太网使用截断二进制指数退避算法来确定碰撞后重传的时机</p></blockquote><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ol><li><p><strong>基本退避时间取为争用期 2я。</strong></p></li><li><p>从整数集合 [0, 1, … , (2k - 1)] 中随机地取出一个数，记为 r。重传所需的时延就是 <strong>r 倍</strong>的基本退避时间。</p></li><li><p>参数 k 按下面的公式计算：</p><blockquote><p>k = Min[重传次数, 10]</p></blockquote></li><li><p>当 k ≤10 时，参数 k 等于重传次数。</p></li><li><p>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 </p></li></ol><p>举个栗子<br>第 1 次冲突重传时：<br>    k = 1，r 为 {0，1} 集合中的任何一个数。<br>第 2 次冲突重传时：<br>    k = 2，r 为 {0，1，2，3} 集合中的任何一个数。<br>第 3 次冲突重传时：<br>    k = 3，r 为 {0，1，2，3，4，5，6，7} 集合中的任何一个数。</p><h3 id="10-Mbit-s-以太网争用期的长度"><a href="#10-Mbit-s-以太网争用期的长度" class="headerlink" title="10 Mbit/s 以太网争用期的长度"></a><strong>10 Mbit/s 以太网争用期的长度</strong></h3><p>10 Mbit/s 以太网取 51.2μs 为争用期的长度。<br>对于 10 Mbit/s 以太网，以太网规定了最短有效帧长为 64 字节，在争用期内可发送 512 bit（即 64 字节）。所以凡长度小于 64 字节的帧都是由于冲突而异常中止的<strong>无效帧</strong>。</p><blockquote><p>这意味着：<br>以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</p></blockquote><p>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 </p><h4 id="覆盖范围"><a href="#覆盖范围" class="headerlink" title="覆盖范围"></a>覆盖范围</h4><p>在 10 Mbit/s 以太网 51.2 μs 的争用期内，信号能传输多远的距离？</p><p>以太网上最大的端到端单程时延必须小于争用期的一半（即 25.6 μs），这相当于以太网的最大端到端长度约为 5 km。</p><h3 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h3><blockquote><p>当发送数据的站一旦发现发生碰撞时，除了立即停止发送数据外，还要继续发送32比特或48比特的人为干扰信号，以让所有用户都知道已经发生了碰撞</p></blockquote><p>注意：B 也能够检测到冲突，并立即停止发送数据帧，接着就发送干扰信号。<br>这里为了简单起见，只画出 A 发送干扰信号的情况。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413150301732.png" alt="image-20210413150301732"></p><h3 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h3><ol><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行<strong>双向交替通信（半双工通信）</strong>。</li><li>每个站在发送数据之后的一小段时间内，存在着<strong>遭遇碰撞</strong>的可能性。 </li><li>这种发送的不确定性使整个以太网的平均通信量<strong>远小于</strong>以太网的最高数据率。 </li></ol><p>下面是该协议整个过程的流程图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413150725543.png" alt="image-20210413150725543"></p><h2 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h2><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p><p>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，<strong>叫做集线器 (hub)</strong>。</p><p>传统的总线拓扑结构（前面详细讲过了）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413152754451.png" alt="image-20210413152754451"></p><p>使用集线器的双绞线以太网，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413152825307.png" alt="image-20210413152825307"></p><h3 id="星形以太网-10BASE-T"><a href="#星形以太网-10BASE-T" class="headerlink" title="星形以太网 10BASE-T"></a>星形以太网 10BASE-T</h3><p><strong>10BASE-T特点如下</strong></p><ol><li>使用无屏蔽双绞线，采用星形拓扑。</li><li>每个站需要用两对双绞线，分别用于发送和接收。</li><li>双绞线的两端使用 RJ-45 插头。</li><li>集线器使用了大规模集成电路芯片，因此集线器的可靠性提高。 </li><li>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100m。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413153048104.png" alt="image-20210413153048104"></p><p>这种 10 Mbit/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 具有很高的性价比。</p><p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。从此以太网的拓扑就从总线形变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。 </p><h3 id="集线器特点"><a href="#集线器特点" class="headerlink" title="集线器特点"></a>集线器特点</h3><ol><li>集线器是<strong>使用电子器件来模拟实际电缆线</strong>的工作，因此整个系统仍然像一个传统的以太网那样运行。 </li><li>使用集线器的以太网<strong>在逻辑上仍是一个总线网</strong>，各工作站使用的还是 <strong>CSMA/CD 协议，并共享逻辑上的总线</strong>。 </li><li>集线器很像一个<strong>多接口</strong>的转发器，工作在物理层。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li></ol><p>结构图如下</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413153248800.png" alt="image-20210413153248800"></p><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><p>多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%。</p><p>假设я（该符号暂时找不到，所以统一用这个代替一下） 是以太网单程端到端传播时延。则争用期长度为 2я ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。</p><p>设帧长为 L (bit)，数据发送速率为 C (bit/s)，则帧的发送时间为  T0 = L/C (s)。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413155601307.png" alt="image-20210413155601307"></p><p>一个站在发送帧时出现了碰撞。经过一个争用期 2я 后，可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 T0。</p><p>通过图我们注意到，成功发送一个帧需要占用信道的时间是 T0 + я，比这个帧的发送时间要多一个单程端到端时延я。<strong>这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播</strong>。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是я 。</p><p>因此，必须经过时间T0 + я后以太网的媒体才处于完全空闲状态</p><p>我们在以太网中定义了参数 a ，它是以太网单程端到端时延я与帧的发送时间 T0 之比： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413155822743.png" alt="image-20210413155822743"></p><p>通过公式我们可以知道：要提高以太网的信道利用率，就必须减小я与 T0 之比。</p><p>a → 0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 </p><p>为提高利用率，以太网的参数 a 的值应当尽可能小些。<br>对以太网参数 a 的要求是：当数据率一定时，以太网的连线的长度受到限制，否则я的数值会太大。以太网的帧长不能太短，否则 T0 的值会太小，使 a 值太大。 </p><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是 T0 + я ，而帧本身的发送时间是 T0。于是，我们可计算出理想情况下的极限信道利用率 Smax 为： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413160220692.png" alt="image-20210413160220692"></p><p>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。<br>据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><h3 id="MAC-层的硬件地址"><a href="#MAC-层的硬件地址" class="headerlink" title="MAC 层的硬件地址"></a>MAC 层的硬件地址</h3><blockquote><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 </p></blockquote><p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。</p><p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或路由器就有多个“地址”。更准确些说，这种 48 位“地址”应当是某个接口的标识符。</p><p>IEEE 802 标准规定 MAC 地址字段可采用 6 字节 ( 48位) 或 2 字节 ( 16 位) 这两种中的一种。<br>IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。<br>地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161124465.png" alt="image-20210413161124465"></p><p>所以，一个地址块可以生成 224 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。<br>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址 (hardware address) 或物理地址。<br>“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</p><h4 id="单站地址，组地址，广播地址"><a href="#单站地址，组地址，广播地址" class="headerlink" title="单站地址，组地址，广播地址"></a>单站地址，组地址，广播地址</h4><p>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。</p><p>当 I/G 位 = 0 时，地址字段表示一个<strong>单站地址</strong>。</p><p>当 I/G 位 = 1 时，表示<strong>组地址</strong>，用来进行多播（以前曾译为组播）。此时，IEEE 只分配地址字段前三个字节中的 23 位。</p><p>当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 223 个单个站地址和 223 个组地址。</p><p>所有 48 位都为 1 时，为<strong>广播地址</strong>。只能作为目的地址使用。</p><h4 id="全球管理与本地管理"><a href="#全球管理与本地管理" class="headerlink" title="全球管理与本地管理"></a>全球管理与本地管理</h4><p>IEEE 把地址字段第一字节的最低第 2 位规定为 G/L 位，表示 Global / Local。</p><p>当 G/L 位 = 0 时，是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于全球管理。</p><p>当 G/L 位 = 1 时， 是本地管理，这时用户可任意分配网络上的地址。</p><h4 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h4><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是发往本站的帧则收下，然后再进行其他的处理。<br>否则就将此帧丢弃，不再进行其他的处理。</p><blockquote><p>“发往本站的帧”包括以下三种帧： </p><ol><li>单播 (unicast) 帧（一对一）</li><li>广播 (broadcast) 帧（一对全体）</li><li>多播 (multicast) 帧（一对多）</li></ol></blockquote><p>所有的适配器都至少能够识别前两种帧，即<strong>能够识别单播地址和广播地址。有的适配器可用编程方法识别多播地址。</strong></p><p><strong>只有目的地址才能使用广播地址和多播地址。</strong></p><p>以<strong>混杂方式 (promiscuous mode)</strong> 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。</p><h3 id="MAC-帧的格式"><a href="#MAC-帧的格式" class="headerlink" title="MAC 帧的格式"></a>MAC 帧的格式</h3><p>常用的以太网 MAC 帧格式有两种标准：<br><strong>DIX Ethernet V2 标准</strong><br><strong>IEEE 的 802.3 标准</strong></p><h4 id="以太网V2标准下的MAC帧"><a href="#以太网V2标准下的MAC帧" class="headerlink" title="以太网V2标准下的MAC帧"></a>以太网V2标准下的MAC帧</h4><p>最常用的 MAC 帧是以太网 V2 的格式。下面就来讲解以太网V2标准下的MAC帧</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161523396.png" alt="image-20210413161523396"></p><p>其中，目的地址和源地址都是6字节，类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。 </p><p>数据字段的正式名称是 MAC 客户数据字段。<br>最小长度 64 字节 - 18 字节的首部和尾部 = 数据字段的最小长度（46字节） </p><p>当传输媒体的误码率为 1x10-8 时，MAC 子层可使未检测到的差错小于 1x10-14 。 </p><p><strong>注意：当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。</strong> </p><p>在帧的前面插入（硬件生成）的 8 字节中，第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段 1 个字节是帧开始定界符，表示后面的信息就是 MAC 帧。 </p><p>最后，<strong>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</strong></p><h4 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h4><p>无效的MAC帧主要有以下特点</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li></ul><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</p><p>怎么解决这些无效的帧，对的，丢掉，前面有提到过</p><blockquote><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p></blockquote><h4 id="IEEE-802-3-MAC-帧"><a href="#IEEE-802-3-MAC-帧" class="headerlink" title="IEEE 802.3 MAC 帧"></a>IEEE 802.3 MAC 帧</h4><p>下面再来讲讲IEEE 802.3 MAC 帧格式</p><p>与以太网 V2 MAC 帧格式相似，区别在于：</p><ol><li>IEEE 802.3 规定的 MAC 帧的第三个字段是<strong>“长度 / 类型”</strong>。<ol><li>当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。</li><li>当这个字段值小于 0x0600 时才表示“长度”。</li></ol></li><li>当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</li></ol><p>让我们再搬出V2 MAC帧的图进行对比</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413161523396.png" alt="image-20210413161523396"></p><blockquote><p>现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p></blockquote><p>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。</p><blockquote><p><strong>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</strong> </p></blockquote><h1 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h1><h2 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h2><p>有两种方式可以对以太网进行扩展</p><ul><li><p>使用光纤扩展<br>主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。 很容易使主机和几公里以外的集线器相连接。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413163939949.png" alt="image-20210413163939949"></p></li><li><p>使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413164058671.png" alt="image-20210413164058671"></p></li></ul><p>使用集线器扩展以太网的优缺点有啥</p><p><strong>优点</strong></p><ol><li><p>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</p></li><li><p>扩大了以太网覆盖的地理范围。</p></li></ol><p><strong>缺点</strong></p><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 </li></ol><p>这里的碰撞域是什么意思</p><blockquote><p>碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。碰撞域越大，发生碰撞的概率越高。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165236969.png" alt="image-20210413165236969"></p><p>这样，即使你使用了多个集线器，但其实它们还是属于同个碰撞域，也就是说，在每个碰撞域里只能由一个站再发送数据，这样吞吐量和一个集线器形成的碰撞域是一样的。</p><p>接下来再来讲讲一种更高效的方法——<strong>交换机</strong></p><h2 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h2><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165441193.png" alt="image-20210413165441193"></p><p>网桥工作在数据链路层。它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。<br>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </p><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong>。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。以太网交换机具有<strong>并行性</strong>。能同时连通多对接口，使多对主机能同时通信。</p><p>相互通信的主机都是独占传输媒体，都能进行无碰撞地传输数据。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165626642.png" alt="image-20210413165626642"></p><p>这样，以太网交换机的每个接口是一个碰撞域，吞吐量相比较单纯集线器大大提高</p><h3 id="以太网交换机特点、优点"><a href="#以太网交换机特点、优点" class="headerlink" title="以太网交换机特点、优点"></a>以太网交换机特点、优点</h3><p><strong>以太网交换机具有怎样的特点呢</strong></p><ul><li>以太网交换机的接口有<strong>存储器</strong>，能在输出端口繁忙时把到来的帧进行<strong>缓存</strong>。</li><li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的<strong>帧交换表</strong>（又称为地址表）是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li><li>以太网交换机使用了专用的<strong>交换结构</strong>芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li><li>以太网交换机的<strong>性能</strong>远远超过普通的集线器，而且价格并不贵。</li></ul><p>通过上面的介绍，让我们来看看以太网交换机具有怎样的优点</p><ol><li><p>用户独享带宽，增加了总容量。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170307329.png" alt="image-20210413170307329"></p></li><li><p>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。</p></li><li><p>以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。</p></li></ol><h3 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h3><ol><li><p><strong>存储转发方式</strong><br>把整个数据帧<strong>先缓存后再进行处理</strong>。</p></li><li><p><strong>直通 (cut-through) 方法</strong><br>接收数据帧的同时就立即按<strong>数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</p><p><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些<strong>无效帧</strong>转发给其他的站。</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170618836.png" alt="image-20210413170618836"></p><p>在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。</p><h3 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h3><p>多图预警，通过多个图来描述以太网交换机自学习过程</p><p>开始时，交换表是空的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170859854.png" alt="image-20210413170859854"></p><p>然后A 先向 B 发送一帧。该帧从接口 1 进入到交换机。</p><p>交换机收到帧后，先查找交换表。没有查到应从哪个接口转发这个帧给 B。</p><p>交换机把这个帧的源地址 A 和接口 1 <strong>写入交换表</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413170932553.png" alt="image-20210413170932553"></p><p>交换机向除接口 1 以外的所有的接口广播这个帧。</p><p>由于与该帧的目的地址不相符，C 和 D 将丢弃该帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171303606.png" alt="image-20210413171303606"></p><p>B 向 A 发送一帧。该帧从接口 3 进入到交换机。</p><p>交换机收到帧后，先查找交换表。发现交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p><p>交换机把这个帧的源地址 B 和接口 3 写入交换表中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171342002.png" alt="image-20210413171342002"></p><p>最后，考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目<strong>都设有一定的有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><blockquote><p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p></blockquote><p>最后，通过一张图来归纳交换机自学习和转发帧的步骤归纳</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413171701153.png" alt="image-20210413171701153"></p><h3 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h3><p>来啦，小测验</p><p>假设：A 向 B 发送了一帧，C 向 E 发送了一帧，E 向 A 发送了一帧。<br>请分析：此时，S1 和 S2 的交换表内容分别是什么？</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413172314284.png" alt="image-20210413172314284"></p><p>答案如下</p><p>S1表</p><table><thead><tr><th align="center">MAC地址</th><th align="center">接口</th><th align="center">有效时间</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">B</td><td align="center">3</td><td align="center"></td></tr><tr><td align="center">E</td><td align="center">5</td><td align="center"></td></tr></tbody></table><p>s2表</p><table><thead><tr><th align="center">MAC地址</th><th align="center">接口</th><th align="center">有效时间</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">5</td><td align="center"></td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center"></td></tr><tr><td align="center">E</td><td align="center">1</td><td align="center"></td></tr></tbody></table><h3 id="回路"><a href="#回路" class="headerlink" title="回路"></a>回路</h3><p>现在来看看交换机存在的一个问题</p><p>假定开始时，交换机 S1 和 S2 的交换表都是空的。<br>主机 A 向主机 E 发送一帧。交换机在没有交换表的情况下会对其进行广播，让我们看看其中一个数据的流动线路情况，从交换机S1接口5出发，到另一个交换机S2，再次广播，其中一条路跑到接口6，然后又跑回交换机S1，再进行广播，其中一条跑到接口5，如此循环下去，便形成了回路</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%9E%E8%B7%AF.gif" alt="交换机回路"></p><p>怎么解决：<strong>生成树协议 STP</strong></p><p>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP  (Spanning Tree Protocol)</strong>。<br>其要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173446655.png" alt="image-20210413173446655"></p><h2 id="从总线以太网到星形以太网"><a href="#从总线以太网到星形以太网" class="headerlink" title="从总线以太网到星形以太网"></a>从总线以太网到星形以太网</h2><p>现在对以太网的发展历程进行总结</p><p>早期，以太网采用无源的总线结构。现在，采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA/CD 协议，以全双工方式工作。但仍然采用以太网的帧结构。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413165441193.png" alt="image-20210413165441193"></p><p> CSMA/CD 协议下的局域网存在的以下几个方面的问题：</p><ol><li>扩展性</li><li>安全性</li><li>可管理性 等</li></ol><p>所有计算机都处于同一个<strong>碰撞域（或冲突域）</strong>中和同一个<strong>广播域</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173722363.png" alt="image-20210413173722363"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173806387.png" alt="image-20210413173806387"></p><blockquote><p><strong>广播域（broadcast domain）</strong>：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p></blockquote><p>若采用以太网交换机的星形以太网</p><p>每个接口都处于一个独立的<strong>碰撞域（或冲突域）</strong>中，但所有计算机都处于同一个<strong>广播域</strong>中。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174031621.png" alt="image-20210413174031621"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413173947505.png" alt="image-20210413173947505"></p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</p><p>IEEE 802.1Q 对虚拟局域网 VLAN 的定义：</p><blockquote><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p></blockquote><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></p><p>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174232906.png" alt="image-20210413174232906"></p><p>这张图中，每个虚拟局域网是一个广播域。VLAN1, VLAN2 和 VLAN3 是三个不同的广播域。</p><p>当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到其广播的信息。而VLAN1 和 VLAN3 中的工作站 A1，A2 和 C1 等都不会收到 B1 发出的广播信息。 </p><p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即“<strong>广播风暴</strong>”) 而引起性能恶化。 </p><h3 id="VLAN优点"><a href="#VLAN优点" class="headerlink" title="VLAN优点"></a>VLAN优点</h3><p><strong>虚拟局域网（VLAN）技术具有以下主要优点：</strong></p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h3 id="划分虚拟局域网的方法"><a href="#划分虚拟局域网的方法" class="headerlink" title="划分虚拟局域网的方法"></a>划分虚拟局域网的方法</h3><ul><li>基于交换机端口</li><li>基于计算机网卡的MAC地址</li><li>基于协议类型</li><li>基于IP子网地址</li><li>基于高层应用或服务</li></ul><h4 id="基于交换机端口"><a href="#基于交换机端口" class="headerlink" title="基于交换机端口"></a>基于交换机端口</h4><p>先讲讲基于交换机端口的方法：</p><p>最简单、也是最常用的方法。<br>属于在第一层划分虚拟局域网的方法。<br>缺点：不允许用户移动。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174534860.png" alt="image-20210413174534860"></p><h4 id="基于计算机网卡的MAC地址的方法"><a href="#基于计算机网卡的MAC地址的方法" class="headerlink" title="基于计算机网卡的MAC地址的方法"></a>基于计算机网卡的MAC地址的方法</h4><p>根据用户计算机的MAC地址划分虚拟局域网。属于在第二层划分虚拟局域网的方法。允许用户移动。</p><p>缺点：需要输入和管理大量的MAC地址。如果用户的MAC地址改变了，则需要管理员重新配置VLAN。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413174643551.png" alt="image-20210413174643551"></p><table><thead><tr><th>MAC  地址</th><th>VLAN</th></tr></thead><tbody><tr><td>00-15-F5-CC-C8-14</td><td>10</td></tr><tr><td>C0-AB-D5-00-18-F4</td><td>10</td></tr><tr><td>C0-C5-18-DE-BC-E6</td><td>30</td></tr></tbody></table><h4 id="基于协议类型的方法"><a href="#基于协议类型的方法" class="headerlink" title="基于协议类型的方法"></a>基于协议类型的方法</h4><p>根据<strong>以太网帧的第三个字段“类型”字段</strong>确定该类型的协议属于哪一个虚拟局域网。<br>属于在第二层划分虚拟局域网的方法。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175313847.png" alt="image-20210413175313847"></p><table><thead><tr><th>“类型”</th><th>VLAN</th></tr></thead><tbody><tr><td>IP</td><td>10</td></tr><tr><td>IPX</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h4 id="基于IP子网地址的方法"><a href="#基于IP子网地址的方法" class="headerlink" title="基于IP子网地址的方法"></a>基于IP子网地址的方法</h4><p>根据<strong>以太网帧的第三个字段“类型”字段</strong>和<strong>IP分组首部中的源 IP 地址字段</strong>确定该 IP 分组属于哪一个虚拟局域网。<br>属于在第三层（网络层）划分虚拟局域网的方法。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175434466.png" alt="image-20210413175434466"></p><table><thead><tr><th>IP  子网</th><th>VLAN</th></tr></thead><tbody><tr><td>192.168.1.0/24</td><td>10</td></tr><tr><td>192.168.2.0/24</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h4 id="基于高层应用或服务的方法"><a href="#基于高层应用或服务的方法" class="headerlink" title="基于高层应用或服务的方法"></a>基于高层应用或服务的方法</h4><p>根据高层应用或服务、或者它们的组合划分虚拟局域网。<br>更加灵活，但更加复杂。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175556212.png" alt="image-20210413175556212"></p><table><thead><tr><th>应用</th><th>VLAN</th></tr></thead><tbody><tr><td>FTP</td><td>10</td></tr><tr><td>TELNET</td><td>30</td></tr><tr><td>……</td><td>…</td></tr></tbody></table><h3 id="虚拟局域网使用的以太网帧格式"><a href="#虚拟局域网使用的以太网帧格式" class="headerlink" title="虚拟局域网使用的以太网帧格式"></a>虚拟局域网使用的以太网帧格式</h3><p>IEEE 批准了 802.3ac 标准，该标准定义了以太网的帧格式的扩展，以支持虚拟局域网。</p><p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记 (tag)，用来指明该帧属于哪一个虚拟局域网。插入VLAN标记得出的帧称为 802.1Q 帧或带标记的以太网帧。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175642834.png" alt="image-20210413175642834"></p><p>传送过程图示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413175721413.png" alt="image-20210413175721413"></p><h1 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h1><h2 id="100BASE-T-以太网"><a href="#100BASE-T-以太网" class="headerlink" title="100BASE-T 以太网"></a>100BASE-T 以太网</h2><p><strong>速率达到或超过 100 Mbit/s 的以太网称为高速以太网。</strong></p><p>100BASE-T 在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802.3 的 CSMA/CD 协议。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。1995 年IEEE已把 100BASE-T 的快速以太网定为正式标准，其代号为 IEEE 802.3u。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>可在全双工方式下工作而无冲突发生。<strong>在全双工方式下工作时，不使用 CSMA/CD 协议</strong>。</li><li><strong>MAC 帧格式仍然是 802.3 标准规定的。</strong></li><li><strong>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 米。</strong></li><li>帧间时间间隔从原来的 9.6μs 改为现在的 0.96μs 。 </li></ul><h3 id="100-Mbit-s-以太网的三种不同的物理层标准"><a href="#100-Mbit-s-以太网的三种不同的物理层标准" class="headerlink" title="100 Mbit/s 以太网的三种不同的物理层标准"></a>100 Mbit/s 以太网的三种不同的物理层标准</h3><ul><li>100BASE-TX<ol><li>使用 2 对 UTP 5 类线 或 屏蔽双绞线 STP。</li><li>网段最大程度：100 米。</li></ol></li><li>100BASE-T4<ol><li>使用 4 对 UTP 3 类线 或 5 类线。 </li><li>网段最大程度：100 米。</li></ol></li><li>100BASE-FX <ol><li>使用 2 对光纤。 </li><li>网段最大程度：2000 米。</li></ol></li></ul><h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><p>允许在 1 Gbit/s 下以全双工和半双工两种方式工作。使用 IEEE 802.3 协议规定的帧格式。<strong>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</strong>与 10BASE-T 和 100BASE-T 技术向后兼容。</p><blockquote><p>吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中。</p></blockquote><p><strong>使用两种成熟的技术：</strong>一种来自现有的以太网，另一种则是美国国家标准协会 ANSI 制定的光纤通道 FC  (Fiber Channel)。</p><table><thead><tr><th>名称</th><th>媒体</th><th>网段最大长度</th><th>特点</th></tr></thead><tbody><tr><td>1000BASE-SX</td><td>光缆</td><td>550  m</td><td>多模光纤（50 和 62.5  mm）</td></tr><tr><td>1000BASE-LX</td><td>光缆</td><td>5000  m</td><td>单模光纤（10 mm）多模光纤（50 和 62.5  mm）</td></tr><tr><td>1000BASE-CX</td><td>铜缆</td><td>25  m</td><td>使用 2  对屏蔽双绞线电缆  STP</td></tr><tr><td>1000BASE-T</td><td>铜缆</td><td>100  m</td><td>使用 4  对  UTP 5 类线</td></tr></tbody></table><h3 id="半双工方式工作的吉比特以太网"><a href="#半双工方式工作的吉比特以太网" class="headerlink" title="半双工方式工作的吉比特以太网"></a>半双工方式工作的吉比特以太网</h3><p>吉比特以太网工作在半双工方式时，就必须进行碰撞检测。为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：</p><ol><li><strong>载波延伸 (carrier extension)</strong></li><li><strong>分组突发 (packet bursting)</strong></li></ol><h3 id="载波延伸"><a href="#载波延伸" class="headerlink" title="载波延伸"></a>载波延伸</h3><p>使最短帧长仍为 64 字节（这样可以保持兼容性），<strong>同时将争用时间增大为 512 字节</strong>。</p><p>凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到 512 字节。接收端在收到以太网的 MAC 帧后，要将所填充的特殊字符删除后才向高层交付。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413195200135.png" alt="image-20210413195200135"></p><h3 id="分组突发"><a href="#分组突发" class="headerlink" title="分组突发"></a>分组突发</h3><p>当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到 1500 字节或稍多一些为止。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20210413195224917.png" alt="image-20210413195224917"></p><h3 id="全双工方式工作的吉比特以太网"><a href="#全双工方式工作的吉比特以太网" class="headerlink" title="全双工方式工作的吉比特以太网"></a>全双工方式工作的吉比特以太网</h3><p>当吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），<strong>不使用载波延伸和分组突发。</strong></p><h2 id="10-吉比特以太网-10GE-和更快的以太网"><a href="#10-吉比特以太网-10GE-和更快的以太网" class="headerlink" title="10 吉比特以太网 (10GE) 和更快的以太网"></a>10 吉比特以太网 (10GE) 和更快的以太网</h2><p>10 吉比特以太网（10GE）并非把吉比特以太网的速率简单地提高到 10 倍，其主要特点有：</p><ol><li>与 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 以太网的帧格式完全相同。</li><li>保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。<br>不再使用铜线而只使用光纤作为传输媒体。</li><li><strong>只工作在全双工方式，因此没有争用问题，也不使用 CSMA/CD 协议。</strong> </li></ol><p><strong>10GE 的物理层标准</strong></p><table><thead><tr><th align="center">名称</th><th align="center">媒体</th><th align="center">网段最大长度</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">10GBASE-SR</td><td align="center">光缆</td><td align="center">300  m</td><td align="center">多模光纤（0.85 mm）</td></tr><tr><td align="center">10GBASE-LR</td><td align="center">光缆</td><td align="center">10  km</td><td align="center">单模光纤（1.3 mm）</td></tr><tr><td align="center">10GBASE-ER</td><td align="center">光缆</td><td align="center">40  km</td><td align="center">单模光纤（1.5 mm）</td></tr><tr><td align="center">10GBASE-CX4</td><td align="center">铜缆</td><td align="center">15  m</td><td align="center">使用 4  对双芯同轴电缆  (twinax)</td></tr><tr><td align="center">10GBASE-T</td><td align="center">铜缆</td><td align="center">100  m</td><td align="center">使用 4  对  6A 类 UTP  双绞线</td></tr></tbody></table><h2 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h2><p>以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了<strong>端到端的以太网传输</strong>。</p><p>这种工作方式的好处有： </p><ol><li>技术成熟；</li><li>互操作性很好；</li><li>在广域网中使用以太网时价格便宜；</li><li>采用统一的以太网帧格式，简化了操作和管理。 </li></ol><h2 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h2><p>IEEE 在 2001 年初成立了 802.3 EFM 工作组，专门研究高速以太网的宽带接入技术问题。</p><p>以太网宽带接入具有以下<strong>特点</strong>：</p><ol><li>可以提供<strong>双向</strong>的宽带通信。</li><li>可以根据用户对带宽的需求灵活地进行带宽升级。</li><li>可以实现端到端的以太网传输，中间<strong>不需要再进行帧格式的转换</strong>。这就提高了数据的传输效率且降低了传输的成本。</li><li><strong>但是不支持用户身份鉴别</strong>。</li></ol><h2 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h2><blockquote><p><strong>PPPoE (PPP over Ethernet)</strong> 的意思是<strong>“在以太网上运行 PPP</strong>”，它把 PPP 协议与以太网协议结合起来 —— 将 PPP 帧再封装到以太网中来传输。</p></blockquote><p>现在的光纤宽带接入 FTTx 都要使用 PPPoE 的方式进行接入。在 PPPoE 弹出的窗口中键入在网络运营商购买的用户名和密码，就可以进行宽带上网了。</p><p>利用 ADSL 进行宽带上网时，从用户个人电脑到家中的 ADSL 调制解调器之间，也是使用 RJ-45 和 5 类线（即以太网使用的网线）进行连接的，并且也是使用 PPPoE 弹出的窗口进行拨号连接的。</p>]]></content>
    
    <summary type="html">
    
      来呀客官，来看看数据链路层
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://dong-666.github.io/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://dong-666.github.io/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2021-04-18T07:31:14.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图</p></blockquote><p>主要讲了计算机网络五大层结构，后面有时间会补上<strong>网络安全</strong>、<strong>互联网上的音频/视频服务</strong>以及<strong>无线网络和移动网络</strong>，以下先讲讲计算机网络的概述，通过对计算机网络各个名词的学习和体系结构的初步认识，从而增加对后面学习的理解，之后会通过思维导图导入各层学习</p><h1 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h1><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>先放出一张图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102236857.png" alt="image-20210418102236857"></p><h2 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h2><blockquote><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)。</p></blockquote><p>端系统在功能上可能有很大的差别：</p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102356227.png" alt="image-20210418102356227"></p><p>然后，端之间通信（比如主机A和主机B进行通信）实际上是指：<strong>“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。</strong>这个相关内容可以通过运输层和应用层了解</p><p>端系统之间的通信方式通常可划分为两大类：</p><blockquote><p>客户-服务器方式（C/S方式）<br>即 Client/Server 方式，简称为 C/S 方式。 </p></blockquote><blockquote><p>对等方式（P2P方式）<br>即 Peer-to-Peer 方式 ，简称为 P2P 方式。</p></blockquote><h3 id="客户-服务器方式"><a href="#客户-服务器方式" class="headerlink" title="客户-服务器方式"></a>客户-服务器方式</h3><p><strong>客户</strong> (client) 和<strong>服务器</strong> (server) 都是指通信中所涉及的两个应用进程。</p><p>客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户是<strong>服务的请求方</strong>，服务器是<strong>服务的提供方</strong>。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418102656794.png" alt="image-20210418102656794"></p><blockquote><p>客户软件：被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，<strong>客户程序必须知道服务器程序的地址</strong>。</p><p>不需要特殊的硬件和很复杂的操作系统。 </p></blockquote><blockquote><p>服务器软件：一种专门用来提供某种服务的程序，可<strong>同时处理多个远地或本地客户的请求</strong>。</p><p><strong>系统启动后即自动调用并一直不断地运行着</strong>，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</p><p>一般需要强大的硬件和高级的操作系统支持。</p></blockquote><p>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</p><p>相关详细内容可以通过运输层和应用层阅读到，当然前三层涉及到的知识也很重要</p><h3 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h3><p><strong>对等连接 (peer-to-peer，简写为 P2P )</strong> 是指两个主机<strong>在通信时并不区分哪一个是服务请求方还是服务提供方</strong>。</p><p>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</p><p>双方都可以下载对方已经存储在硬盘中的共享文档。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418103029567.png" alt="image-20210418103029567"></p><p>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p><h2 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h2><p>网络核心部分是互联网中最复杂的部分。网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p><strong>在网络核心部分起特殊作用的是路由器 (router)。</strong>路由器是实现<strong>分组交换 (packet switching)</strong> 的关键构件，其任务是转发收到的分组，这是网络核心部分<strong>最重要的功能</strong>。（所以网络层那一章的知识很重要）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418103325964.png" alt="image-20210418103325964"></p><p><strong>典型交换技术包括：</strong></p><ol><li>电路交换</li><li>分组交换</li><li>报文交换等</li></ol><p><strong>互联网的核心部分采用了分组交换技术。</strong></p><p>下面简述各交换技术的特点</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>首先，如果我们需要两个电话能进行通信，比较简单，在两者之间连接一条电话线即可实现。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104110956.png" alt="image-20210418104110956"></p><p>现在，问题复杂了，如果五个电话都想要可以互相通信（两两连接）呢</p><p>那么它们之间就需要十对电话线</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104252231.png" alt="image-20210418104252231"></p><p>由此我们可以得出：N 部电话机两两直接相连，需 N(N –1)/2 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（N 2）成正比。这个数量随着电话的增加会出现疯狂的增长，所需要的电话线会非常多，这时，如果通过<strong>交换机</strong>我们就可以实现全网的交换任务了，同时减少了彼此之间的电话线，转由交换机统一管理</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104547321.png" alt="image-20210418104547321"></p><p>每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。 <strong>所采用的交换方式就是电路交换 (circuit switching)。</strong></p><p>什么是交换：<strong>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源</strong></p><p>电路交换必定是面向连接的。 </p><p>电路交换分为三个阶段：</p><ol><li><strong>建立连接：</strong>建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；</li><li><strong>通信：</strong>主叫和被叫双方就能互相通电话；</li><li><strong>释放连接：</strong>释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。</li></ol><p>面向连接的电路交换会有什么样的问题：<strong>电路交换的用户始终占用端到端的通信资源</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104805420.png" alt="image-20210418104805420"></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换则采用<strong>存储转发</strong>技术。</p><p>在发送端，先把较长的报文<strong>划分成较短的、固定长度的数据段。</strong> </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418104932663.png" alt="image-20210418104932663"></p><p>首先在每一个数据段前面添加上首部构成分组 (packet)。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.gif" alt="分组交换"></p><p>分组交换网以“分组”作为数据传输单元。依次把各分组发送到接收端（假定接收端在左边）。</p><p>然后，接收端收到分组后剥去首部还原成报文。</p><p>最后，在接收端把收到的数据恢复成为原来的报文。</p><p>这一交换的过程需要有一个前提：这里我们假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。</p><p><strong>分组交换的传输单元</strong></p><p>每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418134245270.png" alt="image-20210418134245270"></p><p>数据传输过程中，负责转发分组的便是<strong>路由器</strong></p><p>在路由器中的输入和输出端口之间没有直接连线。<br>路由器处理分组的过程是：</p><ol><li>把收到的分组先放入缓存（暂时存储）；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口转发出去。</li></ol><p>注意：主机和路由器并不相同，主机是<strong>为用户进行信息处理</strong>的，并向网络发送分组，从网络接收分组。路由器<strong>对分组进行存储转发</strong>，最后把分组交付目的主机。学到后面，你会发现它们之间更多的区别</p><p>那么，分组转发有什么优点呢</p><table><thead><tr><th>优点</th><th>所采用的手段</th></tr></thead><tbody><tr><td><strong>高效</strong></td><td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</td></tr><tr><td><strong>灵活</strong></td><td>为每一个分组独立地选择最合适的转发路由。</td></tr><tr><td><strong>迅速</strong></td><td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。</td></tr><tr><td><strong>可靠</strong></td><td>保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</td></tr></tbody></table><p>当然他也存在一定缺点</p><p>分组在各结点存储转发时需要排队，这就会造成一定的<strong>时延</strong>。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 </p><p>最后，用一张图表示它们的区别</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418134753955.png" alt="image-20210418134753955"></p><p>三种交换的比较</p><ul><li>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</li><li>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率</li><li>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ul><h1 id="不同类别的网络"><a href="#不同类别的网络" class="headerlink" title="不同类别的网络"></a>不同类别的网络</h1><h2 id="按照网络的作用范围进行分类"><a href="#按照网络的作用范围进行分类" class="headerlink" title="按照网络的作用范围进行分类"></a>按照网络的作用范围进行分类</h2><ul><li><strong>广域网 WAN (Wide Area Network)</strong>：作用范围通常为几十到几千公里。</li><li><strong>城域网 MAN (Metropolitan Area Network)</strong>：作用距离约为 5~50 公里。</li><li><strong>局域网 LAN (Local Area Network)</strong> ：局限在较小的范围（如 1 公里左右）。</li><li><strong>个人区域网 PAN (Personal Area Network)</strong> ：范围很小，大约在 10 米左右。</li></ul><blockquote><p>若中央处理机之间的距离非常近（如仅 1 米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络。 </p></blockquote><h2 id="按照网络的使用者进行分类"><a href="#按照网络的使用者进行分类" class="headerlink" title="按照网络的使用者进行分类"></a>按照网络的使用者进行分类</h2><ul><li>公用网 (public network)<br>按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</li><li>专用网 (private network)<br>为特殊业务工作的需要而建造的网络。</li></ul><p>公用网和专用网都可以提供多种服务。如传送的是计算机数据，则分别是公用计算机网络和专用计算机网络。</p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><p>计算机网络的性能一般是指它的几个重要的性能指标，主要包括：</p><ul><li>速率</li><li>带宽</li><li>吞吐率</li><li>时延</li><li>时延带宽积</li><li>往返时间 RTT</li><li>利用率</li></ul><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>在了解速率之前，首先了解数据的单位——比特</p><blockquote><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p></blockquote><p><strong>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。</strong></p><p>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s等。</p><p>例如4 * 10¹⁰  bit/s 的数据率就记为 40 Gbit/s。</p><p><strong>速率往往是指额定速率或标称速率，非实际运行速率（受带宽影响）。</strong>  </p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>两种不同意义：</p><ul><li><strong>“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。</strong></li><li>在计算机网络中，带宽用来表示网络中<strong>某通道传送数据的能力</strong>。表示在单位时间内网络中的<strong>某信道所能通过的“最高数据率”</strong>。单位是 bit/s，即 “比特每秒”。    </li></ul><p>自己的理解：类似于高速公路和普通公路吧，车道（高速公路至少为六车道）越多，也就是公路越宽，单位时间内通过的容量越大，而普通公路，一般为二车道，宽度容量相较于高速公路就会小些</p><p>在“带宽”的上述两种表述中，前者为<strong>频域称谓</strong>，而后者为<strong>时域称谓</strong>，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><p>速率和带宽的区别便是：速率有关于物理媒介，也就是物理层，而带宽会收到五层协议栈的影响，比如你买的100M电信宽带，然后接入了10M的以太网网线，那么宽带就是指你的带宽，而以太网网线则是指速率。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><strong>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</strong></p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p><strong>吞吐量受网络的带宽或网络的额定速率的限制。</strong>  </p><p>又来自己的理解了，拿前面的例子，六车道高速公路代表着，每单位时间最多只能同时通过六辆车，这相当于是带宽等于6，但不可能每时每刻都那么巧同时有六辆车通过的，可能是一辆、两辆、或者三辆等，那么，这个时候通过的车辆数就是吞吐量</p><p>简单来说，吞吐量便是实际速率，而带宽就是额定速率</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的<strong>一端传送到另一端所需的时间</strong>。</p><p>有时也称为<strong>延迟</strong>或迟延。</p><p>网络中的时延由以下4个不同的部分组成：</p><ol><li><p>发送时延</p><p>发送时延也称为传输时延。发送数据时，数据帧从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142506439.png" alt="image-20210418142506439"></p></li><li><p>传播时延</p><p>电磁波在信道中需要传播一定的距离而花费的时间。 发送时延与传播时延有本质上的不同。信号发送速率和信号在信道上的传播速率是完全不同的概念。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142558278.png" alt="image-20210418142558278"></p></li><li><p>处理时延</p><p>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 </p></li><li><p>排队时延</p><p>分组在路由器输入输出队列中排队等待处理所经历的时延。<strong>排队时延的长短往往取决于网络中当时的通信量。</strong></p></li></ol><p>最后，数据在网络中经历的<strong>总时延</strong>就是发送时延、传播时延、处理时延和排队时延之和。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142718090.png" alt="image-20210418142718090"></p><p>需要重点注意到饿是：对于高速网络链路，我们<strong>提高的仅仅是数据的发送速率</strong>而不是比特在链路上的传播速率。 提高链路带宽减小了数据的发送时延。 </p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>链路的时延带宽积又称为以比特为单位的链路长度。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418142919756.png" alt="image-20210418142919756"></p><p>只有在代表链路的管道都充满比特时，链路才得到了充分利用。</p><blockquote><p>时延带宽积 = 传播时延 × 带宽</p></blockquote><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。</p><p>往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。(运输层会详细聊到这个)</p><p>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</p><p><strong>当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。</strong></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>分为信道利用率和网络利用率。</p><ol><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ol><p><strong>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</strong></p><p>我们知道，时延和信道上数据传播速率有关，假设速率不变的情况下，时延又分为四种，当你利用率提高的同时，其中的一种——排队时延就会相应的变长，那么总的时延就会增加</p><p>若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0 之间的关系： </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418143620011.png" alt="image-20210418143620011"></p><p>其中：U 是网络的利用率，数值在 0 到 1 之间。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418143637381.png" alt="image-20210418143637381"></p><h1 id="非性能特征"><a href="#非性能特征" class="headerlink" title="非性能特征"></a>非性能特征</h1><p>当然，一些非性能特征也很重要。它们与前面介绍的性能指标有很大的关系。主要包括：</p><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性 </li><li>易于管理和维护 </li></ul><h1 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>计算机网络中的数据交换<strong>必须遵守事先约定好的规则</strong>。 </p><p>这些<strong>规则</strong>明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。</p><p><strong>网络协议</strong> (network protocol)，简称为<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准或约定。</p><h3 id="网络协议的三个组成要素"><a href="#网络协议的三个组成要素" class="headerlink" title="网络协议的三个组成要素*"></a>网络协议的三个组成要素*</h3><p><strong>语法</strong>：数据与控制信息的结构或格式 。 </p><p><strong>语义：</strong>需要发出何种控制信息，完成何种动作以及做出何种响应。 </p><p><strong>同步</strong>：事件实现顺序的详细说明。 </p><h3 id="协议具有两种形式"><a href="#协议具有两种形式" class="headerlink" title="协议具有两种形式"></a>协议具有两种形式</h3><p>一种是使用便于人来阅读和理解的文字描述。</p><p>另一种是使用让计算机能够理解的程序代码。</p><p>这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。</p><h2 id="划分层次"><a href="#划分层次" class="headerlink" title="划分层次"></a>划分层次</h2><p>划分层次的优点，以及它的缺点</p><p>优点</p><ul><li>各层之间是独立的。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现和维护。</li><li>能促进标准化工作。  </li></ul><p>缺点</p><ul><li>降低效率。</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销。</li></ul><p>而层数也要适合，如果层数太少，就会使每一层的协议太复杂。层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难。 </p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><p>计算机网络的体系结构 (architecture) 是计算机网络的各层及其协议的集合。 </p><p>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。<br>实现 (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。</p><p><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</strong></p><p><strong>OSI</strong> 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p><p><strong>TCP/IP</strong> 是四层体系结构：应用层、运输层、网际层和网络接口层。<br>但最下面的网络接口层并没有具体内容。</p><p>因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418145642533.png" alt="image-20210418145642533"></p><p>在五层协议下，数据是这样传递的</p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/数据传递.jpg" alt="数据传递"><p>图里省略了到达通信接收方数据的处理方法，具体做法便是在每一层将数据对等层的首部和尾部<strong>剥去</strong>后再传递给上一层</p><p><strong>OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。</strong>这个名词现已被许多非 OSI 标准采用。</p><p>任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。</p><p>各层协议实际上就是在各个对等层之间传递数据时的各项规定。</p><h2 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h2><p><strong>实体 (entity)</strong> 表示任何可发送或接收信息的硬件或软件进程。 </p><p><strong>协议</strong>是控制<strong>两个对等实体</strong>进行通信的规则的集合。 </p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层<strong>提供服务</strong>。</p><p>要实现本层协议，还需要使用下层所提供的服务。 </p><p>协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。 协议是“水平的”，即协议是控制对等实体之间通信的规则。服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。上层使用服务原语获得下层所提供的服务。</p><p>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点 SAP</strong> (Service Access Point)。 服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口。OSI把层与层之间交换的数据的单位称为<strong>服务数据单元 SDU</strong> (Service Data Unit)。SDU 可以与 PDU 不一样，例如，可以是多个 SDU 合成为一个 PDU，也可以是一个 SDU 划分为几个 PDU。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418150946900.png" alt="image-20210418150946900"></p><p>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，还必须非常仔细地检查这个协议能否应付各种异常情况。 </p><h1 id="TCP-IP-的体系结构"><a href="#TCP-IP-的体系结构" class="headerlink" title="TCP/IP 的体系结构"></a>TCP/IP 的体系结构</h1><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151028155.png" alt="image-20210418151028155"></p><p>实际上，现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151050239.png" alt="image-20210418151050239"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151123598.png" alt="image-20210418151123598"></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151137382.png" alt="image-20210418151137382"></p><p>客户进程和服务器进程使用 TCP/IP 协议栈进行通信</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151152180.png" alt="image-20210418151152180"></p><p>功能较强的计算机可同时运行多个服务器进程 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-20210418151236957.png" alt="image-20210418151236957"></p>]]></content>
    
    <summary type="html">
    
      内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
