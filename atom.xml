<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dong</title>
  
  <subtitle>y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dong-666.github.io/"/>
  <updated>2022-04-17T12:33:24.157Z</updated>
  <id>http://dong-666.github.io/</id>
  
  <author>
    <name>天际线上的猪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm操作</title>
    <link href="http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/"/>
    <id>http://dong-666.github.io/2022/04/18/NPM%20%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-18T07:00:00.000Z</published>
    <updated>2022-04-17T12:33:24.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm操作"><a href="#npm操作" class="headerlink" title="npm操作"></a>npm操作</h1><p>查看全局安装的npm包： <code>npm list -g -dept 0</code></p><p>解决因node版本过高而引起的依赖安装失败报错问题：<code>npm i --legacy-peer-deps</code> </p><p>清除缓存：<code>npm cache clean</code></p><p>（待补充…）</p>]]></content>
    
    <summary type="html">
    
      记录一些npm操作
    
    </summary>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="http://Dong-666.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>node登陆验证之jsonwebtoken</title>
    <link href="http://dong-666.github.io/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/"/>
    <id>http://dong-666.github.io/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/</id>
    <published>2022-04-15T13:40:39.000Z</published>
    <updated>2022-04-17T15:13:11.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用jsonwebtoken进行node端登陆注册验证"><a href="#使用jsonwebtoken进行node端登陆注册验证" class="headerlink" title="使用jsonwebtoken进行node端登陆注册验证"></a>使用jsonwebtoken进行node端登陆注册验证</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>简介</strong>：Token在计算机身份认证中是<a href="https://baike.baidu.com/item/令牌/9716092" target="_blank" rel="noopener">令牌</a>（临时）的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。</p><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌（<a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html" target="_blank" rel="noopener">参考资料</a>）</p></blockquote><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>token解决的问题如下</p><ol><li>Token 完全由应用管理，所以它可以避开同源策略</li><li>Token 可以避免 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cnblogs.com%2Fshanyou%2Fp%2F5038794.html" target="_blank" rel="noopener">CSRF 攻击</a>（又引出一个知识点，推荐<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">文章</a>，<strong>前端知识真是如同太平洋广，如同马里亚纳海沟深</strong>）</li><li>Token 可以是无状态的，可以在多个服务间共享</li></ol><h3 id="其它（cookie、session、token）"><a href="#其它（cookie、session、token）" class="headerlink" title="其它（cookie、session、token）"></a>其它（cookie、session、token）</h3><p>本实验主要采用token进行前后端验证，但是同时也有必要了解其他验证方式的原理，推荐看看下面的文章</p><blockquote><p>博客链接：<a href="https://juejin.cn/post/6898630134530752520" target="_blank" rel="noopener">🔺🔺🔺前端鉴权的兄弟们：cookie、session、token、jwt、单点登录 - 掘金 (juejin.cn)</a>，通过该博客，你可了解到</p><ol><li>基于 HTTP 的前端鉴权背景</li><li>cookie 为什么是最方便的存储方案，有哪些操作 cookie 的方式</li><li>session 方案是如何实现的，存在哪些问题</li><li>token 方案是如何实现的，如何进行编码和防篡改？jwt 是做什么的？refresh token 的实现和意义</li><li>session 和 token 有什么异同和优缺点</li><li>单点登录是什么？实现思路和在浏览器下的处理</li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>参考视频（强烈建议看，逻辑清晰，几乎不带一句废话，虽然有点长）:<a href="https://www.bilibili.com/video/BV1Nb411j7AC?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">1小时搞定NodeJs(Express)的用户注册、登录和授权_哔哩哔哩_bilibili🔺🔺🔺</a></p><p>步骤（该案例模拟的用户名为唯一值unique）</p><ol><li><p>相关模块以及初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">//expree服务器</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>); <span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>); <span class="comment">//token</span></span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./User.js'</span>); <span class="comment">//用户模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">// 定义密钥进行token加密，也可通过openssl进行私钥公钥配对,后面有解释</span></span><br><span class="line"><span class="keyword">let</span> SECRET = <span class="string">'dongyuan666'</span>;</span><br><span class="line"><span class="comment">// 接收前端传递的json数据</span></span><br><span class="line">app.use(express.json());</span><br></pre></td></tr></table></figure></li><li><p>用户名唯一，密码加密(User模块)</p><ul><li>bcrypt模块 -&gt; set函数 -&gt; <code>bcrypt.hashSync(val, number)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    unique: <span class="literal">true</span> <span class="comment">//唯一值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">set</span>: (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> bcrypt.hashSync(val, <span class="number">10</span>) <span class="comment">//加密</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>User完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>)</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test-token'</span>, &#123;</span><br><span class="line">  useNewUrlParser: <span class="literal">true</span>,</span><br><span class="line">  useCreateIndex: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    unique: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">set</span>: (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> bcrypt.hashSync(val, <span class="number">10</span>) <span class="comment">//加密</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'User'</span>, UserSchema)</span><br></pre></td></tr></table></figure></li><li><p>处理用户注册</p><ol><li>判断当前用户是否已被注册：<code>User.find({ username: req.body.username,})</code></li><li>写入数据库：<code>User.create({username: req.body.username,password: req.body.password,})</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/register'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log(req.body);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> users = <span class="keyword">await</span> User.find(&#123;</span><br><span class="line">    username: req.body.username,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (users.length != <span class="number">0</span>) <span class="keyword">return</span> res.end(<span class="string">'该用户已注册'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">    username: req.body.username,</span><br><span class="line">    password: req.body.password,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.end(<span class="string">'注册成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理用户登录</p><ol><li>判断数据库是否有当前用户：<code>User.findOne({ username: body.username })</code></li><li>判断密码是否正确：<code>bcrypt.compareSync(body.password, user.password);</code></li><li>生成token：<code>jwt.sign({id}, SECRET, {options})</code><ul><li>定义SECRET：<code>let SECRET = &#39;自定义密钥内容&#39;;</code></li></ul></li><li>发送token</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> SECRET = <span class="string">'自定义密钥内容'</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.判断用户是否存在</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123; <span class="attr">username</span>: body.username &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.status(<span class="number">422</span>).json(&#123; <span class="attr">errorCode</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'用户不存在'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户存在</span></span><br><span class="line">  <span class="comment">// 2.密码校验</span></span><br><span class="line">  <span class="keyword">let</span> isPasswordValid = bcrypt.compareSync(body.password, user.password);</span><br><span class="line">  <span class="keyword">if</span> (!isPasswordValid) <span class="keyword">return</span> res.status(<span class="number">422</span>).json(&#123; <span class="attr">errorCode</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">'密码错误'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.生成token</span></span><br><span class="line">  <span class="keyword">let</span> token = jwt.sign(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="built_in">String</span>(user.id) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    SECRET, <span class="comment">//密钥</span></span><br><span class="line">    &#123;</span><br><span class="line">      expiresIn: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br><span class="line">  res.send(token);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理用户验证</p><ol><li>获取token：<code>req.headers.authorization</code></li><li>解析token：<code>jwt.verify(raw, SECRET)</code></li><li>查找用户：<code>User.findById(id)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/profile'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="built_in">String</span>(req.headers.authorization).split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.verify(raw, SECRET).id;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">  res.send(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>将token验证过程拆解成中间件，并进行验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="built_in">String</span>(req.headers.authorization).split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.verify(raw, SECRET).id;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  req.user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/market'</span>, auth, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(req.user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>); <span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>); <span class="comment">//token</span></span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./User.js'</span>); <span class="comment">//用户模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">// 定义密钥，也可通过openssl进行私钥公钥配对</span></span><br><span class="line"><span class="keyword">let</span> SECRET = <span class="string">'dongyuan666'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收前端传递的json数据</span></span><br><span class="line">app.use(express.json());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.query);</span><br><span class="line">  res.send(<span class="string">'Ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/register'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log(req.body);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> users = <span class="keyword">await</span> User.find(&#123;</span><br><span class="line">    username: req.body.username,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (users.length != <span class="number">0</span>) <span class="keyword">return</span> res.end(<span class="string">'该用户已注册'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">    username: req.body.username,</span><br><span class="line">    password: req.body.password,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.end(<span class="string">'注册成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.判断用户是否存在</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123; <span class="attr">username</span>: body.username &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.status(<span class="number">422</span>).json(&#123; <span class="attr">errorCode</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'用户不存在'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户存在</span></span><br><span class="line">  <span class="comment">// 2.密码校验</span></span><br><span class="line">  <span class="keyword">let</span> isPasswordValid = bcrypt.compareSync(body.password, user.password);</span><br><span class="line">  <span class="keyword">if</span> (!isPasswordValid) <span class="keyword">return</span> res.status(<span class="number">422</span>).json(&#123; <span class="attr">errorCode</span>: <span class="number">2</span>, <span class="attr">message</span>: <span class="string">'密码错误'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.生成token</span></span><br><span class="line">  <span class="keyword">let</span> token = jwt.sign(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="built_in">String</span>(user.id) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    SECRET, <span class="comment">//密钥</span></span><br><span class="line">    &#123;</span><br><span class="line">      expiresIn: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br><span class="line">  res.send(token);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/profile'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// return res.send(String(req.headers.authorization).split(' '))</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> raw = <span class="built_in">String</span>(req.headers.authorization).split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> id = jwt.verify(raw, SECRET).id;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">  res.send(user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">let</span> raw = <span class="built_in">String</span>(req.headers.authorization).split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 解析token并获取id</span></span><br><span class="line">  <span class="keyword">let</span> id = jwt.verify(raw, SECRET).id;</span><br><span class="line">  <span class="comment">// 查找用户</span></span><br><span class="line">  req.user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/market'</span>, auth, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(req.user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="🔺非对称加密"><a href="#🔺非对称加密" class="headerlink" title="🔺非对称加密"></a>🔺非对称加密</h3><p><a href="https://juejin.cn/post/7062173044214595597#heading-9" target="_blank" rel="noopener">在Node.Js中使用JWT实现Token用户验证🔺🔺🔺</a> or <a href="https://www.jianshu.com/p/48462fb34a8a" target="_blank" rel="noopener">node token验证</a></p><blockquote><p>非对称加密：RS256</p><p>私钥（private key）：用于发布令牌</p><p>公钥（public key）：用于验证令牌</p></blockquote><p>非对称加密步骤</p><ol><li><p>使用openssl生成公钥私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl</span><br><span class="line">OpenSSL&gt; genrsa -out private.key 1024</span><br><span class="line">OpenSSL&gt; rsa -<span class="keyword">in</span> private.key -pubout -out public.key</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2022/04/15/node-token%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81/image-20220328102415279.png" alt="image-20220328102415279"></p></li><li><p>新建一个文件用于读取密钥并导出（config.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PRIVATE_KEY = fs.readFileSync(path.resolve(__dirname, <span class="string">'./keys/private.key'</span>));</span><br><span class="line"><span class="keyword">const</span> PUBLIC_KEY = fs.readFileSync(path.resolve(__dirname, <span class="string">'./keys/public.key'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.PRIVATE_KEY = PRIVATE_KEY;</span><br><span class="line"><span class="built_in">module</span>.exports.PUBLIC_KEY = PUBLIC_KEY;</span><br></pre></td></tr></table></figure></li><li><p>导入密钥（app.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; PRIVATE_KEY, PUBLIC_KEY &#125; = <span class="built_in">require</span>(<span class="string">'./config.js'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用私钥进行加密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token = jwt.sign(</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="built_in">String</span>(user.id) &#125;, <span class="comment">//密码不要放进来，放一个唯一的东西就可以了</span></span><br><span class="line">    PRIVATE_KEY, <span class="comment">//私钥加密</span></span><br><span class="line">    &#123;</span><br><span class="line">      expiresIn: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>, <span class="comment">//24h后失效</span></span><br><span class="line">      algorithm: <span class="string">'RS256'</span>, <span class="comment">//非对称加密</span></span><br><span class="line">    &#125; <span class="comment">//配置项</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li><li><p>使用公钥进行解密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jwt.verify(raw, PUBLIC_KEY, &#123; <span class="attr">algorithms</span>: [<span class="string">'RS256'</span>] &#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Token安全之道"><a href="#Token安全之道" class="headerlink" title="Token安全之道"></a>Token安全之道</h2><p>建议阅读：<a href="https://segmentfault.com/q/1010000021515464" target="_blank" rel="noopener">token拷贝到别人电脑上，禁止授权</a>🔺</p><p>简短：</p><ol><li><a href="http://www.sankedan.com/detail/9/2463.html" target="_blank" rel="noopener">关于 token 被盗取的问题</a></li><li><a href="https://blog.csdn.net/weixin_43644324/article/details/87895729" target="_blank" rel="noopener">如果一个用户的 token 被其他用户劫持了，怎样解决这个安全问题</a></li></ol><p>实践：<a href="https://juejin.cn/post/6844903498329358349" target="_blank" rel="noopener">注册、登录和 token 的安全之道</a></p>]]></content>
    
    <summary type="html">
    
      使用jsonwebtoken进行node端登陆注册验证
    
    </summary>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://Dong-666.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据入库</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/</id>
    <published>2022-04-10T07:20:10.000Z</published>
    <updated>2022-04-17T12:49:52.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据入库方式"><a href="#数据入库方式" class="headerlink" title="数据入库方式"></a>数据入库方式</h2><p>打开MongoDB Compass（<a href="https://www.mongodb.com/try/download/compass" target="_blank" rel="noopener">点击此处下载官方安装包</a>）</p><p>下载完解压即可使用</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162053358.png" alt="image-20220211162053358"></p><p>连接数据库，默认一般是这个地址</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162138766.png" alt="image-20220211162138766"></p><p>接着选择你要导入的数据库数据集位置，然后点击ADD DATA→Import file 选项进行数据导入</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211162802872.png" alt="image-20220211162802872"></p><p>然后就可以根据两种不同的数据源格式方式进行导入</p><h3 id="CSV格式导入"><a href="#CSV格式导入" class="headerlink" title="CSV格式导入"></a>CSV格式导入</h3><ol><li><p>选择完csv格式的数据后，在下面的Ignore empty strings选项中根据自己需求进行选择，打勾则是会将空数据忽略，取消勾选则会保留空数据</p></li><li><p>接着在下面的字段名中选择当前字段所属的类型，最好一一确定每个字段类型并选择好，避免后面因数据类型而引起的其他开发问题</p></li><li><p>确定好之后点击INPORT选项即可导入数据了</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163028242.png" alt="image-20220211163028242"></p></li><li><p>导入成功</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163445590.png" alt="image-20220211163445590"></p></li><li><p>最后提醒，一般现在的excel保存后的数据都是xlsx格式的文件类型，这样的文件类型导入后只会出现一堆乱码，所以记得在excel另存为csv类型的文件</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163807052.png" alt="image-20220211163807052"></p></li></ol><h3 id="JSON格式导入"><a href="#JSON格式导入" class="headerlink" title="JSON格式导入"></a>JSON格式导入</h3><ol><li><p>JSON数据比前面的csv数据好导，选择完文件即可导入了，so easy</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211163958511.png" alt="image-20220211163958511"></p></li></ol><h2 id="出库方式"><a href="#出库方式" class="headerlink" title="出库方式"></a>出库方式</h2><p>出库方式非常简单，摸索摸索就出来了</p><p>通过下面的小按钮，然后可以选择根据查询条件导出，也可以选择全部导出，然后点击SELECT FIELDS，选择完想要导出的字段即可导出啦</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211164313741.png" alt="image-20220211164313741"></p><h2 id="控制台导出导入方式（cmd）"><a href="#控制台导出导入方式（cmd）" class="headerlink" title="控制台导出导入方式（cmd）"></a>控制台导出导入方式（cmd）</h2><ol><li><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport -d 数据库名 -c 数据集名 --type 数据类型 --headerline --file 文件名（记得加后缀）</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">mongoimport <span class="literal">-d</span> MZedu <span class="literal">-c</span> MiddleSchool -<span class="literal">-type</span> csv -<span class="literal">-headerline</span> -<span class="operator">-file</span> 梅城中学.csv</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>导出</strong></p><ol><li><p>管理员身份运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h 127.0.0.1 -d 数据库名 -o 保存路径</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport -d 数据库名 -c collections的名字 -o filename.json/filename.csv  -f field</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参数说明：</p><ol><li>-d   数据库名(database)</li><li>-c   collections名</li><li>-o   要存入的文件名(xxx.json/xxx.csv)</li><li>-f   输出特定属性列(一般情况下可以不加这个参数)</li></ol></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>MongoDB最新版（5.0）bin文件夹里面已经没有这两个导出程序了，所以上面的几个命令无法在5.0执行，但在4.2版本，自己试了试是可以的</p></blockquote><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170735586.png" alt="4.2"></p><p>对比可以看到，5.0已经没有该导入导出程序了</p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/image-20220211170800643.png" alt="image-20220211170800643"></p>]]></content>
    
    <summary type="html">
    
      MongoDB数据入库
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Web存储</title>
    <link href="http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/"/>
    <id>http://dong-666.github.io/2022/04/10/web%E5%AD%98%E5%82%A8/</id>
    <published>2022-04-10T07:00:00.000Z</published>
    <updated>2022-04-17T12:30:58.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies - HTTP | MDN (mozilla.org)</a></p><p>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</p><blockquote><p>🔺信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。</p><p>当机器处于不安全环境时，切记<em>不能</em>通过 HTTP Cookie 存储、传输敏感信息。</p></blockquote><p>客户端（浏览器端）可以修改cookie（所以某种意义上来讲它是不安全的，客户端可以随意修改或获取cookie的内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">documont.cookie <span class="comment">//获取</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'abcdefg'</span><span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。推荐阅读：<a href="https://juejin.cn/post/6844903812092674061" target="_blank" rel="noopener">深入了解浏览器存储–从cookie到WebStorage、IndexedDB</a></p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Window.sessionStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p><code>sessionStorage</code> 属性允许你访问一个，对应当前源的 session <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a> 对象。它与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener"><code>localStorage</code></a> 相似，不同之处在于 <code>localStorage</code> 里面存储的数据没有过期时间设置，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</li><li>打开多个相同的 URL 的 Tabs 页面，会创建各自的 <code>sessionStorage</code>。</li><li>关闭对应浏览器标签或窗口，会清除对应的 <code>sessionStorage</code>。 </li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">Window.localStorage - Web API 接口参考 | MDN (mozilla.org)</a></p><p>只读的<code>localStorage</code> 属性允许你访问一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener"><code>Document</code></a> 源（origin）的对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener"><code>sessionStorage</code></a>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除 。</p><p>应注意，无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，<strong>它们都特定于页面的协议。</strong></p><p>另外，<code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>该语法用于设置 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'myCat'</span>, <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于读取 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = localStorage.getItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure><p>该语法用于移除所有的 <code>localStorage</code> 项，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除所有</span></span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>表格转自<a href="https://juejin.cn/post/6844903989096497159" target="_blank" rel="noopener">localStorage、sessionStorage、cookie、session几种web数据存储方式对比总结</a></p><table><thead><tr><th>分类</th><th>生命周期</th><th>存储容量</th><th>存储位置</th></tr></thead><tbody><tr><td>cookie</td><td>默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</td><td>4KB</td><td>保存在客户端，每次请求时都会带上</td></tr><tr><td>localStorage</td><td>理论上永久有效的，除非主动清除。</td><td>4.98MB（不同浏览器情况不同，safari 2.49M）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr><tr><td>sessionStorage</td><td>仅在当前网页会话下有效，关闭页面或浏览器后会被清除。</td><td>4.98MB（部分浏览器没有限制）</td><td>保存在客户端，不与服务端交互。节省网络流量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      吃块cookie？
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB环境配置过程</title>
    <link href="http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>http://dong-666.github.io/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-10T03:15:10.000Z</published>
    <updated>2022-04-17T12:49:54.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB配置过程"><a href="#MongoDB配置过程" class="headerlink" title="MongoDB配置过程"></a>MongoDB配置过程</h1><p>环境变量配置</p><p>右键”计算机”，点击”属性“，下拉选择”高级系统设置“→”环境变量“，在”系统变量“中双击”Path“，在后面添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MongoDB\Server\5.0\bin</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160446805.png" alt="image-20220211160446805"></p><p><img src= "/img/loading.gif" data-src="/2022/04/10/MongoDB%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/image-20220211160738853.png" alt="image-20220211160738853"></p>]]></content>
    
    <summary type="html">
    
      MongoDB配置过程
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://Dong-666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>解决arcgis字段长度限制</title>
    <link href="http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
    <id>http://dong-666.github.io/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/</id>
    <published>2022-03-28T08:00:00.000Z</published>
    <updated>2022-04-17T12:24:21.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决arcgis字段长度限制"><a href="#解决arcgis字段长度限制" class="headerlink" title="解决arcgis字段长度限制"></a>解决arcgis字段长度限制</h1><p>在一般的shp文件<img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092734837.png" alt="image-20220319092734837">下修改文本字段的长度，只要超过255，通常会现实这样一个错误</p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092714321.png" alt="image-20220319092714321"></p><p>解决方法为，新建一个个人地理数据库，再将该shp文件放到该数据库下，重新在该文件下的<code>属性</code>窗口修改文本字段的长度，现在无论你输入多少，都可以修改成功</p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319092544606.png" alt="image-20220319092544606"></p><p><img src= "/img/loading.gif" data-src="/2022/03/28/%E8%A7%A3%E5%86%B3arcgis%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/image-20220319093201270.png" alt="image-20220319093201270"></p>]]></content>
    
    <summary type="html">
    
      如题
    
    </summary>
    
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/categories/ArcGIS/"/>
    
    
      <category term="GIS" scheme="http://Dong-666.github.io/tags/GIS/"/>
    
      <category term="ArcGIS" scheme="http://Dong-666.github.io/tags/ArcGIS/"/>
    
  </entry>
  
  <entry>
    <title>前端知识小汇总</title>
    <link href="http://dong-666.github.io/2022/03/05/study/"/>
    <id>http://dong-666.github.io/2022/03/05/study/</id>
    <published>2022-03-05T09:58:15.000Z</published>
    <updated>2022-03-08T00:38:37.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><p>🔴重点🟠难点🟡性能🟢算法🔵JS高阶🟣框架</p><h2 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h2><ol><li><p>get、post（请求参数长度限制）——HTTP协议</p><ol><li><a href="https://juejin.cn/post/6844903433674178574" target="_blank" rel="noopener">两者区别</a></li><li><a href="https://juejin.cn/post/6992933721703710750" target="_blank" rel="noopener">GET 和 POST</a></li></ol></li><li><p>原型链</p><ol><li><p>gitee -&gt; 原型链代码</p></li><li><p>processOn <a href="https://mp.processon.com/view/link/604b5ac963768958e9989002#map" target="_blank" rel="noopener">思维导图</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211217103257781.png" alt="image-20211217103257781"></p></li></ol></li><li><p>mouseover、mouseenter</p><ol><li><p><a href="https://blog.csdn.net/LPLIFE/article/details/80436623" target="_blank" rel="noopener">文章</a></p></li><li><p>共同点：鼠标移入元素触发事件</p></li><li><p>不同点：</p><ul><li><p>mouseover：若存在子元素，则会冒泡触发多次mouseover事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseover.gif" alt="mouseover"></p></li><li><p>mouseenter：不存在子元素冒泡，也就是鼠标移入只会触发一次mouseenter事件</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/mouseenter.gif" alt="mouseenter"></p></li></ul></li></ol></li><li><p><a href="https://juejin.cn/post/6844904126199889927" target="_blank" rel="noopener">可视区域高度</a></p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/js%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.png" alt></p><p>可视区域就是不包括上下左右的工具栏、状态栏（滚动条特殊）。代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可视区域宽度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="comment">//可视区域高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"><span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><p>document.documentElement也可以为document.body</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平滚动条的位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft</span><br><span class="line"><span class="comment">//垂直滚动条位置</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollRight</span><br></pre></td></tr></table></figure></li><li><p>defer（异步加载js)</p><ol><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ol></li><li><p>防抖节流</p><ol><li><p>防抖（高阶）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, context, param</span>) </span>&#123;</span><br><span class="line">        clearTimeout(method.tId);</span><br><span class="line">        method.tId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          method.apply(context, param);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>防抖（闭包型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> out = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">          clearTimeout(out);</span><br><span class="line">          out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            method.call(that, args);</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>节流（自定义）</p><p><a href="https://juejin.cn/post/6844903669389885453" target="_blank" rel="noopener">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throlle</span>(<span class="params">method, timeout = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out;</span><br><span class="line">  <span class="keyword">let</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; timeout) &#123;</span><br><span class="line">      clearTimeout(out);</span><br><span class="line">      out = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        method(...args);</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      method(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>事件流</p><ol><li><p><a href="https://juejin.cn/post/6844903741783556109" target="_blank" rel="noopener">JS事件流和事件委托</a></p></li><li><p><a href="https://juejin.cn/post/6844903834075021326" target="_blank" rel="noopener">你真的理解 事件冒泡 和 事件捕获</a>吗</p></li><li><p>阻止冒泡,阻止默认事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c 冒泡'</span>);</span><br><span class="line">    e.stopPropagation();<span class="comment">//阻止冒泡</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span><span class="comment">//阻止默认事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身</p></blockquote></li><li><p><a href="https://juejin.cn/post/6844903450493321223" target="_blank" rel="noopener">javascript 事件流</a></p></li></ol></li><li><p>JS拖拽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖动开始--&gt;拖动过程中--&gt;拖动结束</span></span><br><span class="line"><span class="comment">// 监听目标DOM的onmousedown事件→document的onmousemove→document的onmouseup</span></span><br><span class="line"><span class="comment">//记录旧坐标鼠标移动后记录下新坐标,通过新坐标减去旧坐标得出变化的坐标,然后改变其位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldX, oldY, newX, newY; <span class="comment">//存储新旧鼠标位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 元素点击事件</span></span><br><span class="line">  ele.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    oldX = e.clientX; <span class="comment">//存储鼠标当前位置(初始化位置)</span></span><br><span class="line">    oldY = e.clientY;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.style.left &amp;&amp; !<span class="keyword">this</span>.style.top) &#123;</span><br><span class="line">      <span class="comment">//如果元素无初始值,则需要赋值</span></span><br><span class="line">      <span class="keyword">this</span>.style.left = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.style.top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      newX = e.clientX; <span class="comment">//存储移动后的鼠标位置</span></span><br><span class="line">      newY = e.clientY;</span><br><span class="line">      <span class="comment">// 移动后的位置 = 当前位置 - (移动后的鼠标位置-移动前的鼠标位置)</span></span><br><span class="line">      ele.style.top = <span class="built_in">parseFloat</span>(ele.style.top) + (newY - oldY) + <span class="string">'px'</span>;</span><br><span class="line">      ele.style.left = <span class="built_in">parseFloat</span>(ele.style.left) + (newX - oldX) + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">      oldX = newX; <span class="comment">//移动完后旧鼠标位置为新鼠标位置</span></span><br><span class="line">      oldY = newY;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标松开事件</span></span><br><span class="line">    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 解绑事件</span></span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js drag api</p><p><a href="https://www.cnblogs.com/moqiutao/p/6365113.html" target="_blank" rel="noopener">HTML5 拖放（Drag 和 Drop）详解与实例 - 风雨后见彩虹 - 博客园 (cnblogs.com)</a></p><p>在被拖动的元素上需定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./PoinkoParrot2.jpeg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"draggable"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在拖放的过程中会触发以下事件：</p><ul><li><p>在拖动目标上触发事件(源元素):</p><ul><li>ondragstart - 用户开始拖动元素时触发</li><li>ondrag - 元素正在拖动时触发</li><li>ondragend - 用户完成元素拖动后触发</li></ul></li><li><p>释放目标时触发的事件:</p><ul><li>ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件</li><li>ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件</li><li>ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件</li><li>ondrop - 在一个拖动过程中，释放鼠标键时触发此事件</li></ul></li></ul></li><li><p>eval</p><ul><li><a href="https://juejin.cn/post/6938775708739207182" target="_blank" rel="noopener">Eval</a></li><li><a href="https://juejin.cn/post/6844903713140637709" target="_blank" rel="noopener">你不知道的 eval</a></li><li><a href="https://juejin.cn/post/6954380745871720462" target="_blank" rel="noopener">欺骗词法 eval 和 with</a></li></ul></li><li><p>AMD、CMD、CommonJs</p><ul><li><a href="https://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现 - ECMAScript 6入门</a></li><li><a href="https://juejin.cn/post/6844903576309858318" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul></li><li><p>🟠js监听对象属性改变（vue属性监听）</p><ul><li><a href="https://juejin.cn/post/6844903842828533767" target="_blank" rel="noopener">论如何监听一个对象某个属性的变化</a></li></ul></li><li><p>JS实现跨域</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li></ul></li><li><p>JS深度拷贝（浅拷贝、深拷贝…）</p><p><img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211222145748666.png" alt="image-20211222145748666"></p></li><li><p>重排重绘</p><ul><li><a href="https://juejin.cn/post/6844903745914929165" target="_blank" rel="noopener">浏览器重绘(repaint)重排(reflow)与优化</a></li></ul></li><li><p>🟠JS全排列</p><ul><li><p><a href="https://juejin.cn/post/6844904191379374087" target="_blank" rel="noopener">前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">...chunks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span> (<span class="params">chunkIndex, prev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = chunks[chunkIndex];</span><br><span class="line">    <span class="keyword">let</span> isLast = chunkIndex === chunks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> chunk) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = prev.concat(val);</span><br><span class="line">      <span class="keyword">if</span> (isLast) &#123;</span><br><span class="line">        <span class="comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span></span><br><span class="line">        res.push(cur); <span class="comment">//将最后一个数组的所有选项分别压入</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        helper(chunkIndex + <span class="number">1</span>, cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 从属性数组下标为 0 开始处理</span></span><br><span class="line">  <span class="comment">// 并且此时的 prev 是个空数组</span></span><br><span class="line">  helper(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'iPhone X'</span>, <span class="string">'iPhone XS'</span>];</span><br><span class="line">  <span class="keyword">let</span> colors = [<span class="string">'黑色'</span>, <span class="string">'白色'</span>];</span><br><span class="line">  <span class="keyword">let</span> storages = [<span class="string">'64g'</span>, <span class="string">'256g'</span>];</span><br><span class="line">  <span class="keyword">let</span> res = combine(names, colors, storages);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="comment">/* result</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone X', '白色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '黑色', '256g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '64g' ],</span></span><br><span class="line"><span class="comment">    [ 'iPhone XS', '白色', '256g' ]</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>  <img src= "/img/loading.gif" data-src="/2022/03/05/study/image-20211224151929493.png" alt="image-20211224151929493"></p></li></ul></li><li><p>this指向、隐式丢失、显式绑定</p><ul><li><a href="https://juejin.cn/post/6844904113352736776" target="_blank" rel="noopener">this绑定的四种方式：new，显式，隐式，默认</a></li></ul></li><li><p>🟠virtual dom</p><ul><li><a href="https://juejin.cn/post/6844903609667321863" target="_blank" rel="noopener">探索Virtual DOM的前世今生</a></li><li><a href="https://juejin.cn/post/6844903615652610055" target="_blank" rel="noopener">深入框架本源系列 —— Virtual Dom</a></li><li><a href="https://juejin.cn/post/6844903921442422791" target="_blank" rel="noopener">面试官问: 如何理解Virtual DOM？</a></li></ul></li><li><p>vue生命周期</p></li><li><p>🔴🟠Promise底层实现</p></li><li><p>事件监听</p><ul><li><a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">HTML DOM 事件对象</a></li><li><a href="https://juejin.cn/post/6844903886960984072" target="_blank" rel="noopener">一篇文章能否解决你事件监听的许多疑问</a></li><li>🔴🔵<a href="https://juejin.cn/post/6844903647197790221" target="_blank" rel="noopener">撸一个JS的事件管理</a></li><li>🔵<a href="https://juejin.cn/post/6844904069820055560" target="_blank" rel="noopener">🔥JavaScript 自定义事件如此简单！</a></li></ul></li><li><p>Generator</p><ul><li><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112" target="_blank" rel="noopener">generator</a></p></li><li><p>基本使用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(res.next());<span class="comment">//&#123; value: 4, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>生成自增id函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">next_id</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// !不是阻塞执行，是yield时跳出函数并储存当时的状态。</span></span><br><span class="line">    <span class="comment">// !执行next()时还原当时的状态，从上次yield的位置向下执行</span></span><br><span class="line">    <span class="keyword">yield</span> ++id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = next_id();</span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next().value); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li></ul><ol start="22"><li><p>arguments（箭头函数）</p><ul><li><a href="https://juejin.cn/post/6844903616231260174" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li><li><a href="https://juejin.cn/post/6844903801799835655" target="_blank" rel="noopener">详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景</a></li><li><a href="https://juejin.cn/post/6844904152640782343" target="_blank" rel="noopener">曾经我以为我很懂箭头函数</a></li><li><a href="https://juejin.cn/post/6844904133409914894" target="_blank" rel="noopener">对阮一峰《ES6 入门》中箭头函数 this 描述的探究</a></li></ul></li><li><p>🔴🟠🔵继承</p><ul><li><a href="https://juejin.cn/post/6844903696111763470" target="_blank" rel="noopener">JavaScript常用八种继承方案</a></li><li><a href="https://juejin.cn/post/6844904094948130824" target="_blank" rel="noopener">🔥比继承家业还要简单的JS继承题-封装篇(牛刀小试)</a></li><li><a href="https://juejin.cn/post/6844903475021627400" target="_blank" rel="noopener">JS原型链与继承</a></li></ul></li><li><p>🔴script——async属性</p><ul><li><a href="https://juejin.cn/post/6844903560879013896" target="_blank" rel="noopener">defer和async</a></li><li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener">defer和async简洁版</a></li></ul></li><li><p>🔴jsonp——跨域的解决</p><ul><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">笔记</a></li><li><a href="https://juejin.cn/post/6844903462551945230" target="_blank" rel="noopener">原生 JavaScript 实现 AJAX、JSONP</a></li><li><a href="https://juejin.cn/post/6844903976505344013" target="_blank" rel="noopener">一分钟说完JSONP请求</a></li></ul></li><li><p>🔴ajax的返回状态——Fetch</p><ul><li><a href="https://juejin.cn/post/6844903618764603399" target="_blank" rel="noopener">Ajax原理一篇就够了</a></li><li><a href="https://ypigy.gitee.io/2020/07/20/AJAX/" target="_blank" rel="noopener">AJAX笔记 | Dong</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html" target="_blank" rel="noopener">Fetch API 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul></li><li><p>dns预加载（缓存）dns-preFetch</p><ul><li><a href="https://juejin.cn/post/6844903492490887182" target="_blank" rel="noopener">DNS Prefetching 的正确使用姿势</a></li><li><a href="https://juejin.cn/post/6915204591730556935" target="_blank" rel="noopener">preload、prefetch、preconnect 和 dns-prefetch 知多少</a></li></ul></li><li><p>🔵函数柯里化（currying）</p><ul><li><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">详解JS函数柯里化</a></li></ul></li><li><p>骨架屏</p><p><a href="https://www.jianshu.com/p/a72263d2d105" target="_blank" rel="noopener">什么是骨架屏 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/96455668" target="_blank" rel="noopener">如何实现优美的骨架屏 - 知乎 (zhihu.com)</a></p></li><li><p>🔴启动性能（异步）（前端性能优化）</p><ul><li><a href="https://juejin.cn/post/6892994632968306702" target="_blank" rel="noopener">前端性能优化 24 条建议（2020） - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6904517485349830670" target="_blank" rel="noopener">工作中如何进行前端性能优化(21种优化+7种定位方式) - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7020212914020302856" target="_blank" rel="noopener">写在 2021 的前端性能优化指南 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6844904195707895816" target="_blank" rel="noopener">前端性能优化总结 - 掘金 (juejin.cn)</a></li></ul></li><li><p>HTTP缓存机制</p><p><a href="https://juejin.cn/post/6844904100035821575#heading-59" target="_blank" rel="noopener">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903634002509832" target="_blank" rel="noopener">面试精选之http缓存 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903517702848526" target="_blank" rel="noopener">HTTP—-HTTP缓存机制 - 掘金 (juejin.cn)</a></p></li><li><p>websocket、AJAX</p><p><a href="https://juejin.cn/post/6844903544978407431" target="_blank" rel="noopener">WebSocket：5分钟从入门到精通 - 掘金 (juejin.cn)</a></p></li><li><p>TCP/IP模型（计算机网络）</p><p><a href="https://ypigy.gitee.io/2021/04/18/运输层/#传输控制协议TCP概述" target="_blank" rel="noopener">计算机网络-运输层 | Dong (gitee.io)</a></p><p>[计算机网络-网络层 | Dong (gitee.io)](<a href="https://ypigy.gitee.io/2021/04/18/网络层/#网际协议" target="_blank" rel="noopener">https://ypigy.gitee.io/2021/04/18/网络层/#网际协议</a> IP)</p></li><li><p>🟠gulp、webpack（打包原理）</p><p><a href="https://juejin.cn/post/6844903802382860296#heading-6" target="_blank" rel="noopener">Webpack 模块打包原理 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6917069979913289736#heading-15" target="_blank" rel="noopener">对比webpack，你更应该先掌握gulp【10分钟教你彻底掌握gulp】 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904038543130637#heading-22" target="_blank" rel="noopener">webpack打包原理 ? 看完这篇你就懂了 ! - 掘金 (juejin.cn)</a></p></li><li><p>PWA</p><p><a href="https://juejin.cn/post/6844904052166230030" target="_blank" rel="noopener">面试官：请你实现一个PWA 我：😭 - 掘金 (juejin.cn)</a></p></li><li><p>🔴单元测试</p><p><a href="https://juejin.cn/post/7039108357554176037" target="_blank" rel="noopener">如何做前端单元测试 - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/7049293284883038238" target="_blank" rel="noopener">前端单元测试入门与最佳实践 - 掘金 (juejin.cn)</a></p></li><li><p>🔴seo优化</p><p><a href="https://segmentfault.com/a/1190000019623624_vueseo" target="_blank" rel="noopener">基于Vue SEO的四种方案 - SegmentFault 思否</a></p><p><a href="https://juejin.cn/post/6980167371864424456" target="_blank" rel="noopener">前端搜索引擎优化（SEO）的技巧 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903824428105735#heading-4" target="_blank" rel="noopener">前端SEO优化 - 掘金 (juejin.cn)</a></p></li><li><p>grid栅格布局</p><p><a href="https://juejin.cn/post/6854573220306255880" target="_blank" rel="noopener">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p></li><li><p>bigint</p><p><a href="https://juejin.cn/post/6844903902295359502" target="_blank" rel="noopener">JS最新基本数据类型：BigInt - 掘金 (juejin.cn)</a></p></li><li><p>🔴🟠0.1+0.2 ？（是0.3吗）</p><p><a href="https://juejin.cn/post/7056934829920616461" target="_blank" rel="noopener">用了一天时间，我终于彻底搞懂了 0.1+0.2 是否等于 0.3！ - 掘金 (juejin.cn)</a></p></li><li><p>osi七层模型（计算机网路）</p><p><a href="https://ypigy.gitee.io/categories/计算机网络/" target="_blank" rel="noopener">分类: 计算机网络 | Dong (gitee.io)</a></p></li><li><p>🔴head、状态码</p><p><a href="https://ypigy.gitee.io/2020/07/28/http协议/" target="_blank" rel="noopener">http协议 | Dong (gitee.io)</a></p><p><a href="https://blog.csdn.net/wzx19840423/article/details/79073087" target="_blank" rel="noopener">http状态码总结_wzx19840423的专栏-CSDN博客_http状态码</a></p><p><a href="https://blog.csdn.net/u014346301/article/details/53995333" target="_blank" rel="noopener">HTTP状态码（HTTP Status Code）_Sweet oDream-CSDN博客</a></p></li><li><p>声明式绑定（REACT Query/ Apollo GtaphQL Client）<br>等有学react再来吧</p></li><li><p>假数据生产（Yapi、RAP2、Apifox）</p><ol><li><a href="https://hellosean1025.github.io/yapi/index.html" target="_blank" rel="noopener">YApi 接口管理平台 (hellosean1025.github.io)</a></li><li><a href="http://rap2.taobao.org/account/login" target="_blank" rel="noopener">RAP接口管理平台 (taobao.org)</a></li><li><a href="https://github.com/thx/rap2-delos" target="_blank" rel="noopener">阿里妈妈前端团队出品的开源接口管理工具RAP第二代</a></li><li><a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a></li></ol></li><li><p>BFF架构</p><p><a href="https://juejin.cn/post/6950530370810937352" target="_blank" rel="noopener">第 016 期 前后端经常争吵？ - BFF 了解一下 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7008840813069205512" target="_blank" rel="noopener">微服务/API时代的前端开发] BFF入门–5个实用的BFF使用案例 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844903959333699598" target="_blank" rel="noopener">初识BFF架构设计 - 掘金 (juejin.cn)</a></p></li><li><p>🔴文档碎片</p><p><a href="https://juejin.cn/post/7012073594918273032" target="_blank" rel="noopener">前端性能优化：创建文档碎片 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/408738417" target="_blank" rel="noopener">性能优化之文档碎片 - 知乎 (zhihu.com)</a></p></li><li><p>🔴宏任务、微任务（同步异步）</p><p>直接看js代码and思维导图（可以的话整个笔记）</p></li><li><p>compose函数</p><p><a href="https://juejin.cn/post/6844904061821517832" target="_blank" rel="noopener">JavaScript中的compose函数和pipe函数 - 掘金 (juejin.cn)</a></p></li><li><p>forEach跳出循环（终止并返回值）</p><p><a href="https://juejin.cn/post/6971972782292729886" target="_blank" rel="noopener">面试官问我JS中forEach能不能跳出循环 - 掘金 (juejin.cn)</a>看完看看评论，挺有意思的</p></li><li><p>shell命令</p><p><a href="https://juejin.cn/post/6844903489911406599" target="_blank" rel="noopener">Shell常见命令实践 - 掘金 (juejin.cn)</a></p></li><li><p>git命令</p><ol><li>合并代码冲突（merge&amp;rebase）</li><li>代码回滚（reset&amp;checkout）</li><li>代码暂存（stash）</li></ol></li><li><p>linux命令</p></li><li><p>Element.</p><ol><li>getBounding</li><li>IntersectionOberver</li><li>createNodeIterator</li><li>getComputedStyle</li><li>getPropertyValue</li><li>MutationObserver</li></ol></li><li><p>ES6常用方法</p><ul><li><a href="https://juejin.cn/post/6906398702269628424" target="_blank" rel="noopener">混子前端24个解决工作问题的ES6代码片段 - 掘金 (juejin.cn)</a></li></ul></li></ol><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol><li><a href="https://chinese.freecodecamp.org/learn" target="_blank" rel="noopener">编程学习</a></li><li>面试题：<ul><li><a href="https://juejin.cn/post/6989422484722286600" target="_blank" rel="noopener">2021年我的前端面试准备 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7035259189966405668" target="_blank" rel="noopener">面试的时候面试官是这样问我Js基础的，角度真刁钻 - 掘金 (juejin.cn)</a></li></ul></li><li><a href="https://juejin.cn/post/7013247812628381704" target="_blank" rel="noopener">组件库</a></li><li><a href="https://juejin.cn/post/7026339412799651876" target="_blank" rel="noopener">Vue源码(一些数据结构)</a></li><li><a href="https://juejin.cn/post/7025868886914400293" target="_blank" rel="noopener">现代web开发困局</a></li><li><a href="https://www.zhihu.com/question/458213150" target="_blank" rel="noopener">为什么 WeakSet 和 WeakMap 无法获取到元素的数量，也无法迭代其中的元素</a></li><li><a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">JS垃圾回收机制</a></li><li><a href="https://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="noopener">前端性能优化</a></li><li><a href="https://segmentfault.com/a/1190000012571492" target="_blank" rel="noopener">gzip</a></li><li><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener">PWA</a></li><li><a href="https://juejin.cn/post/7007206194276204575#heading-26" target="_blank" rel="noopener">前端学习路线以及知识体系：</a></li><li><a href="https://juejin.cn/post/7038297948630827039" target="_blank" rel="noopener">11个非常有用的HTML单行代码🎃 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7048916480032768013" target="_blank" rel="noopener">「前端该如何优雅地Mock数据🏃」每个前端都应该学会的技巧 - 掘金 (juejin.cn)</a></li></ol>]]></content>
    
    <summary type="html">
    
      记录一下看过的前端知识点，进行汇总并整理
    
    </summary>
    
    
      <category term="web" scheme="http://Dong-666.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://Dong-666.github.io/tags/web/"/>
    
      <category term="前端" scheme="http://Dong-666.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>K最近邻算法KNN</title>
    <link href="http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-20T10:00:00.000Z</published>
    <updated>2022-03-02T08:00:45.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>KNN（K- Nearest Neighbor）法即K最邻近法，最初由 Cover和Hart于1968年提出，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路非常简单直观：如果一个样本在特征空间中的K个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别 </p><p>该方法的不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最邻近点。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。另外还有一种 Reverse KNN法，它能降低KNN算法的计算复杂度，提高分类的效率 </p><p>KNN算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分</p></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>准备数据，对数据进行预处理 。</li><li>计算测试样本点（也就是待分类点）到其他每个样本点的距离</li><li>对每个距离进行排序，然后选择出距离最小的K个点</li><li>对K个点所属的类别进行比较，根据少数服从多数的原则，将测试样本点归入在K个点中占比最高的那一类</li></ol><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221648768.png" alt="image-20220221221648768"></p><p>使用毕达哥拉斯公式计算A和B的相似性（距离），值越小，相似性越大</p><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221215435440.png" alt="image-20220221215435440"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221221838593.png" alt="image-20220221221838593"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>原理上挺简单的，所以没解释，直接上代码，包含两个函数，一个毕达哥拉斯公式，一个KNN算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毕达哥拉斯  Math.sqrt((x1-x2)² + (y1 - y2)²)</span></span><br><span class="line"><span class="comment">// 传参：目标对象1，目标对象2，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pythagoras</span>(<span class="params">obj1, obj2, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> common = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj2[key]) &#123;</span><br><span class="line">      res.push(<span class="built_in">Math</span>.pow(<span class="built_in">parseFloat</span>(obj1[key]) - <span class="built_in">parseFloat</span>(obj2[key]), <span class="number">2</span>)); <span class="comment">//差值取平方</span></span><br><span class="line">      common.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">Math</span>.sqrt(res.reduce(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> (cur += next), <span class="number">0</span>)).toFixed(<span class="number">2</span>); <span class="comment">//累加取平方根且保留两位小数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; res, common &#125;;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法-KNN-毕达哥拉斯比较距离</span></span><br><span class="line"><span class="comment">// 传参：对象集合，当前对象，是否返回详细结果（默认否）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kNN</span>(<span class="params">objs, newObj, returnDetail = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allDistance = []; <span class="comment">//存储所有距离</span></span><br><span class="line">  <span class="keyword">let</span> minDistance = <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//存储最小距离,默认js能读的最大数值</span></span><br><span class="line">  <span class="keyword">let</span> minObjName; <span class="comment">//存储最小对象名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> objs) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = pythagoras(objs[key], newObj); <span class="comment">//对每个对象执行毕达哥拉斯公式</span></span><br><span class="line">    allDistance.push(&#123; <span class="attr">distance</span>: res, <span class="attr">targetName</span>: key &#125;); <span class="comment">//将所有结果压入</span></span><br><span class="line">    <span class="comment">// res &lt; minDistance &amp;&amp; ((minDistance = res), (minObjName = key));</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历查找最小距离对象</span></span><br><span class="line">  <span class="keyword">let</span> resultObj = allDistance.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.distance - b.distance)[<span class="number">0</span>];</span><br><span class="line">  minObjName = resultObj[<span class="string">'targetName'</span>];</span><br><span class="line">  minDistance = resultObj[<span class="string">'distance'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnDetail) <span class="keyword">return</span> &#123; allDistance, minDistance, minObjName &#125;;</span><br><span class="line">  <span class="keyword">return</span> minObjName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟数据以及测试"><a href="#模拟数据以及测试" class="headerlink" title="模拟数据以及测试"></a>模拟数据以及测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">//数据库已有用户及其喜欢的电影类型的打分</span></span><br><span class="line"><span class="keyword">let</span> favoriteType = &#123;</span><br><span class="line">  xiaoming: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">3</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaohong: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">4</span>,</span><br><span class="line">    action: <span class="number">1</span>,</span><br><span class="line">    scienceFiction: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaolv: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">1</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaozi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">1</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoqi: &#123;</span><br><span class="line">    terror: <span class="number">1</span>,</span><br><span class="line">    comedy: <span class="number">2</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">3</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  xiaoquan: &#123;</span><br><span class="line">    terror: <span class="number">5</span>,</span><br><span class="line">    comedy: <span class="number">5</span>,</span><br><span class="line">    love: <span class="number">5</span>,</span><br><span class="line">    action: <span class="number">5</span>,</span><br><span class="line">    scienceFiction: <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = kNN(favoriteType, &#123; <span class="attr">terror</span>: <span class="number">1</span>, <span class="attr">comedy</span>: <span class="number">4</span>, <span class="attr">love</span>: <span class="number">2</span>, <span class="attr">action</span>: <span class="number">5</span>, <span class="attr">scienceFiction</span>: <span class="number">5</span> &#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allDistance: [</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.12'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoqi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'4.36'</span>, <span class="attr">targetName</span>: <span class="string">'xiaozi'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.00'</span>, <span class="attr">targetName</span>: <span class="string">'xiaohong'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.10'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoquan'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'5.20'</span>, <span class="attr">targetName</span>: <span class="string">'xiaolv'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">distance</span>: <span class="string">'6.78'</span>, <span class="attr">targetName</span>: <span class="string">'xiaoming'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  minDistance: <span class="string">'4.12'</span>,</span><br><span class="line">  minObjName: <span class="string">'xiaoqi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><img src= "/img/loading.gif" data-src="/2022/02/20/K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/image-20220221222005339.png" alt="image-20220221222005339"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>KNN用于分类和回归，需要考虑最近的邻居。</li><li>分类就是编组。 </li><li>回归就是预测结果（如数字）。 </li><li>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 </li><li>能否挑选合适的特征事关KNN算法的成败</li></ol>]]></content>
    
    <summary type="html">
    
      KNN（K- Nearest Neighbor）法即K最邻近法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://dong-666.github.io/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-02-13T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:49.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式</p></blockquote><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221172703812.png" alt="image-20220221172703812"></p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180313039.png" alt="image-20220221180313039"></p><p>解决方式就是采用动态规划</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180638182.png" alt="image-20220221180638182"></p><p>背包分割的最小重量取决于能拿的最小物品重量，如果此时最小物品为0.5，那么背包就要被划分成4/0.5 = 8，8列</p><p>在每一行， <strong>可偷的商品都为当前行的商品以及之前各行的商品</strong>，逐行进行计算，比如第一行，可拿的物品只有吉他，那么接下来四格，就都只能考虑吉他，所以全都填充为单个吉他的价值，等到第二行时，可选的选项就有音响和前一行的吉他了，这时候每个单元格再根据物品价值和质量综合判断来进行数据填充，音响重量有4，所以前面依旧沿用吉他的价值，直接到音响的重量所处格子，这时候我们发现音响价值在4的时候大于1500，也就是音响本身价值大于吉他，所以进行替换，接下来亦是如此，到第三行第四个格子我们发现笔记本电脑的价格加上<strong>上一行</strong>4-笔记本重量所处单元格的价值大于上一行4所处价值，所以得出最终的结果</p><p>计算结果如下</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221180723661.png" alt="image-20220221180723661"></p><p>计算每个单元格的价值时，使用的公式如下</p><p>在1和2之间进行比较，选择大的那方</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221182208929.png" alt="image-20220221182208929"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p><strong>各行的排列顺序无关紧要</strong></p><p>也就是说哪个物品先判断都行，你想把音响放在最开始进行分析都可以，不影响结果（但在后面的代码中为了方便我还是会为数据进行排序，从最轻的拿起，可以思考下我为什么那样做，当然也有可能会是我想不到（不足）的地方（怕打脸哈哈哈））</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183039104.png" alt="image-20220221183039104"></p></li><li><p><strong>使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分（你只能把它当作一个最小的整体，不能继续分割的整体）</strong></p><p>如果想处理像偷大米、黄豆之类可以拆出来倒到背包的问题时，则可以使用贪婪算法</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183404146.png" alt="image-20220221183404146"></p></li><li><p>相互依赖的情况</p><p>没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是<strong>离散</strong>的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了子问题会相互产生影响的问题</p></li><li><p>为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包</p><p>形象来说就是一分为二，再在每个子背包中一分为二（有点类似二叉树）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221183745856.png" alt="image-20220221183745856"></p></li><li><p>最优解可能会导致背包没装满</p><p>假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路如下</p><ol><li>因为从上面的算法得出：每次计算当前行都只会用到上一行的数据，所以我并没有像书里一样使用表格去记录这个过程，我使用了两个二维数组prices、goods分别用来存储每格的价值和所含物品，每次每行计算后的最新结果goods[1]会重新赋值给goods[0]，计算前又将goods[0]默认赋值给goods[1]，这样就可以只在价格有改变时改变单元格即可， prices同理</li><li>然后对初始数据initData进行排序，这样可以保证最开始那一行是有数据的，如果是别的比较重的物品，则最开始那几个空格就会为空，就又要去做一些多余的判断或者赋默认值，挺麻烦的，怕代码冗余和出现一些问题</li><li>内层（列）遍历，每次都只用从当前物品重量对应单元格开始算，毕竟前几格你也放不下嘛，默认当前格的上一行值即可，减少代码判断</li><li>核心判断语句不变，跟上面一致</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDeep</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetGoods</span>(<span class="params">data, bagWeight</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initData = <span class="built_in">Array</span>.from(data); <span class="comment">//数据初始化，防止修改到原数据</span></span><br><span class="line">  <span class="keyword">let</span> prices = [[], []]; <span class="comment">//存放价值的数组</span></span><br><span class="line">  <span class="keyword">let</span> goods = [[], []]; <span class="comment">//存放每个最大价值所含物品</span></span><br><span class="line">  initData.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.weight - b.weight); <span class="comment">//数据初始化排序，从小到大</span></span><br><span class="line">  <span class="keyword">let</span> baseWeight = initData[<span class="number">0</span>][<span class="string">'weight'</span>]; <span class="comment">//获得基础容量</span></span><br><span class="line">  <span class="keyword">let</span> pricesLength = <span class="built_in">Math</span>.floor(bagWeight / baseWeight); <span class="comment">//获得背包应分割的数量,向下取整，排除书包额外容量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据,相当于遍历第一件商品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pricesLength; i++) &#123;</span><br><span class="line">    prices[<span class="number">0</span>].push(initData[<span class="number">0</span>][<span class="string">'price'</span>]);</span><br><span class="line">    goods[<span class="number">0</span>].push([initData[<span class="number">0</span>][<span class="string">'name'</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除当前商品，避免参与下面的算法执行</span></span><br><span class="line">  <span class="keyword">delete</span> initData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心，从第二件商品开始遍历，对每一件商品进行数据填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initData) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = initData[key];</span><br><span class="line">    <span class="keyword">let</span> elementWeightIndex = element[<span class="string">'weight'</span>] / baseWeight - <span class="number">1</span>; <span class="comment">//物品重量对应索引</span></span><br><span class="line"></span><br><span class="line">    prices[<span class="number">1</span>] = copyDeep(prices[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line">    goods[<span class="number">1</span>] = copyDeep(goods[<span class="number">0</span>]); <span class="comment">//默认从上一行取值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = elementWeightIndex; i &lt; pricesLength; i++) &#123;</span><br><span class="line">      <span class="comment">//第一种情况：当前物品重量同当前背包小格重量相等</span></span><br><span class="line">      <span class="keyword">if</span> (i == elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品及价格</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>]];</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种情况，当前物品重量大于当前背包小格重量</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; elementWeightIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果当前物品价格加上（当前背包质量-当前物品质量）的价格大于先前价格</span></span><br><span class="line">        <span class="keyword">if</span> (element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>] &gt; prices[<span class="number">0</span>][i]) &#123;</span><br><span class="line">          <span class="comment">// 赋值为当前物品和（当前背包质量-当前物品质量）的物品总和及价格总和</span></span><br><span class="line">          prices[<span class="number">1</span>][i] = element[<span class="string">'price'</span>] + prices[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>];</span><br><span class="line">          goods[<span class="number">1</span>][i] = [element[<span class="string">'name'</span>], ...goods[<span class="number">0</span>][i - elementWeightIndex - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prices[<span class="number">0</span>] = copyDeep(prices[<span class="number">1</span>]);</span><br><span class="line">    goods[<span class="number">0</span>] = copyDeep(goods[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    goods: goods[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">    price: prices[<span class="number">1</span>][pricesLength - <span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下"><a href="#运行下" class="headerlink" title="运行下"></a>运行下</h4><p>模拟数据有点多，不要介意，确保可靠嘛</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'吉他'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'音响'</span>, <span class="attr">price</span>: <span class="number">3000</span>, <span class="attr">weight</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'笔记本电脑'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'iphone'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ipad'</span>, <span class="attr">price</span>: <span class="number">2000</span>, <span class="attr">weight</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'自行车'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'钻石'</span>, <span class="attr">price</span>: <span class="number">50000</span>, <span class="attr">weight</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'花'</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'巧克力'</span>, <span class="attr">price</span>: <span class="number">500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'耳机'</span>, <span class="attr">price</span>: <span class="number">1500</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = dynamicToGetGoods(data, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; goods: [ '音响', '钻石', 'iphone', '吉他', '耳机', '巧克力' ], price: 58500 &#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。</li><li>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 </li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴</li></ol><p>每次用的时候问问自己</p><blockquote><ol><li>单元格中的值是什么？</li><li>如何将这个问题划分为子问题？ </li><li>网格的坐标轴是什么？</li></ol></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>建立表格</li><li>确定每一个格的值代表什么 </li><li>如何将大问题划分为具有相同解法的子问题</li><li>确定网格坐标轴</li></ol><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185431847.png" alt="image-20220221185431847"></p><p>尝试一下，在纸上绘制网格，将每个单词分解（子问题）</p><p>答案如下（思考下，这是如何得出的）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185929563.png" alt="image-20220221185929563"></p><p>解决这个问题核心的伪代码类似于下面这样</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221185552675.png" alt="image-20220221185552675"></p><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ol><li><p>对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190054121.png" alt="image-20220221190054121"></p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>你可以先尝试着根据上面的思路自己写一下</p><p>在写的过程中你是否会发现一个问题，在代码的实现上，我们会发现上面的公式会有些问题，毕竟我们是用二维数组去记录这个过程，所以某些情况下会出现<code>data[index1 - 1][index2 - 1]</code>报错的情况，什么情况下呢</p><p>如下图，这些情况下的值在你按部就班时运行会报错的，因为它缺少斜对角的值，毕竟没有<code>data[-1][-1]</code>这样的值出现</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220222085726502.png" alt="image-20220222085726502"></p><p>怎么解决，有两种方法，第一种是每次到该计算都做一下判断，判断是否有值，我嫌太麻烦了，且影响从代码上去理解这个算法的思路，所以使用第二种，给你一个二维数组，你就会理解了，然后我就懒得解释了哈哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span> ],</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在里面，我会用一个函数<code>fillDataByWordLength</code>去填充第一行的0，以及在内层循环（列）中每次一开始填充一个0</p><p>还有一点，我使用了<code>max</code>和<code>maxWord</code>在每次判断时去分别存储<strong>最长公共子串长度</strong>和<strong>最长公共子串</strong>，免得后面再在二维数组去找一个最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br></pre></td></tr></table></figure><p><code>getMaxWord</code>函数主要用作获得最长的公共子串，比如，fish和fosh最长的公共子串就为sh</p><p>然后再看看下面的代码，应该没啥问题了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得最长的公共子串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxWord</span>(<span class="params">word, maxWordPosition, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = maxWordPosition - max + <span class="number">1</span>; i &lt;= maxWordPosition; i++) &#123;</span><br><span class="line">    res += word[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">//存储最长公共子串数</span></span><br><span class="line">  <span class="keyword">let</span> maxWord; <span class="comment">//存储最长公共子串</span></span><br><span class="line">  <span class="keyword">let</span> maxWord1Position; <span class="comment">//存储最长公共子串截至位置</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">        data[index1][index2] &gt; max &amp;&amp; ((max = data[index1][index2]), (maxWord1Position = index1 - <span class="number">1</span>)); <span class="comment">//最长公共子串数赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不相等则赋值为0</span></span><br><span class="line">        data[index1][index2] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxWord = getMaxWord(word1, maxWord1Position, max);</span><br><span class="line">  <span class="keyword">return</span> &#123; max, maxWord &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-1"><a href="#运行下-1" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190426458.png" alt="image-20220221190426458"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190516948.png" alt="image-20220221190516948"></p><p>这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的 字母数。如何计算最长公共子序列呢</p><p>计算过程如下：图很重要！！！！！！（懒得打字了）</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190615957.png" alt="image-20220221190615957"></p><p>核心伪代码</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221190713163.png" alt="image-20220221190713163"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>思路是和上面例子很相近的，只是判断语句不同了而已，直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据word长度填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillDataByWordLength</span>(<span class="params">word, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word.length; i++) &#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicToGetCommonWords</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = []; <span class="comment">//存储动态规划网格</span></span><br><span class="line">  data[<span class="number">0</span>] = fillDataByWordLength(word2, <span class="number">0</span>); <span class="comment">//数组填充</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算法核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index1 = <span class="number">1</span>; index1 &lt; word1.length + <span class="number">1</span>; index1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element1 = word1[index1 - <span class="number">1</span>]; <span class="comment">//获取当前字母</span></span><br><span class="line">    data[index1] = []; <span class="comment">//初始化数组</span></span><br><span class="line">    data[index1].push(<span class="number">0</span>); <span class="comment">//默认第一位为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index2 = <span class="number">1</span>; index2 &lt; word2.length + <span class="number">1</span>; index2++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element2 = word2[index2 - <span class="number">1</span>]; <span class="comment">//获取当前对比字母</span></span><br><span class="line">      <span class="keyword">if</span> (element1 == element2) &#123;</span><br><span class="line">        <span class="comment">// 若相等，则当前单元格值等于左对角线方格值加上1</span></span><br><span class="line">        data[index1][index2] = data[index1 - <span class="number">1</span>][index2 - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">//当前单元格赋值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若不相等，则从左边或上边的邻居方格中取一个最大值</span></span><br><span class="line">        data[index1][index2] = <span class="built_in">Math</span>.max(data[index1][index2 - <span class="number">1</span>], data[index1 - <span class="number">1</span>][index2]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">res</span>: data[word1.length][word2.length], <span class="attr">calculationMatrix</span>: data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行下-2"><a href="#运行下-2" class="headerlink" title="运行下"></a>运行下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = dynamicToGetCommonWords(<span class="string">'fish'</span>, <span class="string">'fosh'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-src="/2022/02/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220221191104618.png" alt="image-20220221191104618"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="动态规划的实际应用"><a href="#动态规划的实际应用" class="headerlink" title="动态规划的实际应用"></a>动态规划的实际应用</h3><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 </li><li>你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>需要在给定约束条件下优化某种指标时，动态规划很有用。</li><li>问题可分解为离散子问题时，可使用动态规划来解决。</li><li>每种动态规划解决方案都涉及网格。</li><li>单元格中的值通常就是你要优化的值。</li><li>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ol>]]></content>
    
    <summary type="html">
    
      动态规划算法通常用于求解具有某种最优性质的问题
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法</title>
    <link href="http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-10T06:00:00.000Z</published>
    <updated>2022-03-02T08:00:37.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，<strong>算法得到的是在某种意义上的局部最优解</strong></p><p>换句话说：贪婪算法就是每步都选择局部最优解，最终得到的就是全局最优解</p></blockquote><p>贪心算法也存在如下问题：</p><ol><li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑</li><li>贪心算法一般用来解决求最大或最小解</li><li>贪心算法只能确定某些问题的可行性范围</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150319952.png" alt="image-20220220150319952"></p><h3 id="集合覆盖问题（广播站问题）"><a href="#集合覆盖问题（广播站问题）" class="headerlink" title="集合覆盖问题（广播站问题）"></a>集合覆盖问题（广播站问题）</h3><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220150857304.png" alt="image-20220220150857304"></p><p>这一节的算法代码会在后面放出来，我们先专注于这个算法以及其应用先，毕竟会用但不知道在哪用就跟不会用差不多嘛</p><p>通过上面两个例子，我们可以得出如简介一样的总结，贪婪算法不算最优解，但是在某些复杂的问题下我们用它可以达到非常接近最优解的解，那什么又是复杂的问题，也就是哪些问题才需要用到贪婪算法呢</p><h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><blockquote><p>NP完全问题的简单定义：以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常 聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。</p></blockquote><p>比如<a href="https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/7737042" target="_blank" rel="noopener">旅行商问题</a>，这个<a href="https://zhuanlan.zhihu.com/p/159266077" target="_blank" rel="noopener">链接</a>会讲述TSP问题以及帮你引入到贪婪算法里，懂了这一节的例子也可以不用看了</p><p>比如有这么三个城市-北京、石家庄、呼和浩特，你都想去旅游，于是有一天，你开始规划路线，那么从哪里出发，最后去哪里，你会如何规划呢</p><p><img src= "/img/loading.gif" data-src="/2022/02/10/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/image-20220220152241040.png" alt="image-20220220152241040"></p><p>我们先不考虑起点从哪，假设我们想先去石家庄，然后去呼和浩特，最后再到北京，这便是其中一条路线，但我们想找出最短的那条路程，比较把时间花在路上，玩的很累不是吗，那么怎么选呢，<strong>穷举法</strong>？好像很不错的样子，我们来试试</p><blockquote><p>北京-石家庄-呼和浩特</p><p>北京-呼和浩特-石家庄</p><p>石家庄-北京-呼和浩特</p><p>石家庄-呼和浩特-北京</p><p>呼和浩特-北京-石家庄</p><p>呼和浩特-石家庄-北京</p></blockquote><p>然后就是在里面挑出一条最佳路线，显然，这个方法的时间复杂度是<strong>O(n！)</strong></p><p>这可是阶乘啊，意味着啥，当你越来越富，想玩的地方越来越多，你要挑选出一条最佳路线的难度可是越来越大，原来有钱人也不是那么好的</p><p>那么这个时候我们就要选择贪婪算法了</p><h3 id="如何识别-NP-完全问题"><a href="#如何识别-NP-完全问题" class="headerlink" title="如何识别 NP 完全问题"></a>如何识别 NP 完全问题</h3><p>NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小</p><p>下面几点可作为辨别NP问题的参考</p><ol><li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一 个NP完全问题吗？</li><li>在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？</li><li>你要制作中国地图，需要用不同的颜色标出相邻的省。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻省的颜色都不同。请问这是NP完全问题吗？</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说完上面，我们来看看JavaScript如何实现广播站问题的贪婪算法</p><p>首先，运行该算法我们需要什么样的数据格式，一个用于存储省名的数组、一个用于表达广播站及其可以广播的省份的映射关系-散列表，在里面，我们用字母来表示广播站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省份缩写</span></span><br><span class="line"><span class="keyword">let</span> address = [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>, <span class="string">'SC'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//广播站-散列表</span></span><br><span class="line"><span class="keyword">let</span> radioStation = &#123;</span><br><span class="line">  a: [<span class="string">'GD'</span>, <span class="string">'HN'</span>, <span class="string">'AH'</span>],</span><br><span class="line">  b: [<span class="string">'AH'</span>, <span class="string">'ZJ'</span>, <span class="string">'HN'</span>, <span class="string">'SC'</span>],</span><br><span class="line">  c: [<span class="string">'HN'</span>, <span class="string">'AH'</span>, <span class="string">'ZJ'</span>],</span><br><span class="line">  d: [<span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  e: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'GC'</span>, <span class="string">'JS'</span>],</span><br><span class="line">  f: [<span class="string">'HN'</span>, <span class="string">'HB'</span>, <span class="string">'FJ'</span>, <span class="string">'SC'</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着就是算法的实现了</p><p>记住我们的步骤</p><p>(1) 选出这样一个广播台，即它覆盖了<strong>最多的未覆盖</strong>省份。即便这个广播台覆盖了一些已覆盖的省，也没有关系。</p><p> (2) 重复第一步，直到覆盖了所有的州。</p><p>根据第二步，我们就应该会感觉到可能要用到迭代了</p><p>首先先不管用不用迭代，我们来分析下这个过程</p><p>最核心的一步：我们要找出<strong>最多的未覆盖</strong>省份的广播站，那么这一步如何实现</p><p>通过<strong>遍历</strong>广播站，找出广播站和所需要覆盖的省份间的<strong>交集</strong>，谁的交集包含的元素<strong>最多</strong>，就选哪个，这就是最核心的了，遍历、交集、最多，这三个名称就是算法核心代码了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line"><span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line"><span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">  <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">  <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">  intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着遍历完第一遍，有可能会剩下其他省份还没找出广播站呢，那该如何做呢，再对剩下的省份执行上述步骤嘛，这不就要用到迭代了，代码如下，我们用<code>res</code>这个变量用于存储最终的广播站结果集合，然后记得把当前选到的广播站从下次执行的函数参数中的数据删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line"><span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line"><span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br></pre></td></tr></table></figure><p>既然是迭代，那肯定要有终止条件，不然就无限迭代下去了，这个问题的基线条件是所有的地址都已找到所能广播的广播站了，换成代码的解释就是address长度为零</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line"><span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是这个算法的大致代码了，等等，如果有一个地址没有任何广播站能广播到呢，出现这种情况怎么办，这种问题我们只能当作无解，毕竟没有广播站能广播到你要的地址，说明数据有问题，需求也就根本无法解决</p><p>代码上也就是，两者交集没有任何结果，如果address长度还没为0时，没有结果意味着没有广播站可以服务该地址了，所以注意该代码位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法： 参数：所有地点（数组）、广播站（散列表）、最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greedy</span>(<span class="params">address, radioStation, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最大地址数的广播站所能广播的地址</span></span><br><span class="line">  <span class="keyword">let</span> maxAddressStation = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// 最大地址数的广播站名称</span></span><br><span class="line">  <span class="keyword">let</span> station = <span class="built_in">Object</span>.keys(radioStation)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基线条件（递归终止条件）</span></span><br><span class="line">  <span class="keyword">if</span> (address.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历radioStation，将每一项与addressCollection进行交集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> radioStation) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = radioStation[key];</span><br><span class="line">    <span class="keyword">let</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>(address.filter(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(element).has(i))); <span class="comment">//取交集</span></span><br><span class="line">    <span class="comment">// 判断：若当前集合大于之前的集合，则重新赋值最大值</span></span><br><span class="line">    intersection.size &gt; maxAddressStation.size &amp;&amp; ((maxAddressStation = intersection), (station = key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxAddressStation.size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'所选数据无解'</span>;</span><br><span class="line"></span><br><span class="line">  res.push(station); <span class="comment">//将广播站压入</span></span><br><span class="line">  address = address.filter(<span class="function"><span class="params">i</span> =&gt;</span> !maxAddressStation.has(i)); <span class="comment">//取差集，即剩下需要广播的地址</span></span><br><span class="line">  <span class="keyword">delete</span> radioStation[station]; <span class="comment">//排除当前已选择的广播站</span></span><br><span class="line">  <span class="keyword">return</span> greedy(address, radioStation, res); <span class="comment">//继续下次递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 </li><li>对于NP完全问题，还没有找到快速解决方案。 </li><li>面临NP完全问题时，最佳的做法是使用近似算法。 </li><li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li></ol><h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><p>三个都是NP问题，快去用贪婪算法试着解出来吧！加油💪</p>]]></content>
    
    <summary type="html">
    
      贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>狄克斯特拉算法</title>
    <link href="http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T14:00:00.000Z</published>
    <updated>2022-03-02T07:59:40.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800" target="_blank" rel="noopener">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>假设给定一个二维数组，里面存储着各个相邻点之间的距离，</p><p>比如第一个<code>[&#39;a&#39;, &#39;b&#39;, 20]</code>，表示着从A点到B点的距离为20，以此类推</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">30</span>],</span><br><span class="line">  [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="string">'e'</span>, <span class="string">'a'</span>, <span class="number">20</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而我们的需求则是，以某个确定的点为起点，得出其到其余点的最短距离，比如以a为起点，我们想得到其到b、c、d、e的最短距离</p><p>那么这个算法该如何在js上实现</p><p>单纯从这个数组来看，好像有点想不出解法，我们先试着把它转化成图形关系，从而更加容易理解点</p><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220218093850197.png" alt="image-20220218093850197"></p><p>从这个图，我们可以更加直观的理解每个点之间的位置距离关系，比如A，可以直接到达B、C、E，但却不能直接到达D，要想过去，还得通过一些“中介点”</p><p>接着，我们来简略介绍下狄克斯特拉算法的使用步骤</p><blockquote><p>(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 </p><p>(2) 更新该节点的邻居的开销。</p><p>(3) 重复这个过程，直到对图中的每个节点都这样做了。</p><p> (4) 计算最终路径。</p></blockquote><p>在默认初始化条件下：我们用一个表来记录默认起点下到其他点的最短距离</p><table><thead><tr><th>次数</th><th>S</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>{a}</td><td>20</td><td>3</td><td>∞</td><td>20</td></tr><tr><td>2</td><td>{a,c}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>3</td><td>{a,c,b}</td><td>20</td><td>3</td><td>8</td><td>20</td></tr><tr><td>4</td><td>{a,c,b,d}</td><td>20</td><td>3</td><td>8</td><td>14</td></tr></tbody></table><p>用一个表格记录更新完最短距离表格后的目标地点的上一个节点</p><table><thead><tr><th>次数</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>2</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>3</td><td>a</td><td>a</td><td>c</td><td>a</td></tr><tr><td>4</td><td>a</td><td>a</td><td>c</td><td>d</td></tr></tbody></table><p>阐述下这个过程</p><p>首先，我们将A到各个其他点的距离记录进去，接着按<strong>初始距离从短到长</strong>的顺序将a,b、a,c、a,d这三个当作一个整体去更新表格(注意：这里不是简单的就是a→b，而是他们之间的最短路径)</p><p>记住，每次我们都从最短的路径入手，比如a到c的距离最短，那么我们就从该点c入手，其次就是在b和d中选择</p><p>比如在接下来，我们把a→c当作一个整体，它的默认权重为3，然后去对比其他各个点，注意看图，根据结果去刷新最短距离，比如c到e的距离是30，加上默认权重（a→c）3，是33，比a直接到达e还远，所以我们不更新该距离，以及c的最短距离的上一个节点还是a，其他类似，每一步更新完，即可得出起点到达该点的最短距离了</p><p>我们重点看下第三次和第四次，在第三次，a到b，c还是不变，但是c可以直接到d了,也就是说，在原先的基础a到c的距离3上加5，得出该距离为8，同时途径点可以更新为c</p><p>第四次，我们发现d到e的距离为6，加上a到d的最短距离8可以达到14，比a直接过去还短，所以我们更新表格，最短距离为14，上个节点为e</p><p>我们可以看到这样的规律，如果当前节点pass到终点end的距离(passEnd)加上起点start到当前节点pass的距离(startPass)小于默认起点start到终点end的距离(startEnd)，那么就更新表格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果startPass + passEnd &lt; startEnd</span><br><span class="line">则startEnd = startPass + passEnd（更新）</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>我们用一个对象来存储当个点到其他点的距离，比如下面</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    instance: 20,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    instance: 3,</span><br><span class="line">    process: a</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个函数来格式化该操作，data为数组数据，startPoint为起点，targetPoint为终点集合（数组），格式完数据后，我们把起点到起点的数据删掉，因为该点并没有什么用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接着，我们用另一个对象把所有数据包裹起来，</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   起点1:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2: &#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;,</span><br><span class="line">   起点2:&#123;</span><br><span class="line">     目标地点1:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;,</span><br><span class="line">     目标地点2:&#123;</span><br><span class="line">       instance: 距离,</span><br><span class="line">       process: [途径地点]</span><br><span class="line">     &#125;...</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现该操作的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对比长度的函数，通过前面的介绍我们可以知道这个过程的实现，无需多言，直接看代码，入参含义为（数组数据，起点名称，当前点名称，终点名称）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>主函数入口：最主要的就是迭代，对每个点进行迭代执行analyse函数，再对每个点下的终点距离进行遍历判断</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>将结果进行描述的函数，在这里对于算法来说没啥用处，主要就是结果的文字展示</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>拿前面的数据进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = dijkstra(data, <span class="string">'a'</span>, [<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br><span class="line"><span class="keyword">let</span> res1Text = roadPoint(res1, <span class="string">'e'</span>) <span class="comment">//文字描述</span></span><br><span class="line"><span class="built_in">console</span>.log(res1Text);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src= "/img/loading.gif" data-src="/2021/10/06/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/image-20220219164513219.png" alt="image-20220219164513219"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化每条数据，默认距离为无穷大，上一节点为起始点startPoint</span></span><br><span class="line">  targetPoint.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      res[i] = &#123;</span><br><span class="line">        instance: <span class="number">99999</span>,</span><br><span class="line">        process: startPoint,</span><br><span class="line">        target: i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历数据，赋值已有最近临点初始距离</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i[<span class="number">1</span>]] &amp;&amp; i[<span class="number">0</span>] == startPoint) &#123;</span><br><span class="line">      res[i[<span class="number">1</span>]].instance = i[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  res[startPoint] &amp;&amp; <span class="keyword">delete</span> res[startPoint] <span class="comment">//删除起点（无用）</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立全部数据的散列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointDistanceHashTable</span>(<span class="params">data, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 对所有点进行遍历并初始化</span></span><br><span class="line">  targetPoint.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">    res[i] = init(data, i, targetPoint)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两者距离长度，会改变data，返回最新结果</span></span><br><span class="line"><span class="comment">// 参数：数据initData, 起点名称，当前点名称，终点名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longer</span>(<span class="params">initData, start, pass, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newDistance = initData[start][pass].instance + initData[pass][end].instance</span><br><span class="line">  <span class="keyword">if</span> (newDistance &lt; initData[start][end].instance) &#123;</span><br><span class="line">    initData[start][end].instance = newDistance</span><br><span class="line">    initData[start][end].process = pass</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initData[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按距离从小到大进行排序，传入对象（数组），返回数组，会改变原数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(data <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      arr.push(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.instance - b.instance</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪杰斯特拉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params">data, startPoint, targetPoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allPoint = <span class="keyword">new</span> <span class="built_in">Set</span>([...targetPoint, startPoint])</span><br><span class="line">    <span class="comment">// 获取全部点的散列表</span></span><br><span class="line">  <span class="keyword">let</span> initData = pointDistanceHashTable(data, allPoint);</span><br><span class="line">  <span class="comment">// 将起点单独提取出来，用于遍历, 大小比较</span></span><br><span class="line">  <span class="keyword">let</span> startPointData = initData[startPoint];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按初始路径长短顺序进行路径分析</span></span><br><span class="line">  <span class="keyword">return</span> (analyse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPointData.length == <span class="number">0</span>) &#123;</span><br><span class="line">      initData[startPoint].start = startPoint <span class="comment">//给他一个名字</span></span><br><span class="line">      <span class="keyword">return</span> initData[startPoint]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startPointData = sortData(startPointData) <span class="comment">//排序</span></span><br><span class="line">      <span class="comment">// 遍历更新数据</span></span><br><span class="line">      <span class="keyword">for</span> (next <span class="keyword">in</span> initData[startPointData[<span class="number">0</span>].target]) &#123;</span><br><span class="line">        <span class="comment">// 排除掉绕圈</span></span><br><span class="line">        <span class="keyword">if</span> (next != startPoint) &#123;</span><br><span class="line">          <span class="comment">// 更新掉initData的数据</span></span><br><span class="line">          longer(initData, startPoint, startPointData[<span class="number">0</span>].target, next)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      startPointData.shift() <span class="comment">//移除当前数据</span></span><br><span class="line">      <span class="comment">// 继续迭代</span></span><br><span class="line">      <span class="keyword">return</span> analyse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 途径函数，传入算法计算结果的数据，以及要到达的终点，返回文字提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roadPoint</span>(<span class="params">data, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data[end]) <span class="keyword">return</span> <span class="string">'无到达该点的最短距离数据'</span></span><br><span class="line">  <span class="keyword">let</span> pass = [end]</span><br><span class="line">  <span class="keyword">let</span> instanceText = <span class="string">'从'</span> + data.start + <span class="string">'到'</span> + end + <span class="string">'的距离为'</span> + data[end].instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">get</span> = function(end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[end].process == data.start) &#123;</span><br><span class="line">      pass.unshift(data.start)</span><br><span class="line">      <span class="keyword">return</span> instanceText + <span class="string">',完整路径为'</span> + pass</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pass.unshift(data[end].process)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">get</span>(data[end].process)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法</li><li>狄克斯特拉算法用于在加权图中查找最短路径。 </li><li>仅当权重为正时狄克斯特拉算法才管用。 </li><li>如果图中包含负权边，请使用贝尔曼福德算法。</li></ol>]]></content>
    
    <summary type="html">
    
      迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广度优先搜索</title>
    <link href="http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://dong-666.github.io/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2021-10-01T12:00:00.000Z</published>
    <updated>2022-03-02T08:26:26.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>宽度优先<a href="https://baike.baidu.com/item/搜索算法/2988274" target="_blank" rel="noopener">搜索算法</a>（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra<a href="https://baike.baidu.com/item/单源最短路径/6975204" target="_blank" rel="noopener">单源最短路径</a>算法和Prim<a href="https://baike.baidu.com/item/最小生成树" target="_blank" rel="noopener">最小生成树</a>算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>广度优先搜索的运行时间为O(顶点 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数</p><p>对于检查过的人（顶点），务必不要再去检查，否则可能导致无限循环</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ol><h2 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h2><p>有向图是单向的</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904144514052.png" alt="image-20210904144514052"></p><p>无向图没有箭头，直接相连的节点互为邻居，无向图相邻的两个结点彼此指向对方，其实就是一个环，跟上图一样</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>有这么一个人员数据表，他们都有各自的<strong>职业</strong>和<strong>邻居</strong>，假设你是其中一个人：a——工地搬砖工。有一天，你想吃新鲜的蔬菜，但是你不相信陌生人，所以你打算问你的邻居，看看有没有什么认识的人（职业为农民）可以提供保证新鲜的蔬菜给你，如何操作呢（下面为思路）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'worker'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>],</span><br><span class="line">    profession: <span class="string">'panter'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    neighbor: [<span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'teacher'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    neighbor: [<span class="string">'c'</span>, <span class="string">'e'</span>],</span><br><span class="line">    profession: <span class="string">'doctor'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  e: &#123;</span><br><span class="line">    neighbor: [<span class="string">'d'</span>],</span><br><span class="line">    profession: <span class="string">'police'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  f: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    profession: <span class="string">'farmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  g: &#123;</span><br><span class="line">    neighbor: [<span class="string">'b'</span>],</span><br><span class="line">    profession: <span class="string">'programmer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据广度优先搜素算法，我们首先根据各个人员的邻居构建出图模型</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/image-20210904145548745.png" alt="image-20210904145548745"></p><p>接着就是从你（a）自己入手，首先你从b和c开始找起，如若b和c就是农民，那么久返回该对象的名字,我们可以将这两人压入待查找数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c];</span><br></pre></td></tr></table></figure><p>b如果不是，那么就把b的邻居加入数组，一起找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b,c,a,f,g];</span><br></pre></td></tr></table></figure><p>同时把b弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c,a,f,g];</span><br></pre></td></tr></table></figure><p>当然，a也不是，否则查找会造成循环，不断去找a，所以一开始我们需要定义一个数组用以存储已查过的对象，然后每次查完一个放进一个，后面的每次查找待找数组时在已查找数组中查看是否已查过，是则把该值从待找数组中丢掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finded = [<span class="string">'a'</span>];</span><br></pre></td></tr></table></figure><p>继续上面几个步骤，对后面的数据进行查找↓</p><p>接下来是c，c也不是，所以把c的邻居也加进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,f,g,a,f,d];</span><br></pre></td></tr></table></figure><p>重复这几个步骤，直到找出最终的结果</p><p>方法代码如下</p><p><img src= "/img/loading.gif" data-src="/2021/10/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/carbon.png" alt="carbon"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>广度优先搜索指出是否有从A到B的路径。</li><li>如果有，广度优先搜索将找出最短路径。</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来 解决问题。</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 </li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约 会，而rachel也与ross约会”。</li><li>队列是先进先出（FIFO）的。 </li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必 须是队列。 </li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环。</li></ol>]]></content>
    
    <summary type="html">
    
      宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://dong-666.github.io/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2021-08-30T08:00:00.000Z</published>
    <updated>2022-03-02T08:26:48.472Z</updated>
    
    <content type="html"><![CDATA[<p>必看：<a href="https://zhuanlan.zhihu.com/p/95156642" target="_blank" rel="noopener">来吧！一文彻底搞定哈希表！</a></p><p>进阶：<a href="https://baike.baidu.com/item/哈希表/5981869?fr=aladdin" target="_blank" rel="noopener">哈希表_百度百科 (baidu.com)</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/散列函数/2366288" target="_blank" rel="noopener">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>叫做<a href="https://baike.baidu.com/item/散列表/10027933" target="_blank" rel="noopener">散列表</a>。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20210904161554231.png" alt="image-20210904161554231"></p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>一种功能强大的数据结构，其操作速度快，还能以不同的方式建立数据模型</li><li>一种包含额外逻辑的数据结构</li><li>也被称为散列映射、映射、字典和<br>关联数组</li><li>散列表的查找、插入和删除速度都非常快</li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>查找（模拟映射关系）</li><li>防止重复</li><li>用作缓存</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="什么是冲突"><a href="#什么是冲突" class="headerlink" title="什么是冲突"></a>什么是冲突</h4><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/image-20220216142535367.png" alt="image-20220216142535367"></p><blockquote><p>冲突很糟糕，应使用可以最大限度减少冲突的散列函数</p></blockquote><p>避免方法：</p><ol><li>较低的填装因子<ul><li>填装因子越低，发生冲突的可能性越小，<br>散列表的性能越高</li><li>经验：一旦填装因子大于0.7，就调整散列表的长度</li><li>虑到调整长度所需的时间，散列表操作所需的时间也为O(1)</li></ul></li><li>良好的散列函数<ul><li>良好的散列函数让数组中的值呈均匀分布</li><li>糟糕的散列函数让值扎堆，导致大量的冲突</li><li>散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置</li></ul></li></ol><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol><li>散列函数总是将同样的输入映射到相同的索引。</li><li>散列函数将不同的输入映射到不同的索引。</li><li>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100</li></ol><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="伪散列函数查找商品价格"><a href="#伪散列函数查找商品价格" class="headerlink" title="伪散列函数查找商品价格"></a>伪散列函数查找商品价格</h3><p>功能：</p><ol><li>添加商品及其价格</li><li>输入商品，得到其价格</li></ol><p>思路：</p><ol><li>使用类存储</li><li>获取商品价格方法<ul><li>通过遍历已有商品得到其价格并返回出去</li></ul></li><li>添加商品方法<ul><li>通过添加商品将该数据添加到对象中</li></ul></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/6130935fe401fd1fb6a2dfb5.png" alt="6130935fe401fd1fb6a2dfb5"></p><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h3><p>该散列表默认按照最高长度为24来进行字符串存储</p><p>slots用于初始化散列表时的数据存储</p><ul><li>add方法<ul><li>得到当前传入值的字符串长度</li><li>判断当前长度对应的数组位置是否还未开辟出新的数组，是则开辟出新的内存地址</li><li>将当前字符串添加到散列表（slots）中去</li></ul></li><li>delete方法<ul><li>从散列表中查找该字符串长度对应的数组位置</li><li>获得该元素在该数组（对应字符串长度的数组）中的<strong>位置</strong></li><li>将该数据从散列表中数组对应的位置删除</li></ul></li><li>get方法<ul><li>通过<strong>过滤函数（filter）</strong>将数据从散列表中取出来，并返回该值</li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2021/08/30/%E6%95%A3%E5%88%97%E8%A1%A8/613095421efad40d9391d4ad.png" alt="613095421efad40d9391d4ad"></p>]]></content>
    
    <summary type="html">
    
      是根据关键码值(Key value)而直接进行访问的一种数据结构
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js原型小记（大记）</title>
    <link href="http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://dong-666.github.io/2021/08/22/%E5%8E%9F%E5%9E%8B/</id>
    <published>2021-08-22T08:00:00.000Z</published>
    <updated>2022-03-04T08:44:41.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型、原型链、-proto-、prototype"><a href="#原型、原型链、-proto-、prototype" class="headerlink" title="原型、原型链、__proto__、prototype"></a>原型、原型链、__proto__、prototype</h1><blockquote><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p></blockquote><p>也就是说，在js中，我们是可以通过克隆创造世界，看下面的代码，首先我们创建一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个构造函数，暂且将它想象成类，然后我们来new一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>我们创造了一个admin对象，接着，如果有一个admin和上面所创造的对象同名同年龄时，我们该怎么创建呢，有人说：这还不简单嘛，再new一个不就得了，确实，在这里new一个难度不大，但当我们构造同一个对象需要的参数很多时，那又该怎么办，按着原来的参数继续new吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, height, weigt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.height = height,</span><br><span class="line">  <span class="keyword">this</span>.weight = weight,</span><br><span class="line">  <span class="comment">//... 还有其它很多的属性</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经创建了一个对象</span></span><br><span class="line"><span class="keyword">let</span> admin = <span class="keyword">new</span> User(<span class="string">'Admin'</span>, <span class="number">18</span>,<span class="number">177</span> ,<span class="number">110</span>,...)</span><br><span class="line"><span class="comment">// 要再创建同个对象</span></span><br></pre></td></tr></table></figure><p>这样的参数要我们一个一个填进去，但我们已经新建了一个完全的一样的对象，而且这样子做还要防止参数一不小心填错导致对象不同</p><p>所以我们采用克隆的方式来创造一个一模一样的对象，ECMAScript 5提供了Object.create 方法，可以用来克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneAdmin = <span class="built_in">Object</span>.create( admin);</span><br></pre></td></tr></table></figure><p>这，便是js的克隆，在这时候，cloneAdmin.__proto__会指向admin，__proto__是啥，后面我们会提到，这里你只需要知道，这时候的cloneAdmin已经继承admin几乎所有属性包括方法了</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>我们再来了解下原型和原型链，什么是原型，就像上面举的例子，cloneAdmin是通过admin克隆而来的，那么它的原型便是admin，如果现在有一个对象clone2，克隆自cloneAdmin，那么clone2的原型便是cloneAdmin，而从它到admin这一条线上的所有对象便是原型链</p><blockquote><p>js的继承：基于原型链的委托机制就是原型继承的本质</p></blockquote><p>如何理解这句话，我们继续上面的例子，现在cloneAdmin克隆自admin，那么它是可以使用admin的所有属性和方法的，前提是它没有覆盖掉原型的方法，这类似于我们学习其它语言的继承特性</p><p>所以我们也就可以知道：<strong>当对象无法响应某个请求时，会把该请求委托给它自己的原型</strong></p><p>所以，通过以上，可以得出：原型编程范型至少包括以下基本规则</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><h2 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h2><p>JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。</p><p>在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。</p><h2 id="JS的克隆"><a href="#JS的克隆" class="headerlink" title="JS的克隆"></a>JS的克隆</h2><p>JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。</p><h2 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h2><p>JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。</p><p>__proto__就是对象跟“对象构造器的原型”联系起来的纽带。（__proto__：指向该对象的构造函数的原型对象，prototype指向该构造函数的原型对象——来自<a href="https://www.zhihu.com/question/34183746/answer/58155878" target="_blank" rel="noopener">知乎</a>，强烈建议阅读该文章）</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><h2 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h2><p>JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。</p><p>如：我们可以创建一个无原型的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一参数为原型指向，第二个为对象属性编辑</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'hhh'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原型链并不是无限长的，当对象通过原型链找某个属性找到根节点而找不到时，则会返回undefined（Object.prototype 的原型是 null）</p><h1 id="基于原型的继承以及constructor"><a href="#基于原型的继承以及constructor" class="headerlink" title="基于原型的继承以及constructor"></a>基于原型的继承以及constructor</h1><p>通过上面，我们可以知道继承是可以通过原型实现，通过上面的继承原型图，我们进行相应的练习</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg?source=1940ef5c" alt="img"></p><p>首先创建构造函数User</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getDetail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，我们新建一个对象zhangsan</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>现在我们想新建另一个对象李四，让它直接继承于张三（也就是张三的儿子），我们可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zhangsan = <span class="keyword">new</span> User(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> lisi = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(lisi, zhangsan)</span><br><span class="line">lisi.name = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure><p>ok，这样我们就简单的实现了继承，然后，提出一个问题，张三、李四以及构造函数User之间的关系是怎样的（通过上图理解）</p><p>弄清楚之后，你便会对__proto__、prototype、原型继承、原型和原型链有了更深刻的理解(下面是答案，记住一点，prototype是构造函数独有的，对象并没有这个属性，且这个属性指向构造函数原型)</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt="原型继承"></p><p>通过这张图，我们也可以知道</p><p><code>User.prototype.constructor() === User()</code></p><p>也就是说，你也可以通过<code>new User.prototype.constructor()</code>创建对象，当然正常人不会这样做（麻烦）</p><h1 id="构造函数-对象的原型检测"><a href="#构造函数-对象的原型检测" class="headerlink" title="构造函数/对象的原型检测"></a>构造函数/对象的原型检测</h1><p>我们想要对某一个对象的原型进行判断，有两种方法，一种是通过判断构造函数，另一种则是直接判断对象</p><p>首先我们声明三个类、定义它们间的关系以及实例化出各自的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">B.prototype = a</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line">C.prototype = b</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br></pre></td></tr></table></figure><ol><li><p>instanceof方法（构造函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> A)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> B)</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> C)</span><br></pre></td></tr></table></figure><p>结果都为真</p></li><li><p>dad isPrototypeOf(son)（对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(b))</span><br><span class="line"><span class="built_in">console</span>.log(b.isPrototypeOf(c))</span><br><span class="line"><span class="built_in">console</span>.log(a.isPrototypeOf(c))</span><br></pre></td></tr></table></figure><p>结果也都为真</p></li></ol><p>两个方法都会循着原型链向上找，唯一不同的便是instanceof需要传入构造函数，而另一个方法则是传入对象</p><h1 id="原型链中的对象遍历"><a href="#原型链中的对象遍历" class="headerlink" title="原型链中的对象遍历"></a>原型链中的对象遍历</h1><p>首先胡乱设置两个对象，同时这两个对象有继承关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">  A() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我叫"</span> + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  age: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.__proto__ = a</span><br></pre></td></tr></table></figure><p>好的，也就是说a是b的爸爸，然后我们来遍历一下b对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是什么(name 、age、A())</p><p>由此我们可以得出：in遍历是会遍历出包含原型链上其它原型的属性方法，那么如果我们只是想要遍历b独有的方法呢</p><p>这时候可以利用hasOwnProperty()方法去判断方法属性是否属于当前调用对象独有的，使用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被检测对象.hasOwnProperty(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure><p>所以我们就可以使用for_in循环遍历出当前对象的属性方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">  <span class="comment">// 判断当前属性是否为当前对象独有</span></span><br><span class="line">  <span class="keyword">if</span> (b.hasOwnProperty( key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出的结果就是b自己独有的属性方法啦</p><h1 id="借用其他原型链方法"><a href="#借用其他原型链方法" class="headerlink" title="借用其他原型链方法"></a>借用其他原型链方法</h1><p>现在我们有个数组arr，当有个需求要我们求出这个数组的最大值时，你会咋做嘞</p><p>有些人可能会这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>也有可能这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">v, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt; v ? c : v</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>但是嘞，这些都是基于数组原型的方法实现的，声明的数组类型本来就是指向该原型的，那如果这时候我想调用Math里面的方法去实现这一需求，Math.max()方法不需要上面那么复杂的逻辑实现，更简单有木有，但是要如何做呢</p><p>这时候我们就要用到apply或call方法啦（两个函数都可以改变方法的this指向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><p>这样得出来的结果也是一样的，更简单明了是不，他的原理便是改变原函数max的指向，使得我们可以调用不处于同一条原型链的其它对象的方法</p><p>再来一个例子，我们利用数组的过滤来对Dom进行操作，需求是这样的：给出两个input控件，我们想要获得指定的控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"我是a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"我是b"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想要获得name=a的元素，怎么做呢，很简单：1.获取所有input控件 2.调用数组的filter方法进行过滤筛选</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = <span class="built_in">document</span>.querySelectorAll(<span class="string">'[v-model]'</span>)</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Array</span>.prototype.filter.call(ts, e =&gt; e.getAttribute(<span class="string">'name'</span>) === <span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//下面的方法也行</span></span><br><span class="line"><span class="comment">// let res = [].filter.call(ts,e =&gt; e.getAttribute('name') === 'a')</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>].value)</span><br></pre></td></tr></table></figure><h1 id="构造函数原型方法和构造函数内的方法"><a href="#构造函数原型方法和构造函数内的方法" class="headerlink" title="构造函数原型方法和构造函数内的方法"></a>构造函数原型方法和构造函数内的方法</h1><p>从前面我们可以知道，用构造函数实例化出来的对象，他的原型是构造函数的prototype属性，那么当我们给构造函数的prototype对象添加方法时，这个实例化出来的对象也可以使用该方法，那要是将一个对象的__proto__指向该构造函数的prototype时，它是否可以使用构造函数内部定义的方法呢，让我们看一下</p><p>首先定义一个构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> User = <span class="function"><span class="keyword">function</span>(<span class="params">name, age= <span class="number">18</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给它的原型新增方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个对象，并分别调用构造函数内的方法和构造函数prototype的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">'user1'</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1.getAge())</span><br><span class="line">user1.getName()</span><br></pre></td></tr></table></figure><p>结果都可以正常显示</p><p>接着我们直接定义另一个对象，并强制将其原型指向User.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = &#123;&#125;</span><br><span class="line">user3.__proto__ = User.prototype</span><br></pre></td></tr></table></figure><p>调用getAge()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user3.getAge())</span><br></pre></td></tr></table></figure><p>正常显示，调用getName()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user3.getName()</span><br></pre></td></tr></table></figure><p>无法执行，程序报错，显示该错误：user3.getName is not a function</p><p>所以由此我们可以得出，构造函数内部定义的方法，只有在由他实例化出来的对象才会得到，而将一个自定义对象原型指向该构造函数的prototype对象时，是无法使用该构造函数内部的方法的，但是毫无疑问的，它可以使用该构造函数的prototype对象内的方法</p><h1 id="设置和获得原型"><a href="#设置和获得原型" class="headerlink" title="设置和获得原型"></a>设置和获得原型</h1><p>上面我们可以知道，设置对象的原型可以直接使用obj.__proto__属性强制绑定，下面是Object自带的两个方法进行原型设置以及获得当前对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置原型</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(son, dad)</span><br></pre></td></tr></table></figure><p>该方法和son.__proto__ = dad一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(son)</span><br></pre></td></tr></table></figure><p>使用该方法即可获得他爹了</p><h1 id="proto-原理（get、set）"><a href="#proto-原理（get、set）" class="headerlink" title="__proto__原理（get、set）"></a>__proto__原理（get、set）</h1><p>不知道你们有没有试过，将对象的__proto__属性定义成出对象外的其它值类型数据是不可行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;&#125;</span><br><span class="line">obj.__proto__ = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这样是没有任何效果的，为什么呢，因为__proto__实际上是访问器(get/set)构造而成的，他会对设置的值进行过滤，只有符合对象类型的数据，它才会赋值，让我们来仿造一个，了解其实质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Obj  = &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> _proto_() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.obj</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> _proto_(e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Obj._proto_ = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj._proto_);</span><br></pre></td></tr></table></figure><p>核心代码便是<code>e instanceof Object</code>，即判断当前传入类型是否为对象，是则赋值成功，否则忽略该赋值</p><h1 id="基于原型面向对象的多态"><a href="#基于原型面向对象的多态" class="headerlink" title="基于原型面向对象的多态"></a>基于原型面向对象的多态</h1><p>js也可以多态，你没骗我吧，没有的事呢，那就让我们来看看js的多态究竟是个啥</p><p>假设现在有个情况，你家里来客人了，你爸叫你和你妹跟客人打招呼，你说了句“叔叔好，我是我爸的儿子jie（假设你叫jie）”，你妹说：“叔叔好，我是我爸的女儿hua（假设你妹叫hua）”</p><p>看到没有，同样的一个行为，哥哥和妹妹的表现是不同的，这便是多态。让我们用代码实现一下</p><p>首先定义爸爸构造函数，然后 给爸爸原型定义一个介绍的方法（毕竟指令由爹地发出的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.introduction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.show());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着构造儿子，并继承于老爸，然后定义儿子的介绍方法show()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使得Son.prototype.__proto__指向Father.prototype</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Son.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是儿子'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来就是女儿，和儿子一样，但是其show()方法和儿子有所不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Daughter.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Daughter.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我是女儿'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是实例化一个儿子和女儿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jie = <span class="keyword">new</span> Son(<span class="string">'jie'</span>)</span><br><span class="line"><span class="keyword">let</span> hua = <span class="keyword">new</span> Daughter(<span class="string">'hua'</span>)</span><br></pre></td></tr></table></figure><p>假设此时他们接收到了父亲的指令，于是乎分别调用introduction方法并介绍自己</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jie.introduction() <span class="comment">//我是儿子jie</span></span><br><span class="line">hua.introduction() <span class="comment">//我是女儿hua</span></span><br></pre></td></tr></table></figure><p>这便是js的多态实现</p><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>没啥好说的，就是继承父类的方法，但是由自己的实现方式，需要重新定义，这便是重写，直接理解代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个father构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建son对象</span></span><br><span class="line"><span class="keyword">let</span> son = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化爹地</span></span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 让son的原型指向爹地对象</span></span><br><span class="line">son = <span class="built_in">Object</span>.create(father);</span><br><span class="line">son.hi()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写son方法</span></span><br><span class="line">son.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'son hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">son.hi();</span><br></pre></td></tr></table></figure><h1 id="禁止自定义函数原型的constructor被遍历"><a href="#禁止自定义函数原型的constructor被遍历" class="headerlink" title="禁止自定义函数原型的constructor被遍历"></a>禁止自定义函数原型的constructor被遍历</h1><p>之前我们已经了解过consructor，它是构造函数原型里面指向构造函数的一个属性，如下，两者是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.constructor === User</span><br></pre></td></tr></table></figure><p>但当我们想让一个构造函数的原型继承于另一个构造函数时，会发生一点意外</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Father.prototype.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'father hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'son'</span></span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br></pre></td></tr></table></figure><p>在这里面，我们让Son的prototype原型指向Father.prototype，看起来好像一切都正常，也不影响继承，但是仔细观察你会发现，里面的constructor不见了，通过打印<code>console.dir(Son.prototype)</code>，我们可以发现它的constructor确实不见了</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528202637586.png" alt="image-20210528202637586"></p><p>这会造成什么问题，你会无法通过下列方法实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son.prototype.constructor();</span><br></pre></td></tr></table></figure><p>所以，为了避免它原先的constructor丢失造成的问题，我们需要把它纠正回来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure><p>OK啦，只要在每次继承之后加上这句代码，就可以防止constructor丢失了，但其实在这里，还会有一个问题，让我们来遍历一下这个原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> Son.prototype) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到什么结果：hi以及constructor，我们希望constructor出现吗，并不会，我们希望这些原本对象自带的属性是隐藏且不可遍历的，但是在这里，我们将原本丢失的自带构造器添加上去，导致其暴露并可以遍历出来，所以我们要将其可枚举的属性设置为false，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，最后，当我们需要构造函数继承时，需要以下三个步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承</span></span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复原有构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 禁止自定义函数原型的constructor被遍历</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Son.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Son,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="父类构造函数初始化属性"><a href="#父类构造函数初始化属性" class="headerlink" title="父类构造函数初始化属性"></a>父类构造函数初始化属性</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>， 我今年<span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>岁了`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我们定义的一个父类构造函数，也就是说，有一个构造函数会继承它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如何正确继承，哎对了，三步走实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Admin.prototype = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line"></span><br><span class="line">Admin.prototype.constructor = Admin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Admin.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Admin,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，我们现在想让Admin不用自定义的同时也可以同User一样初始化对象（name、age），怎么实现呢</p><p>前面有讲过的，改变User的this指向不就可以实现了吗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  User.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过args传值同时改变User实例化的this指向，从而实现Admin同User一样初始化属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mayun = <span class="keyword">new</span> Admin(<span class="string">'mayun'</span>, <span class="number">22</span>);</span><br><span class="line">mayun.show();</span><br></pre></td></tr></table></figure><p>正确输出啦</p><h1 id="原型工厂封装属性"><a href="#原型工厂封装属性" class="headerlink" title="原型工厂封装属性"></a>原型工厂封装属性</h1><p>每次对构造函数原型进行继承，都要三步走，是不是有点麻烦，要是多个构造函数原型都要继承，岂不是要写很多次，所以我们把它给封装了吧，这样每次就可以直接调用啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">child, dad</span>) </span>&#123;</span><br><span class="line">  child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">    value: child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装后的函数也称为原型工厂，我们来看看它的使用方法把</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Son, Father);</span><br></pre></td></tr></table></figure><p>OK，这样子每次继承就不会很麻烦了，直接调用该函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(Daughter, Father);</span><br></pre></td></tr></table></figure><h1 id="对象工厂派生对象实现继承"><a href="#对象工厂派生对象实现继承" class="headerlink" title="对象工厂派生对象实现继承"></a>对象工厂派生对象实现继承</h1><p>我们之前已经了解过Object.create()可以实现对象继承，现在让我们来封装一个函数，来理解下构造函数实例化对象的原理，从而实现继承吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' is '</span> + <span class="keyword">this</span>.age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有这么一个构造函数，我们想用它创造出许多子对象（类似于构造函数初始化），如何实现呢</p><p>第一步便是克隆出构造函数原型对象（creat）</p><p>第二步初始化对象(call、apply（前面刚讲过）)</p><p>第三步便是返回这个对象啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象工厂造对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(User.prototype);</span><br><span class="line">  User.call(instance, name, age);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来实例化看看吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dy = admin(<span class="string">'dy'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dy.show())</span><br></pre></td></tr></table></figure><p>成功！</p><h1 id="使用mixin实现多继承"><a href="#使用mixin实现多继承" class="headerlink" title="使用mixin实现多继承"></a>使用mixin实现多继承</h1><p>在上面，我们了解到了可以借用其他原型链上的方法满足需求，但有没有其它方式可以使用其它原型链的方法呢。</p><p>“这个我知道，继承那个原型不就好嘛”，哎哟，好像有点道理哦，但这样却可能会导致继承的混乱。</p><p>我们知道，原型链为线形的，也就是说，你只能单向继承，大白话就是你只能有一个亲生爸爸，而如果这时候，跟上面的需求一样，arr数组想用Math对象中的方法时怎么办，</p><p>有小朋友提到了，我可以让Math当Array的爸爸嘛，这样顺着一条原型链上去就能实现方法了嘛，是的没错，但你有没有想过在这个过程中，只是你一个数组需要用到Math中的方法，如果其他数组不需要呢，那么它们也没办法，依然会被绑定到这条原型链上，这样就会造成这条原型链混乱且复杂。</p><p>我们更加希望，事物是有序的，一条继承链下来，对象之间都是有需求的，都是相关联且合理的，所以，这个方法并不可取</p><p>那么有什么方法可以实现这一需求呢：mixin思想，我们使用混入来实现类似多继承的效果，从而使得原原型链（主干）不受影响</p><p>这里要用到Object的一个方法实现类似mixin的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj1, obj2);</span><br></pre></td></tr></table></figure><p>首先创造一个事物构造函数还有其原型的一个方法show</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我叫`</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创造两个事物构造函数分别继承它，extend详见上面的原型工厂继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Human, Thing);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Thing.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extend(Car, Thing);</span><br></pre></td></tr></table></figure><p>然后实例化对象并验证下是否继承到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohong = <span class="keyword">new</span> Human(<span class="string">'xiaohong'</span>);</span><br><span class="line">xiaohong.show();</span><br><span class="line"><span class="keyword">let</span> benchi = <span class="keyword">new</span> Car(<span class="string">'banchi'</span>);</span><br><span class="line">benchi.show();</span><br></pre></td></tr></table></figure><p>很幸运，可以使用父类方法展示自己（我叫xiaohong，我叫banchi）</p><p>然后我们创建一个行为类action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我跑'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'给我叫'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想让benchi和xiaohong都能使用这个类中的方法，但是他们已经有爹地了，这时候我们用mixin思想实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(benchi, action);</span><br><span class="line"><span class="built_in">Object</span>.assign(xiaohong, action);</span><br></pre></td></tr></table></figure><p>然后就执行方法吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">benchi.move(); <span class="comment">//banchi给我跑</span></span><br><span class="line">xiaohong.call(); <span class="comment">//xiaohong给我叫</span></span><br></pre></td></tr></table></figure><p>成功！我们实现了类似多继承</p><h1 id="mixin的内部继承以及super"><a href="#mixin的内部继承以及super" class="headerlink" title="mixin的内部继承以及super"></a>mixin的内部继承以及super</h1><p>还是依照上面的例子，我们想让mixin内部的对象实现继承且，banchi和xiaohong可以调用得到，如何实现嘞</p><p>假设有个todo类，想让它当action的爸爸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todo = &#123;</span><br><span class="line">  doing() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'在 '</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实还是和前面一样的继承，让action的__proto__继承todo即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.__proto__ = todo;</span><br></pre></td></tr></table></figure><p>这样便成功继承，然后我们稍微修改下action里面的方法，使得它可以调用父类todo的方法，这里我们用到<strong>super</strong>关键字</p><blockquote><p>super === this(action).__proto__（this指<strong>当前定义</strong>的对象）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = &#123;</span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'跑'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.show() + <span class="string">'，我'</span> + <span class="keyword">super</span>.doing() + <span class="string">'叫'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后同上面一样运行一下，结果也是正常显示啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(benchi.move());</span><br><span class="line"><span class="built_in">console</span>.log(xiaohong.call());</span><br></pre></td></tr></table></figure><p>我们来看一下他们之间的继承关系（可以多画画这种继承图帮助理解）</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/mixin%E6%8C%87%E5%90%91.png" alt="mixin指向"></p><p>好哒，这一部分我们就了解了mixin内部继承以及super代替原型（son.__proto__）这两个重要的知识点啦</p><h1 id="继承操作Dom（综合案例）"><a href="#继承操作Dom（综合案例）" class="headerlink" title="继承操作Dom（综合案例）"></a>继承操作Dom（综合案例）</h1><p>现在有这样一个需求，我们有三个几乎一样的组件，我们想让他们的功能一致，只是样式稍微不同而已，如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214206292.png" alt="image-20210528214206292"></p><p>三者都是点击切换按钮切换状态语且改变背景颜色，点击隐藏，下面的状态语模块消失，同时按钮提示语改变，开始动手吧</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210528214431075.png" alt="image-20210528214431075"></p><p>样式不说，直接上核心代码</p><p>首先创造动作构造函数，并且定义三个方法——隐藏、显示、背景颜色以及提示语改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animation</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animation.prototype.hide = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animation.prototype.change = <span class="function"><span class="keyword">function</span> (<span class="params">color, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.style.backgroundColor = color;</span><br><span class="line">  <span class="keyword">this</span>.innerHTML = value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创造APP构造函数用于创建展示模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">id, data=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">  <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span><br><span class="line">    value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span><br><span class="line">    tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span><br><span class="line">  &#125;,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让它继承于动作构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extend(App, Animation);</span><br></pre></td></tr></table></figure><p>接着为两个按钮注册点击事件，同时调用父类的显示隐藏以及切换背景方法</p><p>显示隐藏切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.changeIf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span><br><span class="line">      <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态语切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.toggle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及首次打开页面的初始化方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span><br><span class="line">  <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是执行这三个方法的启动函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.toggle();</span><br><span class="line">  <span class="keyword">this</span>.changeIf();</span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以实例化对象，调用run方法啦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span><br><span class="line"> color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span><br><span class="line"> value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span><br><span class="line">&#125;);</span><br><span class="line">div1.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span><br><span class="line">div2.run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span><br><span class="line">  color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">div3.run()</span><br></pre></td></tr></table></figure><p>就算你有其它需要类似功能的模块，你也可以直接实例化该对象并执行run方法，而不用每个同功能的模块书写多次相同冗余的代码了</p><p>全部代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        margin: 5px;</span><br><span class="line">        border: 2px solid rgba(226, 121, 247);</span><br><span class="line">        height: 300px;</span><br><span class="line">        width: 500px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      *<span class="selector-attr">[name=<span class="string">"sec"</span>]</span> &#123;</span></span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 80%;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">        color: pink;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">input</span><span class="selector-attr">[name]</span> &#123;</span></span><br><span class="line">        background-color: pink;</span><br><span class="line"><span class="css">        <span class="comment">/* border: pink; */</span></span></span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 10%;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换"</span> <span class="attr">name</span>=<span class="string">"switch"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"隐藏"</span> <span class="attr">name</span>=<span class="string">"hide"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span> <span class="attr">name</span>=<span class="string">"sec"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">Animation</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="actionscript">      Animation.prototype.hide = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'none'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.display = <span class="string">'block'</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      Animation.prototype.change = <span class="function"><span class="keyword">function</span> <span class="params">(color, value)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.style.backgroundColor = color;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.innerHTML = value;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// * 原型继承工厂函数</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(child, dad)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        child.prototype = <span class="built_in">Object</span>.create(dad.prototype);</span></span><br><span class="line">        child.prototype.constructor = child;</span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(child, <span class="string">'constructor'</span>, &#123;</span></span><br><span class="line">          value: child,</span><br><span class="line"><span class="actionscript">          enumerable: <span class="literal">false</span>,</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">App</span><span class="params">(id, data=&#123;&#125;)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.div = <span class="built_in">document</span>.querySelector(id);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="switch"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="hide"]'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.sec = <span class="keyword">this</span>.div.querySelector(<span class="string">'[name="sec"]'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.data = <span class="built_in">Object</span>.assign(&#123;</span></span><br><span class="line"><span class="actionscript">          color: [<span class="string">'#8e44ad'</span>, <span class="string">'#16a085'</span>], </span></span><br><span class="line"><span class="actionscript">          value: [<span class="string">'你好'</span>, <span class="string">'再见'</span>],</span></span><br><span class="line"><span class="actionscript">          tog: <span class="literal">true</span>, <span class="comment">//用于记录切换状态</span></span></span><br><span class="line">        &#125;,data)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      extend(App, Animation);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.changeIf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnH.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.btnH.value === <span class="string">'隐藏'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.hide.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'显示'</span>;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.btnH.value = <span class="string">'隐藏'</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.toggle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.btnS.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.data.tog) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">1</span>], <span class="keyword">this</span>.data.value[<span class="number">1</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>]);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data.tog = !<span class="keyword">this</span>.data.tog;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.init = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.show.call(<span class="keyword">this</span>.sec)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.change.call(<span class="keyword">this</span>.sec, <span class="keyword">this</span>.data.color[<span class="number">0</span>], <span class="keyword">this</span>.data.value[<span class="number">0</span>])</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      App.prototype.run = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.toggle();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.changeIf();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.init()</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="keyword">new</span> App(<span class="string">'#app1'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">       color: [<span class="string">'#27ae60'</span>, <span class="string">'#2980b9'</span>],</span></span><br><span class="line"><span class="actionscript">       value: [<span class="string">'hello'</span>, <span class="string">'bye'</span>] </span></span><br><span class="line">      &#125;);</span><br><span class="line">      div1.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div2 = <span class="keyword">new</span> App(<span class="string">'#app2'</span>);</span></span><br><span class="line">      div2.run();</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div3 = <span class="keyword">new</span> App(<span class="string">'#app3'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        color: [<span class="string">'#d35400'</span>, <span class="string">'#f39c12'</span>]</span></span><br><span class="line">      &#125;)</span><br><span class="line">      div3.run()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>思维导图总结</p><p><img src= "/img/loading.gif" data-src="/2021/08/22/%E5%8E%9F%E5%9E%8B/image-20210529101210203.png" alt="image-20210529101210203"></p><p>这便是对以上全部知识点综合练习的案例了，不足之处还望批评指出，<strong>请多多指教</strong></p>]]></content>
    
    <summary type="html">
    
      来吧，快七千字的js原型笔记，好好嚼吧，😭😭😭
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://Dong-666.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://Dong-666.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-20T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:01.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-amp-C（分而治之）"><a href="#D-amp-C（分而治之）" class="headerlink" title="D&amp;C（分而治之）"></a>D&amp;C（分而治之）</h2><p>工作原理：</p><ol><li>找出简单的基线条件；</li><li>确定如何缩小问题的规模，使其符合基线条件</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>对一块400m * 640m的土地进行划分</p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165345879.png" alt="image-20210829165345879" style="zoom:50%;"><p>对于640 m × 400 m的土地，可从中划出的最 大方块为400 m × 400 m。 这将余下一块更小的土地，其尺寸为400 m × 240 m</p><p><img src= "/img/loading.gif" data-src="/2021/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210829165421947.png" alt="image-20210829165421947"></p><blockquote><p>重点：适用于这小块地的最大方块（正方形），也是适用于整块地的最大方块</p><p>这是关于“欧几里得算法”的知识</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>采用分而治之的思想进行排序，是对<a href="https://baike.baidu.com/item/冒泡排序/4602306" target="_blank" rel="noopener">冒泡排序</a>算法的一种改进</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p>1) 选择基准值。</p><p>2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 </p><p>3) 对这两个子数组进行快速排序。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>使用快速排序进行排序</p><ol><li>定义左数组存储比当前值小的值，右数组存储比当前数值大的值，以及当前比较目标值</li><li>定义基线条件：当当前传参数组索引小于等于1时，停止执行下面代码并返回当前数组</li><li>定义递归条件<ol><li>截取当前数组内要进行比较的目标值，避免参与遍历导致无限循环</li><li>进行遍历：大于当前值放至右数组，小于当前值放至左数组</li></ol></li><li>返回左数组＋当前值+右数组</li></ol><p>![carbon (1)](快速排序/carbon (1).png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 </li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 </li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n) 快得多。</li></ol>]]></content>
    
    <summary type="html">
    
      采用分而治之的思想进行排序，是对冒泡排序算法的一种改进
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://dong-666.github.io/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-12T08:00:00.000Z</published>
    <updated>2022-03-02T08:00:41.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h2><p>这里涉及的数据类型为<a href="https://blog.csdn.net/Oralinge/article/details/103585108" target="_blank" rel="noopener">引用类型</a>，计算机就像是很多抽屉的集合体，每个抽屉都有地址，当你往里面存储数据时，计算机会将每个数据存储到各自的“抽屉”去，然后用一个内存地址指向该抽屉，方便你根据内存地址去拿取你所需的值</p><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。</p><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>这里只会简单阐述数组和链表的概念，更多会讲述这两种不同数据类型的区别</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>链表是一种物理<a href="https://baike.baidu.com/item/存储单元/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/存储结构/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/数据元素/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/数据元素" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>域。 </p></blockquote><p>简单来说，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。所以，<strong>链表的优势在插入元素方面</strong>。</p><p>当你要往数组插入元素时，计算机要根据数组的长度去寻找一块连续的跟该数组长度相匹配的内存去进行存储，而链表只要存储下个元素的内存地址即可，所以即使链表中的各个数据是分开的不连续的，但还是能通过上一个数据去寻找下个数据的位置。所以在插入数据方面，链表无需考虑其他，直接往内存插入新值即可</p><p>这里举个例子，你和两个朋友去看电影，一般来说，你们三个如果关系太好了，好基友那种，分不开了，你们一般会买三张连续座位的票，从而可以坐在一起看，这便是数组，而当没有三张连续的电影票时，你们只能分开看，但可以根据电影票上的座位位置去找你的小伙伴，这便是链表。这里的座位编号便是内存地址，而你们就是一个又一个的数据。</p><p>在删除方面：链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p><strong>数组</strong>（Array）是有序的元素序列。 [1] 若将有限个类型相同的变量的<a href="https://baike.baidu.com/item/集合/2908117" target="_blank" rel="noopener">集合</a>命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为<a href="https://baike.baidu.com/item/下标变量/12713827" target="_blank" rel="noopener">下标变量</a>。用于区分数组的各个元素的数字编号称为下标。数组是在<a href="https://baike.baidu.com/item/程序设计/223952" target="_blank" rel="noopener">程序设计</a>中，为了处理方便， 把具有相同类型的若干元素按<strong>有序</strong>的形式组织起来的一种形式。  这些有序排列的同类数据元素的集合称为数组</p></blockquote><p>数组的优势：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素</p><h3 id="两者总结"><a href="#两者总结" class="headerlink" title="两者总结"></a>两者总结</h3><ul><li>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起</li><li>数组的元素都在一起</li><li>数组的读取速度比链表快</li><li>链表的插入和删除速度比数组快</li><li>在同一个数组中，所有元素的类型都必须相同</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418" target="_blank" rel="noopener">选择排序（Selection sort）</a>是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><p>有没有思考过对一组数进行排序时的过程是怎样的</p><p>比如要对【1，3，9，5，2】数组进行排序</p><ol><li>我们首先在原数组内进行比较，找出最大值，结果是9，所以我们把他放到新建数组第一个位置【9】</li><li>接着在剩下的数组遍历找出最大的值，是5，放到新数组第二个位置【9，5】</li><li>继续对剩下的三个数字进行同样操作【1，3，2】，得出最终结果【9，5，3，2，1】</li></ol><p>这便是选择排序的过程，一共需要几步呢上面，每次都对原数组进行比较排序，需要进行5趟比较，每趟比较又是和另外几个数的比较，也是5次，所以最终的所需的步数是25，也就是n²</p><blockquote><p>随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一 个。既然如此，运行时间怎么还是O(n² )呢</p><p>确实，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素 数依次为n - 1, n – 2, …, 2和1。平均每次检查的元素数为1/2 × n，因此运行时间为O(n × 1/2 × n)。 但<strong>大O表示法省略诸如1/2这样的常数</strong></p></blockquote><h2 id="选择排序实例代码"><a href="#选择排序实例代码" class="headerlink" title="选择排序实例代码"></a>选择排序实例代码</h2><ol><li><p>数组内比较使用一个函数max进行最大值获取，对数组内每个值进行遍历，找出最大值的索引，具体思路如下</p><blockquote><p>使用变量存储最大值以及最大值索引，给其赋初始值，即为数组第一个数据，接着对数组内数据进行遍历，若遍历到的数据比当前数值大，即将当前变量赋值为它，不断执行该操作，直到遍历完返回该数值索引</p></blockquote></li><li><p>对数组进行排序sort的主函数，使用新数组进行存储排序后的值，接着对原数组进行遍历和最大值查找，找出一个便在原数组删除该数据，避免引起无限循环导致内存泄漏，重复执行，直到最终结果出来</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      arr[minIndex] &gt; arr[j] &amp;&amp; (minIndex = j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一种简单直观的排序算法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://dong-666.github.io/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-08-01T08:00:00.000Z</published>
    <updated>2022-03-02T07:59:54.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</p><h2 id="简单查找"><a href="#简单查找" class="headerlink" title="简单查找"></a>简单查找</h2><p>我们在日常生活中经常会玩一个游戏：找数字</p><p>提问者给出该数字的范围，然后回答者根据这个范围进行猜数，如果比正确答案大，提问者便会说大了，如若小了，则提问者回答小了，直至猜出正确答案</p><p>比如：提问者随便想出一个数字-57，范围是0-100，回答者开始猜，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829090857846.png" alt="算法图解-简单查找"></p><p>等到他猜到57，便成功猜到正确答案了，这便是简单查找，回答者一个一个说，直到正确答案出来</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>更简单的查找方式，根据方法名即可猜到，将猜测范围一分为二，比如0-100，那么你猜50，无论是大了还是小了，你立即就可以排除掉一半的数字，接着重复一分为二的操作进行猜数，最后得出正确答案</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091346823.png" alt="image-20210829091346823"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091357416.png" alt="image-20210829091357416"></p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091407604.png" alt="image-20210829091407604"></p><p>梳理下这个猜数的过程，我们一共进行了几步</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829091706567.png" alt="image-20210829091706567"></p><p>回过头去，如果你采用暴力式简单查找，那么你猜的数字便是n（答案n）步，如果目标数字小，还好，如果是99呢，你就得猜到99才能猜到</p><p>引用书籍的另一个例子——</p><blockquote><p>假设你要在字典中查找一个单词，而该字典包含240 000个单词， 你认为每种查找最多需要多少步？ 如果要查找的单词位于字典末尾，使用简单查找将需要240 000步。使用二分查找时，每次排除一半单词，直到最后只剩下一个单词。</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210829092007999.png" alt="image-20210829092007999"></p><p>可见，随着要猜的范围越来越大，二分查找的优势也越加凸显，而二分查找所需的步数也符合对数的规律</p><blockquote><p>二分查找最多需要log2n步</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单查找-1"><a href="#简单查找-1" class="headerlink" title="简单查找"></a>简单查找</h3><p>我们首先看简单查找的代码实现（这里包括后面只会给出图片格式的代码，因为更多的希望通过实操去理解每个算法的过程）</p><p>直接通过遍历，一个一个判断，最后返回结果</p><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%AE%80%E5%8D%95%E6%9F%A5%E6%89%BE.png" alt></p><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>看看二分查找的实现代码（因为是根据自己的理解所写，所以多多少少可能会有不合理的地方，望指出）</p><ol><li>首先是写一个回答函数，相当于提问者的回答，传入参数包括回答者的数字和正确的数字</li><li>接着便是使用二分法进行猜数，每次猜中间数，对了返回，不对就根据情况进行数组裁剪，裁剪完继续重复该函数（递归思想）</li></ol><p><img src= "/img/loading.gif" data-src="/2021/08/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png" alt="二分查找"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>O(log n)比O(n)快（也就是二分法比简单查找快），当需要搜索的元素越多时，前者比后者快得越多</p></blockquote>]]></content>
    
    <summary type="html">
    
      二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/"/>
    <id>http://dong-666.github.io/2021/07/22/%E9%80%92%E5%BD%92/</id>
    <published>2021-07-22T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>作用：递归只是让解决方案更清晰，并没有性能上的优势，如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解(但在我看来，递归有时候也很难理解)</p></blockquote><p><a href="https://ypigy.gitee.io/2021/03/23/%E5%88%A9%E7%94%A8%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/" target="_blank" rel="noopener">斐波那契数列</a>就是运用递归的想法进行计算</p><h2 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h2><blockquote><p>每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基线条件</span></span><br><span class="line"><span class="keyword">if</span> (newArr.length === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> newArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归条件</span></span><br><span class="line"><span class="keyword">return</span> newArr.pop() + sum(newArr);</span><br></pre></td></tr></table></figure><p>上面为利用递归进行累加的函数</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>栈只有两种操作：压入 （插入）和弹出（删除并读取）</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829162227622.png" alt="image-20210829162227622"></p><p>数组的压入与弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.pop() <span class="comment">//弹出</span></span><br><span class="line">array.push() <span class="comment">//压入</span></span><br></pre></td></tr></table></figure><p>计算机在内部使用被称为调用栈的栈</p><h3 id="函数与调用栈"><a href="#函数与调用栈" class="headerlink" title="函数与调用栈"></a>函数与调用栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bye</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  hi();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bye'</span>);</span><br><span class="line">&#125;</span><br><span class="line">bye();</span><br></pre></td></tr></table></figure><p>下面分析调用bye()发生的事</p><p>首先会为bye分配内存控件，以及该函数所创建的变量也会放到内存</p><p>接着里面会调用另一个函数，所以会在bye上面压入另一个函数hi()，开辟新的内存，同时为其变量分配内存，最后如下图，就像压入一样的操作，根据调用顺序压入内存</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829163034381.png" alt="image-20210829163034381"></p><p>接着就是函数执行，从上到下执行，先弹出最顶部的函数（对应嵌套最深的函数）进行执行，接着一步一步往下执行，最后到最底部的函数（就是最外层函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">hi</span><br><span class="line">bye</span><br></pre></td></tr></table></figure><h2 id="实操-阶乘"><a href="#实操-阶乘" class="headerlink" title="实操-阶乘"></a>实操-阶乘</h2><p>简单阶乘的实现使用了递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fact = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * fact(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析其调用栈如何变化</p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164134539.png" alt="image-20210829164134539"></p><p><img src= "/img/loading.gif" data-src="/2021/07/22/%E9%80%92%E5%BD%92/image-20210829164213432.png" alt="image-20210829164213432"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>递归指的是调用自己的函数。 </li><li>每个递归函数都有两个条件：基线条件和递归条件。</li><li>栈有两种操作：压入和弹出。</li><li>所有函数调用都进入调用栈。</li><li>调用栈可能很长，这将占用大量的内存。</li></ul>]]></content>
    
    <summary type="html">
    
      从前有座山，山里有座庙，庙里有个老和尚。。。
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大O表示法</title>
    <link href="http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://dong-666.github.io/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2021-07-20T06:00:00.000Z</published>
    <updated>2022-03-02T07:59:36.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><blockquote><p>大O表示法指出了算法有多块</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095256434.png" alt="image-20210829095256434"></p><ol><li>大 O 表示法指出了最糟情况下的运行时间（算法执行步数）<ul><li>除最糟情况下的运行时间外，还应考虑平均情况的运行时间</li></ul></li></ol><h2 id="一些常见的大-O-运行时间"><a href="#一些常见的大-O-运行时间" class="headerlink" title="一些常见的大 O 运行时间"></a>一些常见的大 O 运行时间</h2><ol><li>O(log n)，也叫对数时间，这样的算法包括二分查找。 </li><li>O(n)，也叫线性时间，这样的算法包括简单查找。</li><li>O(n * log n)，一种速度较快的排序算法。</li><li>O(n2 )，一种速度较慢的排序算法。</li><li>O(n!)，包括旅行商问题等——一种非常慢的算法。</li></ol><p><img src= "/img/loading.gif" data-src="/2021/07/20/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/image-20210829095521599.png" alt="image-20210829095521599"></p><h2 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h2><blockquote><p>算法的速度指的并非时间，而是操作数的增速。</p><p>谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 </p><p>算法的运行时间用大O表示法表示。</p><p>大O表示法省略诸如1/2这样的常数</p></blockquote>]]></content>
    
    <summary type="html">
    
      大O表示法指出了算法有多块
    
    </summary>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://Dong-666.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-应用层</title>
    <link href="http://dong-666.github.io/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://dong-666.github.io/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-04-18T07:28:20.000Z</published>
    <updated>2022-04-17T13:32:10.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：内容根据《计算机网络第七版》以及相关PPT整理制作，图片主要源于{电子工程出版社}，部分图片源于学校老师上课所画的图以及自己制作的思维导图</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><blockquote><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。</p><p>应用层的许多协议都是基于客户服务器方式。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 </p></blockquote><h1 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h1><h2 id="域名系统概述"><a href="#域名系统概述" class="headerlink" title="域名系统概述"></a>域名系统概述</h2><p>许多应用层软件经常直接使用域名系统 DNS (Domain Name System)，但计算机的用户只是<strong>间接</strong>而不是直接使用域名系统。 </p><p>互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。</p><p>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。 </p><h2 id="互联网的域名结构"><a href="#互联网的域名结构" class="headerlink" title="互联网的域名结构"></a>互联网的域名结构</h2><p>互联网采用了层次树状结构的命名方法。</p><p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</p><p>域名的结构由标号序列组成，各标号之间用点隔开：</p><blockquote><p>… . 三级域名 . 二级域名 . 顶级域名</p></blockquote><p>各标号分别代表不同级别的域名。 </p><p>在这里，域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><p>变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。</p><p>域名中的“点”和点分十进制 IP 地址中的“点”并无一一对应的关系。点分十进制 IP 地址中一定是包含三个“点”，但每一个域名中“点”的数目则不一定正好是三个。 </p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>国家顶级域名 nTLD，例如：</p><ol><li>.cn 表示中国，</li><li>.us 表示美国，</li><li>.uk 表示英国，等。</li></ol><p>通用顶级域名 gTLD，最早的顶级域名是：</p><ol><li>.com（公司和企业）</li><li>.net（网络服务机构</li><li>.org（非赢利性组织）</li><li>.edu（美国专用的教育机构）</li><li>.gov（美国专用的政府部门）</li><li>.mil（美国专用的军事部门）</li><li>.int（国际组织）</li></ol><p>基础结构域名 </p><ol><li>这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名。 </li></ol><p>直接上图表示这些域名关系</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408200642243.png" alt="image-20210408200642243"></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。</p><p>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</p><p>每一个区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到 IP 地址的映射。</p><p>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408200752803.png" alt="image-20210408200752803"></p><p>树状结构的 DNS 域名服务器</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408201212011.png" alt="image-20210408201212011"></p><p>域名服务器分为四种：</p><ol><li>根域名服务器 </li><li>顶级域名服务器 </li><li>权限域名服务器 </li><li>本地域名服务器 </li></ol><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</p><p>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</p><p>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a  一直到 m（前 13 个字母）。</p><p>这里注意：13个不同IP地址的根域名服务器并不意味着只有13个机器，而是共有13套装置</p><pre><code>a.rootservers.netb.rootservers.net… m.rootservers.net</code></pre><p>到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408202756097.png" alt="image-20210408202756097"></p><blockquote><p> 根域名服务器并不直接把域名直接转换成 IP 地址。<br> 在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器。</p></blockquote><h3 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h3><p>顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。</p><p>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </p><h3 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h3><p>负责一个区的域名服务器。</p><p>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p><h3 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h3><p>本地域名服务器对域名系统非常重要。</p><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。</p><h3 id="提高域名服务器的可靠性"><a href="#提高域名服务器的可靠性" class="headerlink" title="提高域名服务器的可靠性"></a>提高域名服务器的可靠性</h3><p>DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。</p><p>当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。</p><p>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</p><h2 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h2><p><strong>主机向本地域名服务器的查询一般都是采用递归查询。</strong>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份（替前一个主机继续查询），向其他根域名服务器继续发出查询请求报文。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408204141405.png" alt="image-20210408204141405"></p><blockquote><p>本地域名服务器向根域名服务器进行递归查询的比较少采用，主要使用下面的迭代查询进行</p></blockquote><p><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</strong>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408203800415.png" alt="image-20210408203800415"></p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。</p><p>可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 </p><p>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时<br>器，并处理超过合理时间的项（例如，每个项目只存放两天）。</p><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。 </p><h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h1><h2 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h2><p>文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。</p><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p><p>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>RFC 959 很早就成为了互联网的正式标准。 </p><h3 id="要知道，文件传送可不是一件简单的事情"><a href="#要知道，文件传送可不是一件简单的事情" class="headerlink" title="要知道，文件传送可不是一件简单的事情"></a>要知道，文件传送可不是一件简单的事情</h3><p>网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的计算机中。</p><p>初看起来，在两个主机之间传送文件是很简单的事情。</p><p>其实这往往非常困难。原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。 </p><h2 id="FTP-的基本工作原理"><a href="#FTP-的基本工作原理" class="headerlink" title="FTP 的基本工作原理"></a>FTP 的基本工作原理</h2><p>网络环境下复制文件的复杂性：</p><ol><li>计算机存储数据的格式不同。</li><li>文件的目录结构和文件命名的规定不同。</li><li>对于相同的文件存取功能，操作系统使用的命令不同。</li><li>访问控制方法不同。 </li></ol><h2 id="FTP工作特点"><a href="#FTP工作特点" class="headerlink" title="FTP工作特点"></a>FTP工作特点</h2><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</p><p>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p><p>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p><h3 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h3><ol><li><p>打开熟知端口（端口号为 21），使客户进程能够连接上。</p></li><li><p>等待客户进程发出连接请求。</p></li><li><p>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</p></li><li><p>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。 </p></li></ol><h3 id="FTP-使用的两个-TCP-连接"><a href="#FTP-使用的两个-TCP-连接" class="headerlink" title="FTP 使用的两个 TCP 连接"></a>FTP 使用的两个 TCP 连接</h3><p><strong>控制连接</strong>在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</p><p>实际用于传输文件的是<strong>“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</p><p><strong>数据传送进程实际完成文件的传送</strong>，在传送完毕后关闭“数据传送连接”并结束运行。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210408214816503.png" alt="image-20210408214816503"></p><p>那么这个过程是否就需要占用两个端口号来建立两个不同的连接嘞，答案是肯定的</p><ol><li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。</li><li>接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。</li><li>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</li></ol><p>这样的好处是啥</p><ol><li>使协议更加简单和更容易实现。</li><li>在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</li></ol><h2 id="简单文件传送协议-TFTP"><a href="#简单文件传送协议-TFTP" class="headerlink" title="简单文件传送协议 TFTP"></a>简单文件传送协议 TFTP</h2><p>TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。</p><p>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</p><p>TFTP 只支持文件传输而不支持交互。</p><p>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 </p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据 PDU 也称为文件块 (block)，每个块按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。 </li></ul><h3 id="如同停止等待协议"><a href="#如同停止等待协议" class="headerlink" title="如同停止等待协议"></a>如同停止等待协议</h3><ul><li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</li><li>发完数据后<strong>在规定时间内收不到确认就要重发数据 PDU</strong>。</li><li>发送确认 PDU 的一方<strong>若在规定时间内收不到下一个文件块，也要重发确认 PDU</strong>。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。 </li><li>开始工作时，TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为  69。</li><li>TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。</li><li>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。</li><li>若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满 512 字节，这正好可作为文件结束的标志。</li></ul><h1 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，也是互联网的正式标准。</p><p>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</p><p>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 </p><p>现在由于 PC 的功能越来越强，用户已较少使用 TELNET 了。</p><p>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。</p><p>和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409070642758.png" alt="image-20210409070642758"></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>客户软件把用户的击键和命令转换成 <strong>NVT 格式</strong>，并送交服务器。</p><p>服务器软件把收到的数据和命令，从 <strong>NVT 格式转换成远地系统所需的格式</strong>。</p><p>向用户返回数据时，服务器把<strong>远地系统的格式转换为 NVT 格式</strong>，本地客户再从 <strong>NVT 格式转换到本地系统所需的格式</strong>。 </p><h1 id="万维网-WWW🔺"><a href="#万维网-WWW🔺" class="headerlink" title="万维网 WWW🔺"></a>万维网 WWW🔺</h1><h2 id="万维网概述"><a href="#万维网概述" class="headerlink" title="万维网概述"></a>万维网概述</h2><blockquote><p>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。<br>万维网是一个大规模的、联机式的信息储藏所。<br>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。<br>这种访问方式称为“链接”。</p></blockquote><p>万维网提供分布式服务</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409070913440.png" alt="image-20210409070913440"></p><p>万维网是<strong>分布式超媒体 (hypermedia) 系统</strong>，它是<strong>超文本 (hypertext) 系统</strong>的扩充。</p><p><strong>一个超文本由多个信息源链接成。</strong>利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。</p><p><strong>超媒体与超文本的区别是文档内容不同。</strong>超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>万维网以<strong>客户 - 服务器</strong>方式工作。</p><p>浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。</p><p>客户程序向服务器程序<strong>发出请求</strong>，服务器程序向客户程序<strong>送回</strong>客户所要的<strong>万维网文档</strong>。</p><p>在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。</p><p>好的，问题来了，通过以下问题，我们将直接引出后几节的内容</p><p>(1) 怎样标志分布在整个互联网上的万维网文档？<br>使用<strong>统一资源定位符 URL</strong> (Uniform Resource Locator) 来标志万维网上的各种文档。使每一个文档在整个互联网的范围内具有唯一的标识符 URL。 </p><p>(2) 用何协议实现万维网上各种超链的链接？<br>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP (HyperText Transfer Protocol)</strong>。<br>HTTP 是一个应用层协议，它<strong>使用 TCP 连接进行可靠的传送</strong>。 </p><p>(3) 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？<br><strong>超文本标记语言 HTML (HyperText Markup Language)</strong> 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 </p><p>(4) 怎样使用户能够很方便地找到所需的信息？<br>为了在万维网上方便地查找信息，用户可使用各种<strong>的搜索工具（即搜索引擎）</strong>。 </p><h2 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h2><p>资源定位符 URL 是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示。<br>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。<br>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。<br>URL 相当于一个文件名在网络范围的扩展。因此 <strong>URL 是与互联网相连的机器上的任何可访问对象的一个指针</strong>。 </p><h3 id="URL-的一般形式"><a href="#URL-的一般形式" class="headerlink" title="URL 的一般形式"></a>URL 的一般形式</h3><p>由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。</p><p>注意：对大小写没有要求，也就是说不管你输入home还是HOME，它的意思都是一样的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409072803806.png" alt="image-20210409072803806"></p><p>&lt;主机&gt; 是存放资源的主机在互联网中的域名</p><p>现在有些浏览器为了方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字符添上。<br>例如，用户只要键入 ypigy.gitee.io，浏览器就自动把未键入的字符补齐，变成<a href="https://ypigy.gitee.io/。" target="_blank" rel="noopener">https://ypigy.gitee.io/。</a></p><p><a href="https://ypigy.gitee.io/2021/03/01/%E5%85%AD%E3%80%81Vue%20Router%E5%85%A5%E9%97%A8/#URL" target="_blank" rel="noopener">HTTP格式的URL</a>，点击了解完整url的含义</p><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><p>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。<br>从层次的角度看，HTTP 是面向事务的 (transaction-oriented) 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 </p><h3 id="万维网的工作过程"><a href="#万维网的工作过程" class="headerlink" title="万维网的工作过程"></a>万维网的工作过程</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409073310895.png" alt="image-20210409073310895"></p><p>每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。<br>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接就被释放了。</p><blockquote><p>在浏览器和服务器之间的<strong>请求</strong>和<strong>响应</strong>的交互，必须按照规定的格式和遵循一定的规则。<strong>这些格式和规则就是超文本传送协议 HTTP</strong>。</p></blockquote><p>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME (MIME-like)”的响应组成。</p><p><strong>最后再强调一遍：HTTP 报文通常都使用 TCP 连接传送。</strong></p><h3 id="HTTP-的主要特点"><a href="#HTTP-的主要特点" class="headerlink" title="HTTP 的主要特点"></a>HTTP 的主要特点</h3><ol><li>HTTP 使用了<strong>面向连接的 TCP</strong> 作为运输层协议，保证了数据的可靠传输。</li><li>HTTP 协议本身也是<strong>无连接的</strong>，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>HTTP 是<strong>面向事务</strong>的客户服务器协议。</li><li>HTTP 1.0 协议是<strong>无状态</strong>的 (stateless)。</li></ol><p>下面我们通过三报文握手来了解http协议的工作</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409082643731.png" alt="image-20210409082643731"></p><p>通过图可以看到：http请求报文是作为第三次报文发送的，这时连接也建立好了，服务器就会将请求所需要的资源发送给客户端</p><p>这个过程过后，客户端接收到了资源后，便会断开tcp连接，然后下一次需要的时候继续建立连接，然后传递数据，而如果说现在你要请求一个包含很多资源（比如很多图片）的网页，那么客户端首先建立第一次tcp连接用于请求html页面，之后资源收到断开连接后又继续发起一次tcp连接，记住：http连接是无状态，也就意味着你每次建立连接都是全新的，耗时是一样的，且如果需要登录的话，会重复登陆，这次请求是一张图片，接下来还有其它资源，就要重复发起一次又一次的tcp连接，这样会很没有效率，如何解决这个问题呢 </p><h3 id="持续连接"><a href="#持续连接" class="headerlink" title="持续连接"></a>持续连接</h3><p><strong>HTTP/1.1 协议使用持续连接 (persistent connection)。</strong></p><p>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</p><p>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p><p>大部分主流浏览器默认用的就是持久连接</p><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p><strong>非流水线方式：</strong>客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</p><p>这和之前的应用层tcp停止等待协议类似，好比你妈叫你帮忙拿酱油，你屁颠屁颠跑去拿，然后递给妈妈，这时候妈妈又叫你帮忙拿盐，你又屁颠屁颠跑去拿盐，再回来递给妈妈，再然后，你妈又叫你……，就不能一次性说完吗，你愤怒的吼着，这不，你也会流水线方式嘛。</p><p><strong>流水线方式：</strong>客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。 </p><p>老妈一听，哦对吼，拿起一张小纸条，写下要拿的东西，笑眯眯（毫无内疚）的递给你：宝贝你辛苦了，然后你就又屁颠屁颠跑去把几样东西一起拿过来递给妈妈</p><p>好的，让我们再看一种情况，如果服务器那边的资源没有更新，而浏览器已经请求过一次服务器的资源了，这时候浏览器这边每次打开该网址都要发起一次tcp连接去重复请求资源，是不是同样浪费资源呢，可不可以把这些没有更改过的资源存起来呢</p><h3 id="代理服务器（高速缓存）"><a href="#代理服务器（高速缓存）" class="headerlink" title="代理服务器（高速缓存）"></a>代理服务器（高速缓存）</h3><p>当当当当，便是代理服务器啦</p><p>代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。</p><p>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</p><p>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。 </p><p>让我们来看一张图，在没有高速缓存的情况下，多台主机对资源发起请求</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409084722171.png" alt="image-20210409084722171"></p><p>那么这条链路上的时延会很大，因为所有万维网通信量都经过这条链路</p><p>那么，使用高速缓存呢</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085015793.png" alt="image-20210409085015793"></p><p>具体步骤为</p><p>(1) 浏览器访问互联网的服务器时，要先与校园网的高速缓存建立 TCP 连接，并向高速缓存发出 HTTP 请求报文。</p><p>(2) 若高速缓存已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。</p><p>(3) 否则，高速缓存就代表发出请求的用户浏览器，与互联网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085130673.png" alt="image-20210409085130673"></p><p>(4) 源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的高速缓存。</p><p>(5) 高速缓存收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085015793.png" alt="image-20210409085015793"></p><h3 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h3><p>既然客户端要发起请求，是不是要写个什么东西告诉服务器呢，当然要，你要东西你不得先说出来你要啥让被请求方知道嘛，服务器响应也同样要给予客户端响应的，那这个东西是什么</p><p>HTTP 有两类报文：<br><strong>请求报文</strong>——从客户向服务器发送请求报文。<br><strong>响应报文</strong>——从服务器到客户的回答。</p><p>由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p><p>先来看看请求报文的结构</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409085755836.png" alt="image-20210409085755836"></p><p>报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。</p><ol><li><p>“方法”是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的操作，因此这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。 </p><p>点击<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE/#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">这里</a>查看请求方法</p></li><li><p>“URL”是所请求的资源的 URL。</p></li><li><p>“版本”是 HTTP 的版本。</p></li></ol><p>再来看看响应报文</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409090024473.png" alt="image-20210409090024473"></p><p>响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</p><ol><li>状态码都是三位数字，具体查看<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE/#%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">这里</a><ul><li>1xx 表示通知信息的，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ul></li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>万维网站点可以使用 Cookie 来跟踪用户。具体可以点击<a href="https://ypigy.gitee.io/2020/07/28/http%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">这里</a></p><p>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 </p><h2 id="万维网的文档"><a href="#万维网的文档" class="headerlink" title="万维网的文档"></a>万维网的文档</h2><h3 id="超文本标记语言-HTML"><a href="#超文本标记语言-HTML" class="headerlink" title="超文本标记语言 HTML"></a>超文本标记语言 HTML</h3><blockquote><p>超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。</p><p>HTML 定义了许多用于排版的命令（即标签）。</p><p>HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。 </p></blockquote><p>仅当 HTML 文档是以 .html 或 .htm 为后缀时，浏览器才对此文档的各种标签进行解释。</p><p>如 HTML 文档改换以 .txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文本文件。</p><p>当浏览器从服务器读取 HTML 文档后，就按照 HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。详细了解html点击<a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML (Extensible Markup Language) 是可扩展标记语言，它和 HTML 很相似。</p><p>但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。</p><p>XML 不是要替换 HTML，而是对 HTML 的补充。</p><h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。</p><p>但 XHTML 是更严格的 HTML 版本，也是一个 W3C 标准（2000年1月），是作为一种 XML 应用被重新定义的 HTML，并将逐渐取代 HTML。</p><p>新的浏览器都支持 XHTML。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS (Cascading Style Sheets) 是层叠样式表，它是一种样式表语言，用于<a href="https://www.processon.com/view/link/60434587e401fd4f9cba7ccd" target="_blank" rel="noopener">为 HTML 文档定义布局</a>。</p><p>CSS 与 HTML 的区别就是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。</p><p>通俗的讲便是，html用于定义页面架构，而css则是决定这些</p><h3 id="动态万维网文档"><a href="#动态万维网文档" class="headerlink" title="动态万维网文档"></a>动态万维网文档</h3><p>当你在自己电脑上写了一个页面，不包括任何从服务器上请求过来的数据（比如使用AJAX），然后用浏览器打开看的时候，这个时候它便是一个静态页面，如果你把它放到服务器上，那么它也依然是静态页面，因为里面的数据不能也不会发生改变，它是一个死页面</p><p><strong>静态文档</strong>是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 </p><p><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。</p><p>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。 </p><p>那么，我们如何动态改变页面的显示数据呢，毕竟，一个新闻网站每天的新闻都是新的把，购物网站的商品每天也会推荐给你不同的吧，总不能一天写一个新页面放到服务器上吧</p><h3 id="万维网服务器功能的扩充"><a href="#万维网服务器功能的扩充" class="headerlink" title="万维网服务器功能的扩充"></a>万维网服务器功能的扩充</h3><ol><li><p>增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。</p></li><li><p>增加一个机制，用来使万维网服务器把浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409092216962.png" alt="image-20210409092216962"></p><p>就是如图所示：使用CGI来创建动态文档，那么CGI是啥</p><h3 id="CGI-程序"><a href="#CGI-程序" class="headerlink" title="CGI 程序"></a>CGI 程序</h3><p>CGI 程序的正式名字是 CGI 脚本 (script)。</p><p>“脚本”指的是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。</p><p>脚本运行起来要比一般的编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令），而不是直接被指令处理器来处理。 </p><h3 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h3><p>活动文档 (active document) 技术把所有的工作都转移给浏览器端。</p><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。</p><p>活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。<br>由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409093246471.png" alt="image-20210409093246471"></p><p>JAVA是活动文档技术的一部分，这里不展开，可自行百度</p><h2 id="万维网的信息检索系统"><a href="#万维网的信息检索系统" class="headerlink" title="万维网的信息检索系统"></a>万维网的信息检索系统</h2><p>在万维网中用来进行搜索的程序叫做搜索引擎。</p><h3 id="全文检索搜索"><a href="#全文检索搜索" class="headerlink" title="全文检索搜索"></a>全文检索搜索</h3><p>全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。</p><p>用户在查询时只要输入关键词，就从已经建立的索引数据库上进行查询（并不是实时地在互联网上检索到的信息）。</p><p>著名的有google、baidu 以及bing</p><h3 id="分类目录搜索"><a href="#分类目录搜索" class="headerlink" title="分类目录搜索"></a>分类目录搜索</h3><p><strong>分类目录搜索引擎</strong>并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。</p><p>分类目录搜索也叫做<strong>分类网站搜索</strong>。 </p><p>著名的有雅虎、新浪以及网易</p><h3 id="垂直搜索引擎"><a href="#垂直搜索引擎" class="headerlink" title="垂直搜索引擎"></a>垂直搜索引擎</h3><p><strong>垂直搜索引擎 (Vertical Search Engine)</strong> 针对某一特定领域、特定人群或某一特定需求提供搜索服务。<br>垂直搜索也是提供关键字来进行搜索的，但被放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。 </p><h2 id="博客和微博"><a href="#博客和微博" class="headerlink" title="博客和微博"></a>博客和微博</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>博客是万维网日志 (weblog) 的简称。也有人把 blog 进行音译，译为“部落格”，或“部落阁”。还有人用“博文”来表示“博客文章”。</p><p>Weblog 这个新词是 Jorn Barger 于 1997 年创造的。</p><p>简写的 blog（这是今天最常用的术语）则是 Peter Merholz 于 1999 年创造的。</p><p>有人把 blog 既当作名词，也当作动词，表示编辑博客或写博客。 </p><p>博客已经极大地扩充了互联网的应用和影响 。</p><p>在博客出现以前，网民是互联网上内容的消费者。</p><p>但博客改变了这种情况，网民不仅是互联网上内容的消费者，而且还是互联网上内容的生产者 。  </p><h3 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h3><p>没啥好说的，大部分人都在用，它和博客最大的区别就是，博客更像是一个个人网站，用来写一些比较大型的文章或技术内容，而微博更多则是分享自己的片段、碎语，三言两语</p><h2 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h2><p>社交网站 SNS (Social Networking Site) 是近年来发展非常迅速的一种网站，其作用是为一群拥有相同兴趣与活动的人创建在线社区</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h2><p>电子邮件 (e-mail)：指使用电子设备交换的邮件及其方法。电子邮件是互联网上使用得最多的和最受用户欢迎的一种应用。</p><p><strong>优点：</strong>使用方便，传递迅速，费用低廉，可以传送多种类型的信息（包括：文字信息，声音和图像等）。</p><p>电子邮件的重要标准包括以下部分</p><ol><li>简单邮件发送协议：SMTP</li><li>互联网文本报文格式</li><li>通用互联网邮件扩充 MIME</li><li>邮件读取协议：POP3 和 IMAP</li></ol><p>通过以下图片理解邮件通信的各个组成部分</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409100723015.png" alt="image-20210409100723015"></p><h3 id="用户代理-UA-User-Agent"><a href="#用户代理-UA-User-Agent" class="headerlink" title="用户代理 UA (User Agent)"></a>用户代理 UA (User Agent)</h3><p>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件。<br>用户代理的功能：撰写、显示、处理和通信。</p><p>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</p><p>邮件服务器按照客户 - 服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。</p><p>用户与电子邮件系统的接口。又被称为电子邮件客户端软件。</p><p>基本功能：撰写、显示、处理和通信。</p><h3 id="邮件服务器-Mail-Server"><a href="#邮件服务器-Mail-Server" class="headerlink" title="邮件服务器 (Mail Server)"></a>邮件服务器 (Mail Server)</h3><p>又被称为邮件传输代理。</p><p>功能：发送和接收邮件，同时还要向发信人报告邮件传送的情况。<br>按照客户 – 服务器方式工作。</p><p>在发送和读取邮件时使用两个不同的协议：SMTP，POP3。</p><h3 id="邮件发送和读取协议"><a href="#邮件发送和读取协议" class="headerlink" title="邮件发送和读取协议"></a>邮件发送和读取协议</h3><p>邮件发送和读取使用不同的协议协议。</p><ol><li><p>简单邮件发送协议 SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。</p></li><li><p>邮局协议 POP3：用于用户代理从邮件服务器读取邮件。</p></li></ol><p>通信双发既可以是客户也可以是服务器，当你是写信方时，你便是客户，收信方是服务器，放过来便是相反，对方是客户，你是服务器</p><p>还要注意的是：<strong>SMTP和POP3（或IMAP）都是使用TCP连接来传送邮件的，目的是为了可靠地传送邮件。</strong></p><p>仔细观察下面的图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409101409058.png" alt="image-20210409101409058"></p><p>发送方发送邮件是通过一条跨越互联网的线过去到达服务器端端，所以请注意：<strong>邮件不会在互联网中的某个中间邮件服务器落地</strong></p><p>发送方是通过“推（push）”的方式讲邮件发送出去，而接收方则是通过“拉（pull）”的方式接收邮件的</p><h3 id="发送和接收电子邮件的几个重要步骤"><a href="#发送和接收电子邮件的几个重要步骤" class="headerlink" title="发送和接收电子邮件的几个重要步骤"></a>发送和接收电子邮件的几个重要步骤</h3><ol><li>发件人调用 PC 中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器。</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。 </li><li>运行在接收方邮件服务器中的SMTP服务器进 程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 </li><li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3（或 IMAP）协议读取发送给自己的邮件。 </li></ol><h3 id="电子邮件的组成"><a href="#电子邮件的组成" class="headerlink" title="电子邮件的组成"></a>电子邮件的组成</h3><p>电子邮件由信封 (envelope) 和内容 (content) 两部分组成。</p><p>电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容。</p><p>在邮件的信封上，最重要的就是收件人的地址。 </p><h4 id="电子邮件地址的格式"><a href="#电子邮件地址的格式" class="headerlink" title="电子邮件地址的格式"></a>电子邮件地址的格式</h4><blockquote><p>收件人邮箱名@邮箱所在主机的域名      </p></blockquote><p>这便是TCP/IP 体系的电子邮件系统规定电子邮件地址的格式</p><p>符号“@”读作“at”，表示“在”的意思。<br>例如电子邮件地址 <a href="mailto:xiexiren@tsinghua.org.cn">xiexiren@tsinghua.org.cn</a></p><p>这里要注意两点</p><ol><li><p>这个用户名（ xiexiren）在该域名的范围内是唯一的。 </p></li><li><p>邮箱所在的主机的域名（tsinghua.org.cn）在全世界必须是唯一的 </p></li></ol><h2 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h2><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409100723015.png" alt="image-20210409100723015"></p><p>SMTP 规定了在两个相互通信的 SMTP 进程交换信息的方法。</p><p>SMTP 使用客户–服务器方式。</p><p>SMTP 基于 TCP 实现客户与服务器的通信。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102248512.png" alt="image-20210409102248512"></p><p>SMTP 是一个基于文本的 （即 ASCII 码） 的协议。 </p><p>SMTP 客户与服务器之间采用命令-响应方式进行交互。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102308510.png" alt="image-20210409102308510"></p><p>SMTP 基于 TCP 实现客户与服务器之间的通信。</p><h3 id="SMTP-通信的三个阶段"><a href="#SMTP-通信的三个阶段" class="headerlink" title="SMTP 通信的三个阶段"></a>SMTP 通信的三个阶段</h3><p><strong>连接建立：</strong>连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。   </p><p><strong>邮件传送</strong></p><p><strong>连接释放：</strong>邮件发送完毕后，SMTP 应释放 TCP 连接。 </p><p>通过图来理解这个过程（这个过程其实和http协议进行通信有点类似）</p><ol><li><p>首先是建立连接用于传送邮件</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102449163.png" alt="image-20210409102449163"></p></li><li><p>接着就是传送邮件了</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102751440.png" alt="image-20210409102751440"></p></li><li><p>然后就是邮件传送完，连接释放</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409102825471.png" alt="image-20210409102825471"></p></li></ol><h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p>一个电子邮件分为信封和内容两大部分。</p><p>RFC 5322 只规定了邮件内容中的首部 (header) 格式，而对邮件的主体 (body) 部分则让用户自由撰写。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103109432.png" alt="image-20210409103109432"></p><p>对图中各个名词进行解释</p><ol><li>“To:” 后面填入一个或多个收件人的电子邮件地址。用户只需打开地址簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。</li><li>“Subject:” 是邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。</li><li>“Cc:”  表示应给某某人发送一个邮件副本。</li><li>“From” 和 “Date” 表示发信人的电子邮件地址和发信日期。</li><li>“Reply-To” 是对方回信所用的地址。 </li></ol><h2 id="邮件读取协议-POP3-和-IMAP"><a href="#邮件读取协议-POP3-和-IMAP" class="headerlink" title="邮件读取协议 POP3 和 IMAP"></a>邮件读取协议 POP3 和 IMAP</h2><p>正如标题：现在有两个常用的邮件读取协议：</p><ol><li>POP3：邮局协议 (Post Office Protocol) 第3个版本 </li><li>IMAP：网际报文存取协议 (Internet Message Access Protocol)</li></ol><p>首先了解下POP3协议</p><h3 id="POP3-协议"><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h3><p>POP3 使用客户–服务器方式。</p><p>POP3 基于TCP实现客户与服务器的通信。</p><p>POP3 支持用户鉴别。</p><p><strong>POP3 服务器会删除被用户读取了的邮件。</strong>（也就是阅完即焚）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103251660.png" alt="image-20210409103251660"></p><h3 id="IMAP-协议"><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h3><p>IMAP 使用客户–服务器方式。</p><p>IMAP 基于TCP实现客户与服务器的通信。</p><p>IMAP是一个联机协议。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409103428001.png" alt="image-20210409103428001"></p><p>IMAP的特点如下</p><ol><li>连接后只下载<strong>邮件首部</strong>（部分下载）。</li><li>用户直接在IMAP服务器上创建和管理文件夹。</li><li>用户可以<strong>搜索</strong>邮件内容。</li><li>用户可以在不同的地方使用不同的计算机<strong>随时</strong>上网阅读和处理自己的邮件。</li><li>允许收信人只读取邮件中的<strong>某一个部分</strong>。</li><li><strong>缺点：</strong>要想查阅邮件，必须先联网。</li></ol><h3 id="IMAP-与-POP3-比较"><a href="#IMAP-与-POP3-比较" class="headerlink" title="IMAP 与 POP3 比较"></a>IMAP 与 POP3 比较</h3><table><thead><tr><th>操作位置</th><th>操作内容</th><th>IMAP</th><th>POP3</th></tr></thead><tbody><tr><td>收件箱</td><td>阅读、标记、移动、删除邮件等</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>发件箱</td><td>保存到已发送</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>创建文件夹</td><td>新建自定义的文件夹</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>草稿</td><td>保存草稿</td><td>客户端与邮箱更新同步</td><td>仅在客户端内</td></tr><tr><td>垃圾文件夹</td><td>接收并移入垃圾文件夹的邮件</td><td>支持</td><td>不支持</td></tr><tr><td>广告邮件</td><td>接收并移入广告邮件夹的邮</td><td>支持</td><td>不支持</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104202426.png" alt="image-20210409104202426"></p><p>这里要好好区别，邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 完全不同。</p><p>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。<br>而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 </p><p>简单来说：发邮件是用<strong>SMTP</strong>协议，而收文件是在<strong>pop3</strong>和<strong>imap</strong>协议中挑一个去收</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104425895.png" alt="image-20210409104425895"></p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p>用户代理 (UA) 的缺点：必须在计算机中安装用户代理软件可能不能安装或不允许安装。所以会导致不方便收邮件，而且，很重要的是，你要收发文件，两个人都要开着电脑，啊这……</p><p>而这时候通过之前学的万维网以及http协议，我们是否可以把这个平台搬到互联网上呢，答案是可以的，你现在的用的邮箱不就是吗，所以，万维网电子邮件的优点是啥</p><ul><li>不需要在计算机中再安装用户代理软件。</li><li>计算机能联网，就能非常方便地收发电子邮件。</li><li>电子邮件界面非常友好。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409104824166.png" alt="image-20210409104824166"></p><p>通过图可以了解到其有两个特点</p><ol><li>发送、接收电子邮件时使用 HTTP 协议。</li><li>两个邮件服务器之间传送邮件时使用 SMTP。</li></ol><p>好的，互联网解决了我们之间的电子邮件交流，现在另一个问题来了，我们使用的SMTP协议好像没法发图片或者其他多媒体文件（SMTP 不能传送可执行文件或其他的二进制对象。），这咋整，我想发鸭，而且还有一个问题：SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。甚至还存在这个问题：SMTP 服务器会拒绝超过一定长度的邮件。那怎么解决呢</p><h2 id="通用互联网邮件扩充-MIME"><a href="#通用互联网邮件扩充-MIME" class="headerlink" title="通用互联网邮件扩充 MIME"></a>通用互联网邮件扩充 MIME</h2><p>对的，就是它，它可以帮我们解决上面遇到的问题，那是不是意味着就可以直接用他来取代SMTP呢，并不是这样的</p><p>MIME 的意图<strong>是继续使用目前的 [RFC 822] 格式</strong>，但<strong>增加了邮件主体的结构</strong>，并<strong>定义了传送非 ASCII 码的编码规则</strong>。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409105253804.png" alt="image-20210409105253804"></p><p>它主要包括三个部分</p><ol><li><p><strong>5 个新的邮件首部字段</strong>，它们可包含在原有首部中。这些字段提供了有关邮件主体的信息。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409105407947.png" alt="MIME首部"></p></li><li><p>定义了许多<strong>邮件内容的格式</strong>，对多媒体电子邮件的表示方法进行了标准化。</p></li><li><p>定义了<strong>传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变。</p><table><thead><tr><th>编码方法</th><th>说明</th></tr></thead><tbody><tr><td>7bit</td><td>7  位  ASCII  编码，每行不能超过  1000  个字符（包括回车和换行）。缺省编码方法。</td></tr><tr><td>8bit</td><td>8  位非  ASCII  编码，每行不能超过  1000  个字节（包括回车和换行）。</td></tr><tr><td>Binary</td><td>8  位非  ASCII  编码，任意长度的字节串。</td></tr><tr><td>Base64</td><td>将任意长度的字节串转换为用 7 位  ASCII 编码表示的字符串。可用于二进制和非文本数据的编码。</td></tr><tr><td>Quoted-printable</td><td>将任意长度的字节串转换为  ASCII  编码表示的字符串。可用于二进制和非文本数据的编码。</td></tr></tbody></table></li></ol><p>这里对各个编码方法就不继续展开了，详细可以通过书本理解</p><h3 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h3><p>MIME 着标准规定 Content-Type 说明必须含有两个标识符，即内容类型(type)和子类型(subtype)，中间用“/”分开。 </p><p>MIME 标准原先定义了 7 个基本内容类型和 15 种子类型。</p><p>MIME允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X-开始。</p><table><thead><tr><th>内容类型</th><th>子类型举例</th><th>说明</th></tr></thead><tbody><tr><td>text（文本）</td><td>plain, html, xml, css</td><td>不同格式的文本</td></tr><tr><td>image（图像）</td><td>gif, jpeg, tiff</td><td>不同格式的静止图像</td></tr><tr><td>audio（音频）</td><td>basic, mpeg, mp4</td><td>可听见的声音</td></tr><tr><td>video（视频）</td><td>mpeg, mp4, quicktime</td><td>不同格式的影片</td></tr><tr><td>model（模型）</td><td>vrml</td><td>3D模型</td></tr><tr><td>application（应用）</td><td>octet-stream, pdf,  javascript, zip</td><td>不同应用程序产生的数据</td></tr><tr><td>message（报文）</td><td>http, rfc822</td><td>封装的报文</td></tr><tr><td>multipart（多部分）</td><td>mixed, alternative, parallel, digest</td><td>多种类型的组合</td></tr></tbody></table><p>举个例子</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409110200263.png" alt="image-20210409110200263"></p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。</p><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><p>DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</p><p>步骤大致如下</p><ol><li><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。</p><p>为什么要广播，因为这时候A并不知道DHCP服务器是哪一台，所以全都发，而此时它并没有IP地址，所以这个报文的源地址也都会是0</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111807042.png" alt="image-20210409111807042"></p></li><li><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p></li><li><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。</p><ul><li>若找到，则返回找到的信息。</li><li>若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。</li></ul><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111829348.png" alt="image-20210409111829348"></p></li></ol><p>并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。</p><p>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409111903379.png" alt="image-20210409111903379"></p><h2 id="租用期-lease-period"><a href="#租用期-lease-period" class="headerlink" title="租用期 (lease period)"></a>租用期 (lease period)</h2><p>DHCP 服务器分配给 DHCP 客户的 IP 地址的<strong>临时的</strong>，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>。<br>租用期的数值应由 DHCP 服务器自己决定。<br>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。 </p><p>不是很理解为啥要租用，不能分配好了就一直用吗，可能是因为怕使用了该ip地址的主机很久不用导致ip地址浪费吧</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409112048314.png" alt="image-20210409112048314"></p><p>梳理图中的过程</p><ol><li><p>DHCP 服务器被动打开 UDP 端口 67， 等待客户端发来的报文。</p></li><li><p>DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文 DHCPDISCOVER。</p></li><li><p>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文 DHCPOFFER，因此，DHCP 客户可能收到多个 DHCP 提供报文 。</p></li><li><p>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文 DHCPREQUEST。</p></li><li><p>被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。</p><p>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</p></li><li><p>租用期过了一半（T1 时间到），DHCP 客户发送请求报文 DHCPREQUEST，要求更新租用期。 </p></li><li><p>DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。</p></li><li><p>DHCP 服务器若不同意，则发回否认报 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤  ❷）。</p><p>若 DHCP 服务器不响应步骤  ❻ 的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤  ❻），然后又继续后面的步骤。 </p></li><li><p>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</p></li></ol><h1 id="简单网络管理协议-SNMP"><a href="#简单网络管理协议-SNMP" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。</p></blockquote><p>网络管理并不是指对网络进行行政上的管理。网络管理分为五大功能</p><ol><li>故障管理：故障检测、隔离和纠正。</li><li>配置管理：初始化网络、并配置网络。</li><li>计费管理：记录网络资源的使用。</li><li>性能管理：估价系统资源的运行状况及通信效率等。</li><li>网络安全管理：对授权机制、访问控制、加密和加密关键字的管理。</li></ol><p>网络管理长这样的</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409113609272.png" alt="image-20210409113609272"></p><ul><li>管理站也常称为网络运行中心 NOC (Network Operations Center)，是网络管理系统的核心。</li><li>管理程序在运行时就成为管理进程。</li><li>管理站（硬件）或管理程序（软件）都可称为管理者(manager)。Manager 不是指人，而是指机器或软件。</li><li>网络管理员 (administrator) 指的是负责网络管理的人员。</li><li>大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li><li>被管对象<ul><li>网络的每一个被管设备中可能有多个被管对象。</li><li>被管设备有时可称为网络元素或网元。</li><li>在被管设备中也会有一些不能被管的对象。 </li></ul></li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运行着的程序叫做网络管理代理程序，或简称为代理。</p><p>代理程序在管理程序的命令和控制下在被管设备上采取本地的行动。</p><h3 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h3><p>网络管理协议简称为网管协议。</p><p>网络管理协议是管理程序和代理程序之间进行通信的规则。</p><p>网络管理员利用网络管理协议，通过管理站对网络中的被管设备进行管理。 </p><p>需要注意的是，网管协议本身不管理网络。</p><h3 id="简单网络管理协议-SNMP-1"><a href="#简单网络管理协议-SNMP-1" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h3><p>简单网络管理协议SNMP (Simple Network Management Protocol) 中的管理程序和代理程序按客户–服务器方式工作。</p><p>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。</p><p>在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。</p><h4 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h4><ul><li>SNMP 最重要的指导思想就是要尽可能简单。</li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。</li><li>在网络正常工作时，SNMP 可实现统计、配置、和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>虽然 SNMP 是在 TCP/IP 基础上的网络管理协议，但也可扩展到其他类型的网络设备上。 </li></ul><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol><li>监视网络性能</li><li>检测分析网络差错</li><li>配置网络设备等。</li></ol><h3 id="委托代理"><a href="#委托代理" class="headerlink" title="委托代理"></a>委托代理</h3><p>整个系统必须有一个管理站。</p><p>若网络元素使用的不是 SNMP 而是另一种网络管理协议，SNMP 协议就无法控制该网络元素。这时可使用委托代理 (proxy agent)。</p><p>委托代理能提供协议转换和过滤操作等功能，对被管对象进行管理。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409114208398.png" alt="image-20210409114208398"></p><h3 id="SNMP-的网络管理组成"><a href="#SNMP-的网络管理组成" class="headerlink" title="SNMP 的网络管理组成"></a>SNMP 的网络管理组成</h3><ol><li>SNMP 本身</li><li>管理信息结构 SMI (Structure of Management Information)</li><li>管理信息库 MIB (Management Information Base)。</li></ol><h2 id="管理信息结构-SMI"><a href="#管理信息结构-SMI" class="headerlink" title="管理信息结构 SMI"></a>管理信息结构 SMI</h2><blockquote><p>功能：</p><ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。 </li></ol></blockquote><p>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义的无二义性。但从 SMI 的名称并不能看出它的功能。SMI 并不定义一个实体应管理的对象数目，也不定义被管对象名以及对象名及其值之间的关联。 </p><p>首先从第一个功能，被管对象的命名上来讲</p><h3 id="被管对象命名"><a href="#被管对象命名" class="headerlink" title="被管对象命名"></a>被管对象命名</h3><p><strong>SMI 规定所有被管对象必须在命名树上</strong>，如下图</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411101957301.png" alt="image-20210411101957301"></p><p>SMI 标准指明：所有的 MIB 变量必须使用抽象语法记法 1（ASN.1）来定义。<br>SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。<br>ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102208973.png" alt="image-20210411102208973"></p><p>SMI 把数据类型分为两大类（如下图）：</p><ol><li>简单类型</li><li>结构化类型。 </li></ol><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102306749.png" alt="image-20210411102306749"></p><h3 id="基本编码规则-BER"><a href="#基本编码规则-BER" class="headerlink" title="基本编码规则 BER"></a>基本编码规则 BER</h3><p>ISO 在制订 ASN.1 语言的同时也为它定义了一种标准的编码方案，即基本编码规则 BER (Basic Encoding Rule)。<br>BER 指明了每种数据类型中每个数据的值的表示。<br>发送端用 BER 编码，可将用 ASN.1 所表述的报文转换成唯一的比特序列。<br>接收端用 BER 进行解码，得到该比特序列所表示的 ASN.1 报文。 </p><p> ASN.1把所有的数据元素都表示为T-L-V三个字段的组成的序列，T字段定义数据的类型，L字段定义V字段的长度，V字段定义数据值</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102353190.png" alt="image-20210411102353190"></p><p><strong>TLV 中的 T 字段定义数据的类型</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102504033.png" alt="image-20210411102504033"></p><p><strong>L 字段定义 V 字段的长度</strong></p><p>单字节的L字段第一位为0，后续七位定义V字段的长度</p><p>当L字段为多字节时，其最高为时1，后面七位定义后续字节的字节数（二进制整数表示），这时，所有后续字节并置起来的二进制整数定义V字段的长度</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102742467.png" alt="image-20210411102742467"></p><p><strong>V 字段定义数据的值</strong></p><table><thead><tr><th>类   型</th><th>大   小</th><th>说      明</th></tr></thead><tbody><tr><td>INTEGER</td><td>4 字节</td><td>在 –231 到  231  – 1  之间的整数</td></tr><tr><td>Interger32</td><td>4 字节</td><td>和 INTEGER  相同</td></tr><tr><td>Unsigned32</td><td>4 字节</td><td>在 0  到  232  – 1  之间的无符号数</td></tr><tr><td>OCTET  STRING</td><td>可变</td><td>不超过  65535 字节长的字节串</td></tr><tr><td>OBJECT  IDENTIFIER</td><td>可变</td><td>对象标识符</td></tr><tr><td>IPAddress</td><td>4 字节</td><td>由 4  个整数组成的IP地址</td></tr><tr><td>Counter32</td><td>4 字节</td><td>可从  0 增加到 232 的整数；当它到达最大值时就返回到  0</td></tr><tr><td>TimeTicks</td><td>4 字节</td><td>记录时间的计数值，以  1/100 秒为单位</td></tr><tr><td>BITS</td><td>—</td><td>比特串</td></tr><tr><td>Opaque</td><td>可变</td><td>不解释的串</td></tr></tbody></table><p>例如，INTEGER 15，其 T 字段是02， INTEGER 类型要用 4 字节编码。最后得出 TLV 编码为 02 04 00 00 00 0F。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104028469.png" alt="image-20210411104028469"></p><p> V 字段<strong>可嵌套</strong>其他数据元素的 TLV 字段</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411103814658.png" alt="image-20210411103814658"></p><h2 id="管理信息库-MIB"><a href="#管理信息库-MIB" class="headerlink" title="管理信息库 MIB"></a>管理信息库 MIB</h2><p>被管对象必须维持可供管理程序读写的若干控制和状态信息。这些信息总称为管理信息库  MIB (Management Information Base) 。<br>管理程序使用 MIB 中这些信息的值对网络进行管理（如读取或重新设置这些值）。<br>只有在 MIB 中的对象才是 SNMP 所能够管理的。</p><p><strong>节点 mib-2 所包含的信息类别举例</strong></p><table><thead><tr><th>类  别</th><th>标 号</th><th>所包含的信息</th></tr></thead><tbody><tr><td>system</td><td>(1)</td><td>主机或路由器的操作系统</td></tr><tr><td>interfaces</td><td>(2)</td><td>各种网络接口</td></tr><tr><td>address  translation</td><td>(3)</td><td>地址转换（例如，ARP 映射）</td></tr><tr><td>ip</td><td>(4)</td><td>IP 软件</td></tr><tr><td>icmp</td><td>(5)</td><td>ICMP  软件</td></tr><tr><td>tcp</td><td>(6)</td><td>TCP  软件</td></tr><tr><td>udp</td><td>(7)</td><td>UDP  软件</td></tr><tr><td>egp</td><td>(8)</td><td>EGP  软件</td></tr></tbody></table><p>MIB <strong>变量的例子</strong></p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104236265.png" alt="image-20210411104236265"></p><h2 id="SNMP-的协议数据单元和报文"><a href="#SNMP-的协议数据单元和报文" class="headerlink" title="SNMP 的协议数据单元和报文"></a>SNMP 的协议数据单元和报文</h2><p>SNMP 的操作只有两种基本的管理功能：</p><ol><li>“读”操作，用 get 报文来检测各被管对象的状况；</li><li>“写”操作，用 set 报文来改变各被管对象的状况。</li></ol><p>SNMP 的这些功能通过探询操作来实现。</p><h3 id="探寻操作"><a href="#探寻操作" class="headerlink" title="探寻操作"></a>探寻操作</h3><blockquote><p>探询操作 —— SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p></blockquote><p>探询的好处：</p><ol><li>可使系统相对简单。</li><li>能限制通过网络所产生的管理信息的通信量。</li></ol><p>探询的缺点：</p><ol><li>不够灵活，而且所能管理的设备数目不能太多。</li><li>开销也较大。</li></ol><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p><strong>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。</strong></p><p>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件（即过滤）。</p><p>过滤的好处是：</p><ol><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。 </li></ol><p>使用探询（至少是周期性地）以维持对网络资源的实时监视。<br>同时也采用陷阱机制报告特殊事件，使得 SNMP 成为一种有效的网络管理协议。 </p><h3 id="SNMP-使用无连接的-UDP"><a href="#SNMP-使用无连接的-UDP" class="headerlink" title="SNMP 使用无连接的 UDP"></a>SNMP 使用无连接的 UDP</h3><p>SNMP 使用无连接的 UDP。但 UDP 不保证可靠交付。</p><p>在运行代理程序的服务器端用熟知端口 161 来接收 get 或 set 报文和发送响应报文（与熟知端口通信的客户端使用临时端口）。<br>运行管理程序的客户端则使用熟知端口 162 来接收来自各代理的 trap 报文。 </p><h3 id="SNMPv1-定义的协议数据单元-PDU-类型"><a href="#SNMPv1-定义的协议数据单元-PDU-类型" class="headerlink" title="SNMPv1 定义的协议数据单元 (PDU) 类型"></a>SNMPv1 定义的协议数据单元 (PDU) 类型</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104738807.png" alt="image-20210411104738807"></p><h3 id="SNMP-的报文格式"><a href="#SNMP-的报文格式" class="headerlink" title="SNMP 的报文格式"></a>SNMP 的报文格式</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104820927.png" alt="image-20210411104820927"></p><h3 id="Get-request-报文-ASN-1-编码"><a href="#Get-request-报文-ASN-1-编码" class="headerlink" title="Get-request 报文 ASN.1 编码"></a>Get-request 报文 ASN.1 编码</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104856701.png" alt="image-20210411104856701"></p><p>ASN.1 定义</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104933471.png" alt="image-20210411104933471"></p><h3 id="Get-request-报文的-BER-编码"><a href="#Get-request-报文的-BER-编码" class="headerlink" title="Get-request 报文的 BER 编码"></a>Get-request 报文的 BER 编码</h3><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411104957973.png" alt="image-20210411104957973"></p><p>BER 编码</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411105021274.png" alt="image-20210411105021274"></p><h1 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h1><h2 id="系统调用和应用编程接口"><a href="#系统调用和应用编程接口" class="headerlink" title="系统调用和应用编程接口"></a>系统调用和应用编程接口</h2><p>大多数操作系统使用系统调用 (system call ) 的机制在应用程序和操作系统之间传递控制权。</p><p>对程序员来说，每一个系统调用和一般程序设计中的函数调用非常相似，只是系统调用是<strong>将控制权传递给了操作系统</strong>。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409144949026.png" alt="image-20210409144949026"></p><h3 id="应用编程接口-API"><a href="#应用编程接口-API" class="headerlink" title="应用编程接口 API"></a>应用编程接口 API</h3><p>系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。</p><p>使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API (Application Programming Interface) 。</p><h2 id="几种常用的系统调用"><a href="#几种常用的系统调用" class="headerlink" title="几种常用的系统调用"></a>几种常用的系统调用</h2><p>Berkeley UNIX 操作系统定义了一种 API，它又称为<strong>套接字接口 (socket interface)</strong>。</p><p>微软公司在其操作系统中采用了套接字接口  API，形成了一个稍有不同的 API，并称之为  Windows Socket。</p><p>AT&amp;T 为其 UNIX 系统 V 定义了一种 API，简写为 TLI (Transport Layer Interface)。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409145218013.png" alt="image-20210409145218013"></p><h3 id="套接字特点及使用"><a href="#套接字特点及使用" class="headerlink" title="套接字特点及使用"></a>套接字特点及使用</h3><p>当应用进程需要使用网络进行通信时就发出系统调用，请求操作系统为其创建“套接字”，以便把网络通信所需要的系统资源分配给该应用进程。</p><p>操作系统为这些资源的总和用一个叫做套接字描述符的号码来表示。</p><p>应用进程所进行的网络操作都必须使用这个套接字描述符。<br>通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该套接字描述符相关的所有资源。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409145449361.png" alt="image-20210409145449361"></p><p>下面来讲一下如何通过套接字来调用TCP 提供面向连接的服务</p><p>总共分为三个阶段，和运输层的tcp三报文握手类似，结合图理解该过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409151143953.png" alt="image-20210409151143953"></p><ol><li><p><strong>连接建立阶段</strong></p><p>当套接字被创建后，它的端口号和 IP 地址都是空的，因此应用进程要<strong>调用 bind</strong>（绑定）来指明套接字的本地地址。在服务器端调用 bind 时就是把熟知端口号和本地 IP 地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接字。</p><p>服务器在调用 bind 后，还必须<strong>调用 listen</strong>（收听）把套接字设置为被动方式，以便随时接受客户的服务请求。<strong>UDP 服务器由于只提供无连接服务，不使用 listen 系统调用。</strong></p><p>服务器紧接着就<strong>调用 accept（接受）</strong>，以便把远地客户进程发来的连接请求提取出来。系统调用 accept 的一个变量就是要指明从哪一个套接字发起的连接。 </p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409151632523.png" alt="image-20210409151632523"></p></li><li><p><strong>数据传送阶段</strong></p><p>客户和服务器都在 TCP 连接上使用 <strong>send 系统调用传送数据</strong>，使用 <strong>recv 系统调用接收数据</strong>。</p><p>通常客户使用 send 发送请求，而服务器使用 send 发送回答。<br>服务器使用 recv 接收客户用 send 调用发送的请求。客户在发完请求后用 recv 接收回答。</p></li><li><p><strong>连接释放阶段</strong></p><p>一旦客户或服务器结束使用套接字，就把套接字撤消。这时就调用 <strong>close 释放连接</strong>和<strong>撤销套接字</strong>。</p></li></ol><h1 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h1><h2 id="具有集中目录服务器的-P2P-工作方式"><a href="#具有集中目录服务器的-P2P-工作方式" class="headerlink" title="具有集中目录服务器的 P2P 工作方式"></a>具有集中目录服务器的 P2P 工作方式</h2><p>在 P2P 工作方式下，所有的音频/视频文件都是在普通的互联网用户之间传输。</p><p>这种工作方式解决了集中式媒体服务器可能出现的瓶颈问题。</p><p>在互联网流量中，P2P 工作方式下的文件分发已占据了最大的份额，比万维网应用所占的比例大得多</p><p>世界上最早使用P2P方式的是<strong>Napster</strong>，Napster 将所有音乐文件的索引信息都集中存放在 Napster 目录服务器中。使用者只要查找目录服务器，就可知道应从何处下载所要的MP3文件。用户要及时向 Napster 的目录服务器报告自己存有的音乐文件。Napster 的文件传输是分散的，文件的定位则是集中的。</p><p>让我们通过一张图理解该过程</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409155704154.png" alt="image-20210409155704154"></p><ol><li>用户 X 向 Napster 目录服务器查询（客户–服务器方式）谁有音乐文件 MP3#。</li><li>Napster 目录服务器回答 X：有三个地点有文件 MP3#，即 A, B 和 C（给出了这三个地点的IP地址）。于是用户 X 得知所需的文件 MP3# 的三个下载地点。</li><li>用户 X 可以随机地选择三个地点中的任一个。假定 X 向 A 发送下载文件 MP3#的请求报文。双方都使用 P2P 方式通信。</li><li>对等方A（现在作为服务器）把文件MP3#发送给X。</li></ol><p><strong>集中式目录服务器同样也存在问题：可靠性差。会成为性能的瓶颈。</strong></p><h2 id="具有全分布式结构的-P2P-文件共享程序"><a href="#具有全分布式结构的-P2P-文件共享程序" class="headerlink" title="具有全分布式结构的 P2P 文件共享程序"></a>具有全分布式结构的 P2P 文件共享程序</h2><h3 id="Gnutella"><a href="#Gnutella" class="headerlink" title="Gnutella"></a>Gnutella</h3><p>Gnutella 是第二代 P2P 文件共享程序，采用<strong>全分布方法</strong>定位内容的 P2P 文件共享应用程序。 </p><p>Gnutella 与 Napster 最大的区别是：不使用集中式的目录服务器，而是使用<strong>洪泛法</strong>在大量 Gnutella <strong>用户之间进行查询</strong>。</p><p>为了不使查询的通信量过大，Gnutella 设计了一种<strong>有限范围的洪泛查询</strong>，以减少<strong>倾注到互联网的查询流量</strong>，但也<strong>影响到查询定位的准确性</strong>。 </p><h3 id="eMule"><a href="#eMule" class="headerlink" title="eMule"></a>eMule</h3><p>eMule 使用了一些服务器。这些服务器并不是保存音频/视频文件，而是保存用户的有关信息，因而可以告诉用户从哪些地方可以下载到所需的文件。</p><p>eMule 使用了专门定义的文件夹，让用户存放可以和其他用户共享的文件。</p><p>eMule 的下载文件规则是鼓励用户向其他用户上传文件。用户上传文件越多，其下载文件的优先级就越高（因而下载就越快）。</p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 所有对等方集合称为一个洪流 (torrent)，下载文件的数据单元为长度固定的文件块 (chunk)。基础设施结点，叫做追踪器 (tracker)。</p><p>A 就和这些对等方建立了 TCP 连接。所有与 A 建立了 TCP 连接的对等方为“相邻对等方”(neighboring peers)。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161511009.png" alt="image-20210409161511009"></p><p>在请求的过程中，A 使用最稀有的优先 (rarest first) 的技术，首先向其相邻对等方请求对应的文件块。<br>所谓稀有是指：如果A所缺少的文件块在相邻对等方中的副本很少，那就是“很稀有的”。</p><p>而当很多对等方需要请求文件块时，A如何决定先向谁提供呢？<br>凡当前以最高数据率向 A 传送文件块的某相邻对等方，A 就优先把所请求的文件块传送给该相邻对等方（原来计算机也这么现实）</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161524959.png" alt="image-20210409161524959"></p><p>从互联网传送数据到主机，叫做<strong>下载 (download)</strong>，从主机向互联网传送，则称为<strong>上传 (upload) 或上载</strong>。</p><h2 id="P2P-文件分发的分析"><a href="#P2P-文件分发的分析" class="headerlink" title="P2P 文件分发的分析"></a>P2P 文件分发的分析</h2><p>让我们来分析下传统的客户-服务器方式下进行数据请求的过程（结合图中的变量名）</p><p>有 N 台主机从服务器下载一个大文件，其长度为 F bit。假定主机与互联网连接的链路的上传速率和下载速率分别为 ui 和 di ，单位都是 bit/s。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409161917270.png" alt="image-20210409161917270"></p><p>从服务器端考虑，所有主机分发完毕的最短时间 Tcs 不可能小于 NF/us （每次都要建立连接）；<br>下载速率最慢的主机的下载速率为 dmin，则 Tcs 不可能小于 F/dmin  。<br>由此可得出所有主机都下载完文件 F 的最少时间是：</p><blockquote><p>Tcs = max（ NF/us，F/dmin ）</p></blockquote><p>而在P2P下的最短时间呢</p><p>初始服务器文件分发的最少时间不可能小于 F/us （只需要上传一次）；<br>下载文件分发的最少时间不可能小于 F/dmin ；<br>上载文件分发的最少时间不可能小于 NF/uT ，其中是 uT  是上传速率之和。<br>所有主机都下载完文件 F 的最少时间的下限是：<br>Tp2p &gt;= max（ F/us ， F/dmin， NF/uT  ）</p><p><strong>举个栗子比较一下</strong>（好吧其实书里这个例子我没法理解，0.75怎么得出来的搞不懂）</p><p>设所有的对等方的上传速率都是 u，并且 F/u = 1 小时。<br>设服务器的上传速率 us = 10u。<br>当 N = 30 时，<br>P2P方式：最少时间的下限是 0.75 小时 &lt; 1 小时（不管 N 多大）。<br>客户−服务器方式：最少时间是 3 小时。</p><p>看不懂？那就对了，我也看不懂（大佬给我走开），反正我就这样理解，如果采用传统的客户-服务器模式传输文件，那么你有几个主机需要文件，你就要和服务器建立几次连接，然后服务器上传文件，接着将服务器资源平均分给多台主机，然后传文件，而P2P则是服务器可以先传给一台（当然也可以多台），这时候服务器所有资源都可以给这一台主机（效率提高）单独传文件，然后服务器记录一下这台主机有这个资源，接着这台得到文件的主机可以通过服务器介绍和另外一台主机进行点对点连接传输文件，同时，服务器也可以继续和另一台传文件，如此下去，1变2，2变4，4变8，指数传递，效率提高，速度变快，服务器压力变小，一举多得啊。</p><h2 id="在-P2P-对等方中搜索对象"><a href="#在-P2P-对等方中搜索对象" class="headerlink" title="在 P2P 对等方中搜索对象"></a>在 P2P 对等方中搜索对象</h2><p>在前面我们知道：Napster在一个集中式目录服务器中构建的查找数据库虽然很简单，但性能上却有瓶颈。</p><p>Gnutella是一种采用全分布方法定位内容的P2P文件共享应用程序，它解决了集中式目录服务器所造成的瓶颈问题。然而Gnutella是在非结构化的覆盖网络中采用查询洪泛的方法来进行查找的，因此查找的效率较低。</p><p>现在广泛使用的索引和查找技术叫做分布式散列表 DHT (Distributed Hash Table)。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。广泛使用的 Chord 算法是美国麻省理工大学于2001 年提出的。</p><p>分布式散列表 DHT 利用散列函数，把资源名 K 及其存放的结点 IP 地址 N 都分别映射为资源名标识符 KID 和结点标识符 NID。<br>Chord 把结点按标识符数值从小到大沿顺时针排列成一个环形覆盖网络。</p><p>如下图所示</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409162434921.png" alt="image-20210409162434921"></p><p>每个资源由 Chord 环上与其标识符值最接近的下一个结点提供服务。</p><p>当N13加进来到节点后，N10的下一个节点就会从N20变成N13，从而资源点标识符K12也会移至该N13上</p><p>但是这个速度还不够，为了加速查找，在 Chord 环上可以增加一些指针表(finger table)，它又称为路由表或查找器表。对于结点 N4， 第 1 列第 i  行计算（N4 + 2i – 1），得出后继结点。</p><p><img src= "/img/loading.gif" data-src="/2021/04/18/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210409162724943.png" alt="image-20210409162724943"></p>]]></content>
    
    <summary type="html">
    
      离我们最近的应用层
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://Dong-666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
